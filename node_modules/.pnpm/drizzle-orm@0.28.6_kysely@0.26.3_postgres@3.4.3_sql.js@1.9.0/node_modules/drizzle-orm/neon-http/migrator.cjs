'use strict';

var migrator = require('../migrator.cjs');
var index = require('../index-1899b9ae.cjs');
require('./index.cjs');
require('node:crypto');
require('node:fs');
require('node:path');
require('@neondatabase/serverless');

/**
 * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database
 *
 * NOTE: The Neon HTTP driver does not support transactions. This means that if any part of a migration fails,
 * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.
 * @param db - drizzle db instance
 * @param config - path to migration folder generated by drizzle-kit
 */
async function migrate(db, config) {
    const migrations = migrator.readMigrationFiles(config);
    const migrationTableCreate = index.sql `
		CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at bigint
		)
	`;
    await db.session.execute(index.sql `CREATE SCHEMA IF NOT EXISTS "drizzle"`);
    await db.session.execute(migrationTableCreate);
    const dbMigrations = await db.session.all(index.sql `select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    const rowsToInsert = [];
    for await (const migration of migrations) {
        if (!lastDbMigration
            || Number(lastDbMigration.created_at) < migration.folderMillis) {
            for (const stmt of migration.sql) {
                await db.session.execute(index.sql.raw(stmt));
            }
            rowsToInsert.push(index.sql `insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
    }
    for await (const rowToInsert of rowsToInsert) {
        await db.session.execute(rowToInsert);
    }
}

exports.migrate = migrate;
//# sourceMappingURL=migrator.cjs.map
