import { readMigrationFiles } from '../migrator.mjs';
import { s as sql } from '../alias-cf8e03cd.mjs';
import '@neondatabase/serverless';
import 'node:crypto';
import 'node:fs';
import 'node:path';

/**
 * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database
 *
 * NOTE: The Neon HTTP driver does not support transactions. This means that if any part of a migration fails,
 * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.
 * @param db - drizzle db instance
 * @param config - path to migration folder generated by drizzle-kit
 */
async function migrate(db, config) {
    const migrations = readMigrationFiles(config);
    const migrationTableCreate = sql `
		CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at bigint
		)
	`;
    await db.session.execute(sql `CREATE SCHEMA IF NOT EXISTS "drizzle"`);
    await db.session.execute(migrationTableCreate);
    const dbMigrations = await db.session.all(sql `select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    const rowsToInsert = [];
    for await (const migration of migrations) {
        if (!lastDbMigration
            || Number(lastDbMigration.created_at) < migration.folderMillis) {
            for (const stmt of migration.sql) {
                await db.session.execute(sql.raw(stmt));
            }
            rowsToInsert.push(sql `insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
    }
    for await (const rowToInsert of rowsToInsert) {
        await db.session.execute(rowToInsert);
    }
}

export { migrate };
//# sourceMappingURL=migrator.mjs.map
