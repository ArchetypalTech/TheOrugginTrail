'use strict';

const entityKind = Symbol.for('drizzle:entityKind');
const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');
function is(value, type) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof
        return true;
    }
    if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
        throw new Error(`Class "${type.name ?? '<unknown>'}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
    }
    let cls = value.constructor;
    if (cls) {
        // Traverse the prototype chain to find the entityKind
        while (cls) {
            if (entityKind in cls && cls[entityKind] === type[entityKind]) {
                return true;
            }
            cls = Object.getPrototypeOf(cls);
        }
    }
    return false;
}

var _a$W;
/*
    `Column` only accepts a full `ColumnConfig` as its generic.
    To infer parts of the config, use `AnyColumn` that accepts a partial config.
    See `GetColumnData` for example usage of inferring.
*/
class Column {
    constructor(table, config) {
        this.table = table;
        this.enumValues = undefined;
        this.config = config;
        this.name = config.name;
        this.notNull = config.notNull;
        this.default = config.default;
        this.defaultFn = config.defaultFn;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
        this.dataType = config.dataType;
        this.columnType = config.columnType;
    }
    mapFromDriverValue(value) {
        return value;
    }
    mapToDriverValue(value) {
        return value;
    }
}
_a$W = entityKind;
Column[_a$W] = 'Column';

var _a$V, _b$L, _c$f;
class ConsoleLogWriter {
    write(message) {
        console.log(message);
    }
}
_a$V = entityKind;
ConsoleLogWriter[_a$V] = 'ConsoleLogWriter';
class DefaultLogger {
    constructor(config) {
        this.writer = config?.writer ?? new ConsoleLogWriter();
    }
    logQuery(query, params) {
        const stringifiedParams = params.map((p) => {
            try {
                return JSON.stringify(p);
            }
            catch {
                return String(p);
            }
        });
        const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(', ')}]` : '';
        this.writer.write(`Query: ${query}${paramsStr}`);
    }
}
_b$L = entityKind;
DefaultLogger[_b$L] = 'DefaultLogger';
class NoopLogger {
    logQuery() {
        // noop
    }
}
_c$f = entityKind;
NoopLogger[_c$f] = 'NoopLogger';

var _a$U;
const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');
class View {
    constructor({ name, schema, selectedFields, query }) {
        this[ViewBaseConfig] = {
            name,
            originalName: name,
            schema,
            selectedFields,
            query: query,
            isExisting: !query,
            isAlias: false,
        };
    }
    getSQL() {
        return new SQL([this]);
    }
}
_a$U = entityKind;
View[_a$U] = 'View';

var _a$T, _b$K, _c$e;
const SubqueryConfig = Symbol.for('drizzle:SubqueryConfig');
class Subquery {
    constructor(sql, selection, alias, isWith = false) {
        this[SubqueryConfig] = {
            sql,
            selection,
            alias,
            isWith,
        };
    }
    getSQL() {
        return new SQL([this]);
    }
}
_a$T = entityKind;
Subquery[_a$T] = 'Subquery';
class WithSubquery extends Subquery {
}
_b$K = entityKind;
WithSubquery[_b$K] = 'WithSubquery';
class SelectionProxyHandler {
    constructor(config) {
        this.config = { ...config };
    }
    get(subquery, prop) {
        if (prop === SubqueryConfig) {
            return {
                ...subquery[SubqueryConfig],
                selection: new Proxy(subquery[SubqueryConfig].selection, this),
            };
        }
        if (prop === ViewBaseConfig) {
            return {
                ...subquery[ViewBaseConfig],
                selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this),
            };
        }
        if (typeof prop === 'symbol') {
            return subquery[prop];
        }
        const columns = is(subquery, Subquery)
            ? subquery[SubqueryConfig].selection
            : is(subquery, View)
                ? subquery[ViewBaseConfig].selectedFields
                : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
            // Never return the underlying SQL expression for a field previously selected in a subquery
            if (this.config.sqlAliasedBehavior === 'sql' && !value.isSelectionField) {
                return value.sql;
            }
            const newValue = value.clone();
            newValue.isSelectionField = true;
            return newValue;
        }
        if (is(value, SQL)) {
            if (this.config.sqlBehavior === 'sql') {
                return value;
            }
            throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
        }
        if (is(value, Column)) {
            if (this.config.alias) {
                return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
            }
            return value;
        }
        if (typeof value !== 'object' || value === null) {
            return value;
        }
        return new Proxy(value, new SelectionProxyHandler(this.config));
    }
}
_c$e = entityKind;
SelectionProxyHandler[_c$e] = 'SelectionProxyHandler';

/** @internal */
function mapResultRow(columns, row, joinsNotNullableMap) {
    // Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise
    const nullifyMap = {};
    const result = columns.reduce((result, { path, field }, columnIndex) => {
        let decoder;
        if (is(field, Column)) {
            decoder = field;
        }
        else if (is(field, SQL)) {
            decoder = field.decoder;
        }
        else {
            decoder = field.sql.decoder;
        }
        let node = result;
        for (const [pathChunkIndex, pathChunk] of path.entries()) {
            if (pathChunkIndex < path.length - 1) {
                if (!(pathChunk in node)) {
                    node[pathChunk] = {};
                }
                node = node[pathChunk];
            }
            else {
                const rawValue = row[columnIndex];
                const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
                if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
                    const objectName = path[0];
                    if (!(objectName in nullifyMap)) {
                        nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
                    }
                    else if (typeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)) {
                        nullifyMap[objectName] = false;
                    }
                }
            }
        }
        return result;
    }, {});
    // Nullify all nested objects from nullifyMap that are nullable
    if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
        for (const [objectName, tableName] of Object.entries(nullifyMap)) {
            if (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {
                result[objectName] = null;
            }
        }
    }
    return result;
}
/** @internal */
function orderSelectedFields(fields, pathPrefix) {
    return Object.entries(fields).reduce((result, [name, field]) => {
        if (typeof name !== 'string') {
            return result;
        }
        const newPath = pathPrefix ? [...pathPrefix, name] : [name];
        if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
            result.push({ path: newPath, field });
        }
        else if (is(field, Table)) {
            result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
        }
        else {
            result.push(...orderSelectedFields(field, newPath));
        }
        return result;
    }, []);
}
/** @internal */
function mapUpdateSet(table, values) {
    const entries = Object.entries(values)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => {
        // eslint-disable-next-line unicorn/prefer-ternary
        if (is(value, SQL)) {
            return [key, value];
        }
        else {
            return [key, new Param(value, table[Table.Symbol.Columns][key])];
        }
    });
    if (entries.length === 0) {
        throw new Error('No values to set');
    }
    return Object.fromEntries(entries);
}
/** @internal */
function applyMixins(baseClass, extendedClasses) {
    for (const extendedClass of extendedClasses) {
        for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
            Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null));
        }
    }
}
function getTableColumns(table) {
    return table[Table.Symbol.Columns];
}
/** @internal */
function getTableLikeName(table) {
    return is(table, Subquery)
        ? table[SubqueryConfig].alias
        : is(table, View)
            ? table[ViewBaseConfig].name
            : is(table, SQL)
                ? undefined
                : table[Table.Symbol.IsAlias]
                    ? table[Table.Symbol.Name]
                    : table[Table.Symbol.BaseName];
}
function iife(fn, ...args) {
    return fn(...args);
}

var _a$S, _b$J, _c$d, _d$7;
/** @internal */
const TableName = Symbol.for('drizzle:Name');
/** @internal */
const Schema = Symbol.for('drizzle:Schema');
/** @internal */
const Columns = Symbol.for('drizzle:Columns');
/** @internal */
const OriginalName = Symbol.for('drizzle:OriginalName');
/** @internal */
const BaseName = Symbol.for('drizzle:BaseName');
/** @internal */
const IsAlias = Symbol.for('drizzle:IsAlias');
/** @internal */
const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');
const IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');
class Table {
    constructor(name, schema, baseName) {
        /** @internal */
        this[_b$J] = false;
        /** @internal */
        this[_c$d] = undefined;
        this[_d$7] = true;
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema;
        this[BaseName] = baseName;
    }
    getSQL() {
        return new SQL([this]);
    }
}
_a$S = entityKind, _b$J = IsAlias, _c$d = ExtraConfigBuilder, _d$7 = IsDrizzleTable;
Table[_a$S] = 'Table';
/** @internal */
Table.Symbol = {
    Name: TableName,
    Schema: Schema,
    OriginalName: OriginalName,
    Columns: Columns,
    BaseName: BaseName,
    IsAlias: IsAlias,
    ExtraConfigBuilder: ExtraConfigBuilder,
};
function isTable(table) {
    return typeof table === 'object' && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
    return table[TableName];
}

var _a$R, _b$I;
class QueryPromise {
    constructor() {
        this[_b$I] = 'QueryPromise';
    }
    catch(onRejected) {
        return this.then(undefined, onRejected);
    }
    finally(onFinally) {
        return this.then((value) => {
            onFinally?.();
            return value;
        }, (reason) => {
            onFinally?.();
            throw reason;
        });
    }
    then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
    }
}
_a$R = entityKind, _b$I = Symbol.toStringTag;
QueryPromise[_a$R] = 'QueryPromise';

/** @internal */
const tracer = {
    startActiveSpan(name, fn) {
        {
            return fn();
        }
    },
};

var _a$Q;
class PgDelete extends QueryPromise {
    constructor(table, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_a$Q = entityKind;
PgDelete[_a$Q] = 'PgDelete';

var _a$P, _b$H;
class PgInsertBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
            }
            return result;
        });
        return new PgInsert(this.table, mappedValues, this.session, this.dialect);
    }
}
_a$P = entityKind;
PgInsertBuilder[_a$P] = 'PgInsertBuilder';
class PgInsert extends QueryPromise {
    constructor(table, values, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
        this.config = { table, values };
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    onConflictDoNothing(config = {}) {
        if (config.target === undefined) {
            this.config.onConflict = sql `do nothing`;
        }
        else {
            let targetColumn = '';
            targetColumn = Array.isArray(config.target)
                ? config.target.map((it) => this.dialect.escapeName(it.name)).join(',')
                : this.dialect.escapeName(config.target.name);
            const whereSql = config.where ? sql ` where ${config.where}` : undefined;
            this.config.onConflict = sql `(${sql.raw(targetColumn)}) do nothing${whereSql}`;
        }
        return this;
    }
    onConflictDoUpdate(config) {
        const whereSql = config.where ? sql ` where ${config.where}` : undefined;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        let targetColumn = '';
        targetColumn = Array.isArray(config.target)
            ? config.target.map((it) => this.dialect.escapeName(it.name)).join(',')
            : this.dialect.escapeName(config.target.name);
        this.config.onConflict = sql `(${sql.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_b$H = entityKind;
PgInsert[_b$H] = 'PgInsert';

var _a$O, _b$G;
class DrizzleError extends Error {
    constructor(message) {
        super(message);
        this.name = 'DrizzleError';
    }
    static wrap(error, message) {
        return error instanceof Error // eslint-disable-line no-instanceof/no-instanceof
            ? new DrizzleError(message ? `${message}: ${error.message}` : error.message)
            : new DrizzleError(message ?? String(error));
    }
}
_a$O = entityKind;
DrizzleError[_a$O] = 'DrizzleError';
class TransactionRollbackError extends DrizzleError {
    constructor() {
        super('Rollback');
    }
}
_b$G = entityKind;
TransactionRollbackError[_b$G] = 'TransactionRollbackError';

var _a$N, _b$F, _c$c;
/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');
class PgTable extends Table {
    constructor() {
        super(...arguments);
        /**@internal */
        this[_b$F] = [];
        /** @internal */
        this[_c$c] = undefined;
    }
}
_a$N = entityKind, _b$F = InlineForeignKeys, _c$c = Table.Symbol.ExtraConfigBuilder;
PgTable[_a$N] = 'PgTable';
/** @internal */
PgTable.Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys,
});
/** @internal */
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new PgTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilderBase]) => {
        const colBuilder = colBuilderBase;
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const pgTable = (name, columns, extraConfig) => {
    return pgTableWithSchema(name, columns, extraConfig, undefined);
};
function pgTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return pgTableWithSchema(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

var _a$M, _b$E;
class CheckBuilder {
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    /** @internal */
    build(table) {
        return new Check(table, this);
    }
}
_a$M = entityKind;
CheckBuilder[_a$M] = 'PgCheckBuilder';
class Check {
    constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
    }
}
_b$E = entityKind;
Check[_b$E] = 'PgCheck';
function check(name, value) {
    return new CheckBuilder(name, value);
}

var _a$L, _b$D;
class ForeignKeyBuilder {
    constructor(config, actions) {
        /** @internal */
        this._onUpdate = 'no action';
        /** @internal */
        this._onDelete = 'no action';
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action === undefined ? 'no action' : action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action === undefined ? 'no action' : action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
_a$L = entityKind;
ForeignKeyBuilder[_a$L] = 'PgForeignKeyBuilder';
class ForeignKey {
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[PgTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[PgTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
_b$D = entityKind;
ForeignKey[_b$D] = 'PgForeignKey';
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config;
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

var _a$K, _b$C, _c$b;
class IndexBuilderOn {
    constructor(unique, name) {
        this.unique = unique;
        this.name = name;
    }
    on(...columns) {
        return new IndexBuilder(columns, this.unique, false, this.name);
    }
    onOnly(...columns) {
        return new IndexBuilder(columns, this.unique, true, this.name);
    }
}
_a$K = entityKind;
IndexBuilderOn[_a$K] = 'PgIndexBuilderOn';
class IndexBuilder {
    constructor(columns, unique, only, name) {
        this.config = {
            name,
            columns,
            unique,
            only,
        };
    }
    concurrently() {
        this.config.concurrently = true;
        return this;
    }
    using(method) {
        this.config.using = method;
        return this;
    }
    asc() {
        this.config.order = 'asc';
        return this;
    }
    desc() {
        this.config.order = 'desc';
        return this;
    }
    nullsFirst() {
        this.config.nulls = 'first';
        return this;
    }
    nullsLast() {
        this.config.nulls = 'last';
        return this;
    }
    where(condition) {
        this.config.where = condition;
        return this;
    }
    /** @internal */
    build(table) {
        return new Index(this.config, table);
    }
}
_b$C = entityKind;
IndexBuilder[_b$C] = 'PgIndexBuilder';
class Index {
    constructor(config, table) {
        this.config = { ...config, table };
    }
}
_c$b = entityKind;
Index[_c$b] = 'PgIndex';
function index(name) {
    return new IndexBuilderOn(false, name);
}
function uniqueIndex(name) {
    return new IndexBuilderOn(true, name);
}

var _a$J, _b$B;
function primaryKey(...columns) {
    return new PrimaryKeyBuilder(columns);
}
class PrimaryKeyBuilder {
    constructor(columns) {
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new PrimaryKey(table, this.columns);
    }
}
_a$J = entityKind;
PrimaryKeyBuilder[_a$J] = 'PgPrimaryKeyBuilder';
class PrimaryKey {
    constructor(table, columns) {
        this.table = table;
        this.columns = columns;
    }
    getName() {
        return `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;
    }
}
_b$B = entityKind;
PrimaryKey[_b$B] = 'PgPrimaryKey';

var _a$I, _b$A, _c$a;
function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
    return `${table[PgTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
class UniqueConstraintBuilder {
    constructor(columns, name) {
        this.name = name;
        /** @internal */
        this.nullsNotDistinctConfig = false;
        this.columns = columns;
    }
    nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
    }
}
_a$I = entityKind;
UniqueConstraintBuilder[_a$I] = 'PgUniqueConstraintBuilder';
class UniqueOnConstraintBuilder {
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
_b$A = entityKind;
UniqueOnConstraintBuilder[_b$A] = 'PgUniqueOnConstraintBuilder';
class UniqueConstraint {
    constructor(table, columns, nullsNotDistinct, name) {
        this.table = table;
        this.nullsNotDistinct = false;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
    }
    getName() {
        return this.name;
    }
}
_c$a = entityKind;
UniqueConstraint[_c$a] = 'PgUniqueConstraint';

function getTableConfig(table) {
    const columns = Object.values(table[Table.Symbol.Columns]);
    const indexes = [];
    const checks = [];
    const primaryKeys = [];
    const foreignKeys = Object.values(table[PgTable.Symbol.InlineForeignKeys]);
    const uniqueConstraints = [];
    const name = table[Table.Symbol.Name];
    const schema = table[Table.Symbol.Schema];
    const extraConfigBuilder = table[PgTable.Symbol.ExtraConfigBuilder];
    if (extraConfigBuilder !== undefined) {
        const extraConfig = extraConfigBuilder(table[Table.Symbol.Columns]);
        for (const builder of Object.values(extraConfig)) {
            if (is(builder, IndexBuilder)) {
                indexes.push(builder.build(table));
            }
            else if (is(builder, CheckBuilder)) {
                checks.push(builder.build(table));
            }
            else if (is(builder, UniqueConstraintBuilder)) {
                uniqueConstraints.push(builder.build(table));
            }
            else if (is(builder, PrimaryKeyBuilder)) {
                primaryKeys.push(builder.build(table));
            }
            else if (is(builder, ForeignKeyBuilder)) {
                foreignKeys.push(builder.build(table));
            }
        }
    }
    return {
        columns,
        indexes,
        foreignKeys,
        checks,
        primaryKeys,
        uniqueConstraints,
        name,
        schema,
    };
}
function getViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[PgViewConfig],
    };
}
function getMaterializedViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[PgMaterializedViewConfig],
    };
}
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
    for (let i = startFrom; i < arrayString.length; i++) {
        const char = arrayString[i];
        if (char === '\\') {
            i++;
            continue;
        }
        if (char === '"') {
            return [arrayString.slice(startFrom, i).replace(/\\/g, ''), i + 1];
        }
        if (inQuotes) {
            continue;
        }
        if (char === ',' || char === '}') {
            return [arrayString.slice(startFrom, i).replace(/\\/g, ''), i];
        }
    }
    return [arrayString.slice(startFrom).replace(/\\/g, ''), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
    const result = [];
    let i = startFrom;
    let lastCharIsComma = false;
    while (i < arrayString.length) {
        const char = arrayString[i];
        if (char === ',') {
            if (lastCharIsComma || i === startFrom) {
                result.push('');
            }
            lastCharIsComma = true;
            i++;
            continue;
        }
        lastCharIsComma = false;
        if (char === '\\') {
            i += 2;
            continue;
        }
        if (char === '"') {
            const [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);
            result.push(value);
            i = startFrom;
            continue;
        }
        if (char === '}') {
            return [result, i + 1];
        }
        if (char === '{') {
            const [value, startFrom] = parsePgNestedArray(arrayString, i + 1);
            result.push(value);
            i = startFrom;
            continue;
        }
        const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
        result.push(value);
        i = newStartFrom;
    }
    return [result, i];
}
function parsePgArray(arrayString) {
    const [result] = parsePgNestedArray(arrayString, 1);
    return result;
}
function makePgArray(array) {
    return `{${array.map((item) => {
        if (Array.isArray(item)) {
            return makePgArray(item);
        }
        if (typeof item === 'string' && item.includes(',')) {
            return `"${item.replace(/"/g, '\\"')}"`;
        }
        return `${item}`;
    }).join(',')}}`;
}

var _a$H;
// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.
class ColumnBuilder {
    constructor(name, dataType, columnType) {
        /**
         * Alias for {@link $defaultFn}.
         */
        this.$default = this.$defaultFn;
        this.config = {
            name,
            notNull: false,
            default: undefined,
            hasDefault: false,
            primaryKey: false,
            isUnique: false,
            uniqueName: undefined,
            uniqueType: undefined,
            dataType,
            columnType,
        };
    }
    /**
     * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
     *
     * @example
     * ```ts
     * const users = pgTable('users', {
     * 	id: integer('id').$type<UserId>().primaryKey(),
     * 	details: json('details').$type<UserDetails>().notNull(),
     * });
     * ```
     */
    $type() {
        return this;
    }
    /**
     * Adds a `not null` clause to the column definition.
     *
     * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
     */
    notNull() {
        this.config.notNull = true;
        return this;
    }
    /**
     * Adds a `default <value>` clause to the column definition.
     *
     * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
     *
     * If you need to set a dynamic default value, use {@link $defaultFn} instead.
     */
    default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
    }
    /**
     * Adds a dynamic default value to the column.
     * The function will be called when the row is inserted, and the returned value will be used as the column value.
     *
     * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
     */
    $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
    }
    /**
     * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
     *
     * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
     */
    primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
    }
}
_a$H = entityKind;
ColumnBuilder[_a$H] = 'ColumnBuilder';

var _a$G, _b$z;
class PgColumnBuilder extends ColumnBuilder {
    constructor() {
        super(...arguments);
        this.foreignKeyConfigs = [];
    }
    array(size) {
        return new PgArrayBuilder(this.config.name, this, size);
    }
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name, config) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        this.config.uniqueType = config?.nulls;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return iife((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            }, ref, actions);
        });
    }
}
_a$G = entityKind;
PgColumnBuilder[_a$G] = 'PgColumnBuilder';
// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.
class PgColumn extends Column {
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}
_b$z = entityKind;
PgColumn[_b$z] = 'PgColumn';

var _a$F, _b$y;
class PgArrayBuilder extends PgColumnBuilder {
    constructor(name, baseBuilder, size) {
        super(name, 'array', 'PgArray');
        this.config.baseBuilder = baseBuilder;
        this.config.size = size;
    }
    /** @internal */
    build(table) {
        const baseColumn = this.config.baseBuilder.build(table);
        return new PgArray(table, this.config, baseColumn);
    }
}
_a$F = entityKind;
PgArrayBuilder[_a$F] = 'PgArrayBuilder';
class PgArray extends PgColumn {
    constructor(table, config, baseColumn, range) {
        super(table, config);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config.size;
    }
    getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            // Thank you node-postgres for not parsing enum arrays
            value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
    }
    mapToDriverValue(value, isNestedArray = false) {
        const a = value.map((v) => v === null
            ? null
            : is(this.baseColumn, PgArray)
                ? this.baseColumn.mapToDriverValue(v, true)
                : this.baseColumn.mapToDriverValue(v));
        if (isNestedArray)
            return a;
        return makePgArray(a);
    }
}
_b$y = entityKind;
PgArray[_b$y] = 'PgArray';

var _a$E, _b$x, _c$9, _d$6;
class PgBigInt53Builder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgBigInt53');
    }
    /** @internal */
    build(table) {
        return new PgBigInt53(table, this.config);
    }
}
_a$E = entityKind;
PgBigInt53Builder[_a$E] = 'PgBigInt53Builder';
class PgBigInt53 extends PgColumn {
    getSQLType() {
        return 'bigint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
_b$x = entityKind;
PgBigInt53[_b$x] = 'PgBigInt53';
class PgBigInt64Builder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'bigint', 'PgBigInt64');
    }
    /** @internal */
    build(table) {
        return new PgBigInt64(table, this.config);
    }
}
_c$9 = entityKind;
PgBigInt64Builder[_c$9] = 'PgBigInt64Builder';
class PgBigInt64 extends PgColumn {
    getSQLType() {
        return 'bigint';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
_d$6 = entityKind;
PgBigInt64[_d$6] = 'PgBigInt64';
function bigint(name, config) {
    if (config.mode === 'number') {
        return new PgBigInt53Builder(name);
    }
    return new PgBigInt64Builder(name);
}

var _a$D, _b$w, _c$8, _d$5;
class PgBigSerial53Builder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgBigSerial53');
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgBigSerial53(table, this.config);
    }
}
_a$D = entityKind;
PgBigSerial53Builder[_a$D] = 'PgBigSerial53Builder';
class PgBigSerial53 extends PgColumn {
    getSQLType() {
        return 'bigserial';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
_b$w = entityKind;
PgBigSerial53[_b$w] = 'PgBigSerial53';
class PgBigSerial64Builder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'bigint', 'PgBigSerial64');
        this.config.hasDefault = true;
    }
    /** @internal */
    build(table) {
        return new PgBigSerial64(table, this.config);
    }
}
_c$8 = entityKind;
PgBigSerial64Builder[_c$8] = 'PgBigSerial64Builder';
class PgBigSerial64 extends PgColumn {
    getSQLType() {
        return 'bigserial';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
_d$5 = entityKind;
PgBigSerial64[_d$5] = 'PgBigSerial64';
function bigserial(name, { mode }) {
    if (mode === 'number') {
        return new PgBigSerial53Builder(name);
    }
    return new PgBigSerial64Builder(name);
}

var _a$C, _b$v;
class PgBooleanBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'boolean', 'PgBoolean');
    }
    /** @internal */
    build(table) {
        return new PgBoolean(table, this.config);
    }
}
_a$C = entityKind;
PgBooleanBuilder[_a$C] = 'PgBooleanBuilder';
class PgBoolean extends PgColumn {
    getSQLType() {
        return 'boolean';
    }
}
_b$v = entityKind;
PgBoolean[_b$v] = 'PgBoolean';
function boolean(name) {
    return new PgBooleanBuilder(name);
}

var _a$B, _b$u;
class PgCharBuilder extends PgColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'PgChar');
        this.config.length = config.length;
        this.config.enumValues = config.enum;
    }
    /** @internal */
    build(table) {
        return new PgChar(table, this.config);
    }
}
_a$B = entityKind;
PgCharBuilder[_a$B] = 'PgCharBuilder';
class PgChar extends PgColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return this.length === undefined ? `char` : `char(${this.length})`;
    }
}
_b$u = entityKind;
PgChar[_b$u] = 'PgChar';
function char(name, config = {}) {
    return new PgCharBuilder(name, config);
}

var _a$A, _b$t;
class PgCidrBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'string', 'PgCidr');
    }
    /** @internal */
    build(table) {
        return new PgCidr(table, this.config);
    }
}
_a$A = entityKind;
PgCidrBuilder[_a$A] = 'PgCidrBuilder';
class PgCidr extends PgColumn {
    getSQLType() {
        return 'cidr';
    }
}
_b$t = entityKind;
PgCidr[_b$t] = 'PgCidr';
function cidr(name) {
    return new PgCidrBuilder(name);
}

var _a$z, _b$s;
class PgCustomColumnBuilder extends PgColumnBuilder {
    constructor(name, fieldConfig, customTypeParams) {
        super(name, 'custom', 'PgCustomColumn');
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new PgCustomColumn(table, this.config);
    }
}
_a$z = entityKind;
PgCustomColumnBuilder[_a$z] = 'PgCustomColumnBuilder';
class PgCustomColumn extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
_b$s = entityKind;
PgCustomColumn[_b$s] = 'PgCustomColumn';
/**
 * Custom pg database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new PgCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

var _a$y;
class PgDateColumnBaseBuilder extends PgColumnBuilder {
    defaultNow() {
        return this.default(sql `now()`);
    }
}
_a$y = entityKind;
PgDateColumnBaseBuilder[_a$y] = 'PgDateColumnBaseBuilder';

var _a$x, _b$r, _c$7, _d$4;
class PgDateBuilder extends PgDateColumnBaseBuilder {
    constructor(name) {
        super(name, 'date', 'PgDate');
    }
    /** @internal */
    build(table) {
        return new PgDate(table, this.config);
    }
}
_a$x = entityKind;
PgDateBuilder[_a$x] = 'PgDateBuilder';
class PgDate extends PgColumn {
    getSQLType() {
        return 'date';
    }
    mapFromDriverValue(value) {
        return new Date(value);
    }
    mapToDriverValue(value) {
        return value.toISOString();
    }
}
_b$r = entityKind;
PgDate[_b$r] = 'PgDate';
class PgDateStringBuilder extends PgDateColumnBaseBuilder {
    constructor(name) {
        super(name, 'string', 'PgDateString');
    }
    /** @internal */
    build(table) {
        return new PgDateString(table, this.config);
    }
}
_c$7 = entityKind;
PgDateStringBuilder[_c$7] = 'PgDateStringBuilder';
class PgDateString extends PgColumn {
    getSQLType() {
        return 'date';
    }
}
_d$4 = entityKind;
PgDateString[_d$4] = 'PgDateString';
function date(name, config) {
    if (config?.mode === 'date') {
        return new PgDateBuilder(name);
    }
    return new PgDateStringBuilder(name);
}

var _a$w, _b$q;
class PgDoublePrecisionBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgDoublePrecision');
    }
    /** @internal */
    build(table) {
        return new PgDoublePrecision(table, this.config);
    }
}
_a$w = entityKind;
PgDoublePrecisionBuilder[_a$w] = 'PgDoublePrecisionBuilder';
class PgDoublePrecision extends PgColumn {
    getSQLType() {
        return 'double precision';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number.parseFloat(value);
        }
        return value;
    }
}
_b$q = entityKind;
PgDoublePrecision[_b$q] = 'PgDoublePrecision';
function doublePrecision(name) {
    return new PgDoublePrecisionBuilder(name);
}

var _a$v, _b$p;
const isPgEnumSym = Symbol.for('drizzle:isPgEnum');
function isPgEnum(obj) {
    return !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumnBuilder extends PgColumnBuilder {
    constructor(name, enumInstance) {
        super(name, 'string', 'PgEnumColumn');
        this.config.enum = enumInstance;
    }
    /** @internal */
    build(table) {
        return new PgEnumColumn(table, this.config);
    }
}
_a$v = entityKind;
PgEnumColumnBuilder[_a$v] = 'PgEnumColumnBuilder';
class PgEnumColumn extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.enum = this.config.enum;
        this.enumValues = this.config.enum.enumValues;
        this.enum = config.enum;
    }
    getSQLType() {
        return this.enum.enumName;
    }
}
_b$p = entityKind;
PgEnumColumn[_b$p] = 'PgEnumColumn';
// Gratitude to zod for the enum function types
function pgEnum(enumName, values) {
    const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name, enumInstance), {
        enumName,
        enumValues: values,
        [isPgEnumSym]: true,
    });
    return enumInstance;
}

var _a$u, _b$o;
class PgInetBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'string', 'PgInet');
    }
    /** @internal */
    build(table) {
        return new PgInet(table, this.config);
    }
}
_a$u = entityKind;
PgInetBuilder[_a$u] = 'PgInetBuilder';
class PgInet extends PgColumn {
    getSQLType() {
        return 'inet';
    }
}
_b$o = entityKind;
PgInet[_b$o] = 'PgInet';
function inet(name) {
    return new PgInetBuilder(name);
}

var _a$t, _b$n;
class PgIntegerBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgInteger');
    }
    /** @internal */
    build(table) {
        return new PgInteger(table, this.config);
    }
}
_a$t = entityKind;
PgIntegerBuilder[_a$t] = 'PgIntegerBuilder';
class PgInteger extends PgColumn {
    getSQLType() {
        return 'integer';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number.parseInt(value);
        }
        return value;
    }
}
_b$n = entityKind;
PgInteger[_b$n] = 'PgInteger';
function integer(name) {
    return new PgIntegerBuilder(name);
}

var _a$s, _b$m;
class PgIntervalBuilder extends PgColumnBuilder {
    constructor(name, intervalConfig) {
        super(name, 'string', 'PgInterval');
        this.config.intervalConfig = intervalConfig;
    }
    /** @internal */
    build(table) {
        return new PgInterval(table, this.config);
    }
}
_a$s = entityKind;
PgIntervalBuilder[_a$s] = 'PgIntervalBuilder';
class PgInterval extends PgColumn {
    constructor() {
        super(...arguments);
        this.fields = this.config.intervalConfig.fields;
        this.precision = this.config.intervalConfig.precision;
    }
    getSQLType() {
        const fields = this.fields ? ` ${this.fields}` : '';
        const precision = this.precision ? `(${this.precision})` : '';
        return `interval${fields}${precision}`;
    }
}
_b$m = entityKind;
PgInterval[_b$m] = 'PgInterval';
function interval(name, config = {}) {
    return new PgIntervalBuilder(name, config);
}

var _a$r, _b$l;
class PgJsonBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'json', 'PgJson');
    }
    /** @internal */
    build(table) {
        return new PgJson(table, this.config);
    }
}
_a$r = entityKind;
PgJsonBuilder[_a$r] = 'PgJsonBuilder';
class PgJson extends PgColumn {
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'json';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return value;
    }
}
_b$l = entityKind;
PgJson[_b$l] = 'PgJson';
function json(name) {
    return new PgJsonBuilder(name);
}

var _a$q, _b$k;
class PgJsonbBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'json', 'PgJsonb');
    }
    /** @internal */
    build(table) {
        return new PgJsonb(table, this.config);
    }
}
_a$q = entityKind;
PgJsonbBuilder[_a$q] = 'PgJsonbBuilder';
class PgJsonb extends PgColumn {
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'jsonb';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return value;
    }
}
_b$k = entityKind;
PgJsonb[_b$k] = 'PgJsonb';
function jsonb(name) {
    return new PgJsonbBuilder(name);
}

var _a$p, _b$j;
class PgMacaddrBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'string', 'PgMacaddr');
    }
    /** @internal */
    build(table) {
        return new PgMacaddr(table, this.config);
    }
}
_a$p = entityKind;
PgMacaddrBuilder[_a$p] = 'PgMacaddrBuilder';
class PgMacaddr extends PgColumn {
    getSQLType() {
        return 'macaddr';
    }
}
_b$j = entityKind;
PgMacaddr[_b$j] = 'PgMacaddr';
function macaddr(name) {
    return new PgMacaddrBuilder(name);
}

var _a$o, _b$i;
class PgMacaddr8Builder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'string', 'PgMacaddr8');
    }
    /** @internal */
    build(table) {
        return new PgMacaddr8(table, this.config);
    }
}
_a$o = entityKind;
PgMacaddr8Builder[_a$o] = 'PgMacaddr8Builder';
class PgMacaddr8 extends PgColumn {
    getSQLType() {
        return 'macaddr8';
    }
}
_b$i = entityKind;
PgMacaddr8[_b$i] = 'PgMacaddr8';
function macaddr8(name) {
    return new PgMacaddr8Builder(name);
}

var _a$n, _b$h;
class PgNumericBuilder extends PgColumnBuilder {
    constructor(name, precision, scale) {
        super(name, 'string', 'PgNumeric');
        this.config.precision = precision;
        this.config.scale = scale;
    }
    /** @internal */
    build(table) {
        return new PgNumeric(table, this.config);
    }
}
_a$n = entityKind;
PgNumericBuilder[_a$n] = 'PgNumericBuilder';
class PgNumeric extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.precision = config.precision;
        this.scale = config.scale;
    }
    getSQLType() {
        if (this.precision !== undefined && this.scale !== undefined) {
            return `numeric(${this.precision}, ${this.scale})`;
        }
        else if (this.precision === undefined) {
            return 'numeric';
        }
        else {
            return `numeric(${this.precision})`;
        }
    }
}
_b$h = entityKind;
PgNumeric[_b$h] = 'PgNumeric';
function numeric(name, config) {
    return new PgNumericBuilder(name, config?.precision, config?.scale);
}
const decimal = numeric;

var _a$m, _b$g;
class PgRealBuilder extends PgColumnBuilder {
    constructor(name, length) {
        super(name, 'number', 'PgReal');
        this.config.length = length;
    }
    /** @internal */
    build(table) {
        return new PgReal(table, this.config);
    }
}
_a$m = entityKind;
PgRealBuilder[_a$m] = 'PgRealBuilder';
class PgReal extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.mapFromDriverValue = (value) => {
            if (typeof value === 'string') {
                return Number.parseFloat(value);
            }
            return value;
        };
    }
    getSQLType() {
        return 'real';
    }
}
_b$g = entityKind;
PgReal[_b$g] = 'PgReal';
function real(name) {
    return new PgRealBuilder(name);
}

var _a$l, _b$f;
class PgSerialBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgSerial');
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgSerial(table, this.config);
    }
}
_a$l = entityKind;
PgSerialBuilder[_a$l] = 'PgSerialBuilder';
class PgSerial extends PgColumn {
    getSQLType() {
        return 'serial';
    }
}
_b$f = entityKind;
PgSerial[_b$f] = 'PgSerial';
function serial(name) {
    return new PgSerialBuilder(name);
}

var _a$k, _b$e;
class PgSmallIntBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgSmallInt');
    }
    /** @internal */
    build(table) {
        return new PgSmallInt(table, this.config);
    }
}
_a$k = entityKind;
PgSmallIntBuilder[_a$k] = 'PgSmallIntBuilder';
class PgSmallInt extends PgColumn {
    constructor() {
        super(...arguments);
        this.mapFromDriverValue = (value) => {
            if (typeof value === 'string') {
                return Number(value);
            }
            return value;
        };
    }
    getSQLType() {
        return 'smallint';
    }
}
_b$e = entityKind;
PgSmallInt[_b$e] = 'PgSmallInt';
function smallint(name) {
    return new PgSmallIntBuilder(name);
}

var _a$j, _b$d;
class PgSmallSerialBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'number', 'PgSmallSerial');
        this.config.hasDefault = true;
        this.config.notNull = true;
    }
    /** @internal */
    build(table) {
        return new PgSmallSerial(table, this.config);
    }
}
_a$j = entityKind;
PgSmallSerialBuilder[_a$j] = 'PgSmallSerialBuilder';
class PgSmallSerial extends PgColumn {
    getSQLType() {
        return 'smallserial';
    }
}
_b$d = entityKind;
PgSmallSerial[_b$d] = 'PgSmallSerial';
function smallserial(name) {
    return new PgSmallSerialBuilder(name);
}

var _a$i, _b$c;
class PgTextBuilder extends PgColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'PgText');
        this.config.enumValues = config.enum;
    }
    /** @internal */
    build(table) {
        return new PgText(table, this.config);
    }
}
_a$i = entityKind;
PgTextBuilder[_a$i] = 'PgTextBuilder';
class PgText extends PgColumn {
    constructor() {
        super(...arguments);
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return 'text';
    }
}
_b$c = entityKind;
PgText[_b$c] = 'PgText';
function text(name, config = {}) {
    return new PgTextBuilder(name, config);
}

var _a$h, _b$b;
class PgTimeBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
        super(name, 'string', 'PgTime');
        this.withTimezone = withTimezone;
        this.precision = precision;
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTime(table, this.config);
    }
}
_a$h = entityKind;
PgTimeBuilder[_a$h] = 'PgTimeBuilder';
class PgTime extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : `(${this.precision})`;
        return `time${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
_b$b = entityKind;
PgTime[_b$b] = 'PgTime';
function time(name, config = {}) {
    return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

var _a$g, _b$a, _c$6, _d$3;
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
        super(name, 'date', 'PgTimestamp');
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTimestamp(table, this.config);
    }
}
_a$g = entityKind;
PgTimestampBuilder[_a$g] = 'PgTimestampBuilder';
class PgTimestamp extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.mapFromDriverValue = (value) => {
            return new Date(this.withTimezone ? value : value + '+0000');
        };
        this.mapToDriverValue = (value) => {
            return this.withTimezone ? value.toUTCString() : value.toISOString();
        };
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : ` (${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
_b$a = entityKind;
PgTimestamp[_b$a] = 'PgTimestamp';
class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
    constructor(name, withTimezone, precision) {
        super(name, 'string', 'PgTimestampString');
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTimestampString(table, this.config);
    }
}
_c$6 = entityKind;
PgTimestampStringBuilder[_c$6] = 'PgTimestampStringBuilder';
class PgTimestampString extends PgColumn {
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : `(${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
_d$3 = entityKind;
PgTimestampString[_d$3] = 'PgTimestampString';
function timestamp(name, config = {}) {
    if (config.mode === 'string') {
        return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
    }
    return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
}

var _a$f, _b$9;
class PgUUIDBuilder extends PgColumnBuilder {
    constructor(name) {
        super(name, 'string', 'PgUUID');
    }
    /**
     * Adds `default gen_random_uuid()` to the column definition.
     */
    defaultRandom() {
        return this.default(sql `gen_random_uuid()`);
    }
    /** @internal */
    build(table) {
        return new PgUUID(table, this.config);
    }
}
_a$f = entityKind;
PgUUIDBuilder[_a$f] = 'PgUUIDBuilder';
class PgUUID extends PgColumn {
    getSQLType() {
        return 'uuid';
    }
}
_b$9 = entityKind;
PgUUID[_b$9] = 'PgUUID';
function uuid(name) {
    return new PgUUIDBuilder(name);
}

var _a$e, _b$8;
class PgVarcharBuilder extends PgColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'PgVarchar');
        this.config.length = config.length;
        this.config.enumValues = config.enum;
    }
    /** @internal */
    build(table) {
        return new PgVarchar(table, this.config);
    }
}
_a$e = entityKind;
PgVarcharBuilder[_a$e] = 'PgVarcharBuilder';
class PgVarchar extends PgColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return this.length === undefined ? `varchar` : `varchar(${this.length})`;
    }
}
_b$8 = entityKind;
PgVarchar[_b$8] = 'PgVarchar';
function varchar(name, config = {}) {
    return new PgVarcharBuilder(name, config);
}

var _a$d;
class PgDialect {
    async migrate(migrations, session) {
        const migrationTableCreate = sql `
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
        await session.execute(sql `CREATE SCHEMA IF NOT EXISTS "drizzle"`);
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(sql `select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
            for await (const migration of migrations) {
                if (!lastDbMigration
                    || Number(lastDbMigration.created_at) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.execute(sql.raw(stmt));
                    }
                    await tx.execute(sql `insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(num) {
        return `$${num + 1}`;
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql.join(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[Table.Symbol.Columns][colName];
            const res = sql `${sql.identifier(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (is(field, SQL.Aliased) && field.isSelectionField) {
                chunk.push(sql.identifier(field.fieldAlias));
            }
            else if (is(field, SQL.Aliased) || is(field, SQL)) {
                const query = is(field, SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new SQL(query.queryChunks.map((c) => {
                        if (is(c, PgColumn)) {
                            return sql.identifier(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (is(field, SQL.Aliased)) {
                    chunk.push(sql ` as ${sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (is(field, Column)) {
                if (isSingleTable) {
                    chunk.push(sql.identifier(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(sql `, `);
            }
            return chunk;
        });
        return sql.join(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClauses, distinct, }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (is(f.field, Column)
                && getTableName(f.field.table)
                    !== (is(table, Subquery)
                        ? table[SubqueryConfig].alias
                        : is(table, PgViewBase)
                            ? table[ViewBaseConfig].name
                            : is(table, SQL)
                                ? undefined
                                : getTableName(table))
                && !((table) => joins?.some(({ alias }) => alias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(sql `${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(sql `, `);
                }
            }
            withSqlChunks.push(sql ` `);
            withSql = sql.join(withSqlChunks);
        }
        let distinctSql;
        if (distinct) {
            distinctSql = distinct === true ? sql ` distinct` : sql ` distinct on (${sql.join(distinct.on, ', ')})`;
        }
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
                let fullName = sql `${sql.identifier(table[Table.Symbol.OriginalName])}`;
                if (table[Table.Symbol.Schema]) {
                    fullName = sql `${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
                }
                return sql `${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        if (joins) {
            for (const [index, joinMeta] of joins.entries()) {
                if (index === 0) {
                    joinsArray.push(sql ` `);
                }
                const table = joinMeta.table;
                const lateralSql = joinMeta.lateral ? sql ` lateral` : undefined;
                if (is(table, PgTable)) {
                    const tableName = table[PgTable.Symbol.Name];
                    const tableSchema = table[PgTable.Symbol.Schema];
                    const origTableName = table[PgTable.Symbol.OriginalName];
                    const alias = tableName === origTableName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql `${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else if (is(table, View)) {
                    const viewName = table[ViewBaseConfig].name;
                    const viewSchema = table[ViewBaseConfig].schema;
                    const origViewName = table[ViewBaseConfig].originalName;
                    const alias = viewName === origViewName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql `${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else {
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`);
                }
                if (index < joins.length - 1) {
                    joinsArray.push(sql ` `);
                }
            }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql ` where ${where}` : undefined;
        const havingSql = having ? sql ` having ${having}` : undefined;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
            orderBySql = sql ` order by ${sql.join(orderBy, sql `, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
            groupBySql = sql ` group by ${sql.join(groupBy, sql `, `)}`;
        }
        const limitSql = limit ? sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? sql ` offset ${offset}` : undefined;
        const lockingClausesSql = sql.empty();
        if (lockingClauses) {
            for (const { strength, config } of lockingClauses) {
                const clauseSql = sql ` for ${sql.raw(strength)}`;
                if (config.of) {
                    clauseSql.append(sql ` of ${config.of}`);
                }
                if (config.noWait) {
                    clauseSql.append(sql ` no wait`);
                }
                else if (config.skipLocked) {
                    clauseSql.append(sql ` skip locked`);
                }
                lockingClausesSql.append(clauseSql);
            }
        }
        return sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {
                    // eslint-disable-next-line unicorn/no-negated-condition
                    if (col.defaultFn !== undefined) {
                        const defaultFnResult = col.defaultFn();
                        const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                        valueList.push(defaultValue);
                    }
                    else {
                        valueList.push(sql `default`);
                    }
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(sql `, `);
            }
        }
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? sql ` on conflict ${onConflict}` : undefined;
        return sql `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
        const concurrentlySql = concurrently ? sql ` concurrently` : undefined;
        const withNoDataSql = withNoData ? sql ` with no data` : undefined;
        return sql `refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
    }
    prepareTyping(encoder) {
        if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
            return 'json';
        }
        else if (is(encoder, PgNumeric)) {
            return 'decimal';
        }
        else if (is(encoder, PgTime)) {
            return 'time';
        }
        else if (is(encoder, PgTimestamp)) {
            return 'timestamp';
        }
        else if (is(encoder, PgDate)) {
            return 'date';
        }
        else if (is(encoder, PgUUID)) {
            return 'uuid';
        }
        else {
            return 'none';
        }
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
            prepareTyping: this.prepareTyping,
        });
    }
    // buildRelationalQueryWithPK({
    // 	fullSchema,
    // 	schema,
    // 	tableNamesMap,
    // 	table,
    // 	tableConfig,
    // 	queryConfig: config,
    // 	tableAlias,
    // 	isRoot = false,
    // 	joinOn,
    // }: {
    // 	fullSchema: Record<string, unknown>;
    // 	schema: TablesRelationalConfig;
    // 	tableNamesMap: Record<string, string>;
    // 	table: PgTable;
    // 	tableConfig: TableRelationalConfig;
    // 	queryConfig: true | DBQueryConfig<'many', true>;
    // 	tableAlias: string;
    // 	isRoot?: boolean;
    // 	joinOn?: SQL;
    // }): BuildRelationalQueryResult<PgTable, PgColumn> {
    // 	// For { "<relation>": true }, return a table with selection of all columns
    // 	if (config === true) {
    // 		const selectionEntries = Object.entries(tableConfig.columns);
    // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
    // 			[key, value],
    // 		) => ({
    // 			dbKey: value.name,
    // 			tsKey: key,
    // 			field: value as PgColumn,
    // 			relationTableTsKey: undefined,
    // 			isJson: false,
    // 			selection: [],
    // 		}));
    // 		return {
    // 			tableTsKey: tableConfig.tsName,
    // 			sql: table,
    // 			selection,
    // 		};
    // 	}
    // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
    // 	// let selectionForBuild = selection;
    // 	const aliasedColumns = Object.fromEntries(
    // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
    // 	);
    // 	const aliasedRelations = Object.fromEntries(
    // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
    // 	);
    // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
    // 	let where, hasUserDefinedWhere;
    // 	if (config.where) {
    // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
    // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
    // 		hasUserDefinedWhere = !!where;
    // 	}
    // 	where = and(joinOn, where);
    // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
    // 	let joins: Join[] = [];
    // 	let selectedColumns: string[] = [];
    // 	// Figure out which columns to select
    // 	if (config.columns) {
    // 		let isIncludeMode = false;
    // 		for (const [field, value] of Object.entries(config.columns)) {
    // 			if (value === undefined) {
    // 				continue;
    // 			}
    // 			if (field in tableConfig.columns) {
    // 				if (!isIncludeMode && value === true) {
    // 					isIncludeMode = true;
    // 				}
    // 				selectedColumns.push(field);
    // 			}
    // 		}
    // 		if (selectedColumns.length > 0) {
    // 			selectedColumns = isIncludeMode
    // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
    // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
    // 		}
    // 	} else {
    // 		// Select all columns if selection is not specified
    // 		selectedColumns = Object.keys(tableConfig.columns);
    // 	}
    // 	// for (const field of selectedColumns) {
    // 	// 	const column = tableConfig.columns[field]! as PgColumn;
    // 	// 	fieldsSelection.push({ tsKey: field, value: column });
    // 	// }
    // 	let initiallySelectedRelations: {
    // 		tsKey: string;
    // 		queryConfig: true | DBQueryConfig<'many', false>;
    // 		relation: Relation;
    // 	}[] = [];
    // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
    // 	// Figure out which relations to select
    // 	if (config.with) {
    // 		initiallySelectedRelations = Object.entries(config.with)
    // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
    // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
    // 	}
    // 	const manyRelations = initiallySelectedRelations.filter((r) =>
    // 		is(r.relation, Many)
    // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
    // 	);
    // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
    // 	const isInnermostQuery = manyRelations.length < 2;
    // 	const selectedExtras: {
    // 		tsKey: string;
    // 		value: SQL.Aliased;
    // 	}[] = [];
    // 	// Figure out which extras to select
    // 	if (isInnermostQuery && config.extras) {
    // 		const extras = typeof config.extras === 'function'
    // 			? config.extras(aliasedFields, { sql })
    // 			: config.extras;
    // 		for (const [tsKey, value] of Object.entries(extras)) {
    // 			selectedExtras.push({
    // 				tsKey,
    // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
    // 			});
    // 		}
    // 	}
    // 	// Transform `fieldsSelection` into `selection`
    // 	// `fieldsSelection` shouldn't be used after this point
    // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
    // 	// 	selection.push({
    // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
    // 	// 		tsKey,
    // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
    // 	// 		relationTableTsKey: undefined,
    // 	// 		isJson: false,
    // 	// 		isExtra,
    // 	// 		selection: [],
    // 	// 	});
    // 	// }
    // 	let orderByOrig = typeof config.orderBy === 'function'
    // 		? config.orderBy(aliasedFields, orderByOperators)
    // 		: config.orderBy ?? [];
    // 	if (!Array.isArray(orderByOrig)) {
    // 		orderByOrig = [orderByOrig];
    // 	}
    // 	const orderBy = orderByOrig.map((orderByValue) => {
    // 		if (is(orderByValue, Column)) {
    // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
    // 		}
    // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
    // 	});
    // 	const limit = isInnermostQuery ? config.limit : undefined;
    // 	const offset = isInnermostQuery ? config.offset : undefined;
    // 	// For non-root queries without additional config except columns, return a table with selection
    // 	if (
    // 		!isRoot
    // 		&& initiallySelectedRelations.length === 0
    // 		&& selectedExtras.length === 0
    // 		&& !where
    // 		&& orderBy.length === 0
    // 		&& limit === undefined
    // 		&& offset === undefined
    // 	) {
    // 		return {
    // 			tableTsKey: tableConfig.tsName,
    // 			sql: table,
    // 			selection: selectedColumns.map((key) => ({
    // 				dbKey: tableConfig.columns[key]!.name,
    // 				tsKey: key,
    // 				field: tableConfig.columns[key] as PgColumn,
    // 				relationTableTsKey: undefined,
    // 				isJson: false,
    // 				selection: [],
    // 			})),
    // 		};
    // 	}
    // 	const selectedRelationsWithoutPK:
    // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
    // 	for (
    // 		const {
    // 			tsKey: selectedRelationTsKey,
    // 			queryConfig: selectedRelationConfigValue,
    // 			relation,
    // 		} of initiallySelectedRelations
    // 	) {
    // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
    // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
    // 		const relationTableTsName = tableNamesMap[relationTableName]!;
    // 		const relationTable = schema[relationTableTsName]!;
    // 		if (relationTable.primaryKey.length > 0) {
    // 			continue;
    // 		}
    // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
    // 		const joinOn = and(
    // 			...normalizedRelation.fields.map((field, i) =>
    // 				eq(
    // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
    // 					aliasedTableColumn(field, tableAlias),
    // 				)
    // 			),
    // 		);
    // 		const builtRelation = this.buildRelationalQueryWithoutPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table: fullSchema[relationTableTsName] as PgTable,
    // 			tableConfig: schema[relationTableTsName]!,
    // 			queryConfig: selectedRelationConfigValue,
    // 			tableAlias: relationTableAlias,
    // 			joinOn,
    // 			nestedQueryRelation: relation,
    // 		});
    // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
    // 		joins.push({
    // 			on: sql`true`,
    // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
    // 			alias: relationTableAlias,
    // 			joinType: 'left',
    // 			lateral: true,
    // 		});
    // 		selectedRelations.push({
    // 			dbKey: selectedRelationTsKey,
    // 			tsKey: selectedRelationTsKey,
    // 			field,
    // 			relationTableTsKey: relationTableTsName,
    // 			isJson: true,
    // 			selection: builtRelation.selection,
    // 		});
    // 	}
    // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
    // 		is(r.relation, One)
    // 	);
    // 	// Process all One relations with PKs, because they can all be joined on the same level
    // 	for (
    // 		const {
    // 			tsKey: selectedRelationTsKey,
    // 			queryConfig: selectedRelationConfigValue,
    // 			relation,
    // 		} of oneRelations
    // 	) {
    // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
    // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
    // 		const relationTableTsName = tableNamesMap[relationTableName]!;
    // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
    // 		const relationTable = schema[relationTableTsName]!;
    // 		if (relationTable.primaryKey.length === 0) {
    // 			continue;
    // 		}
    // 		const joinOn = and(
    // 			...normalizedRelation.fields.map((field, i) =>
    // 				eq(
    // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
    // 					aliasedTableColumn(field, tableAlias),
    // 				)
    // 			),
    // 		);
    // 		const builtRelation = this.buildRelationalQueryWithPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table: fullSchema[relationTableTsName] as PgTable,
    // 			tableConfig: schema[relationTableTsName]!,
    // 			queryConfig: selectedRelationConfigValue,
    // 			tableAlias: relationTableAlias,
    // 			joinOn,
    // 		});
    // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
    // 			sql.join(
    // 				builtRelation.selection.map(({ field }) =>
    // 					is(field, SQL.Aliased)
    // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
    // 						: is(field, Column)
    // 						? aliasedTableColumn(field, relationTableAlias)
    // 						: field
    // 				),
    // 				sql`, `,
    // 			)
    // 		}) end`.as(selectedRelationTsKey);
    // 		const isLateralJoin = is(builtRelation.sql, SQL);
    // 		joins.push({
    // 			on: isLateralJoin ? sql`true` : joinOn,
    // 			table: is(builtRelation.sql, SQL)
    // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
    // 				: aliasedTable(builtRelation.sql, relationTableAlias),
    // 			alias: relationTableAlias,
    // 			joinType: 'left',
    // 			lateral: is(builtRelation.sql, SQL),
    // 		});
    // 		selectedRelations.push({
    // 			dbKey: selectedRelationTsKey,
    // 			tsKey: selectedRelationTsKey,
    // 			field,
    // 			relationTableTsKey: relationTableTsName,
    // 			isJson: true,
    // 			selection: builtRelation.selection,
    // 		});
    // 	}
    // 	let distinct: PgSelectConfig['distinct'];
    // 	let tableFrom: PgTable | Subquery = table;
    // 	// Process first Many relation - each one requires a nested subquery
    // 	const manyRelation = manyRelations[0];
    // 	if (manyRelation) {
    // 		const {
    // 			tsKey: selectedRelationTsKey,
    // 			queryConfig: selectedRelationQueryConfig,
    // 			relation,
    // 		} = manyRelation;
    // 		distinct = {
    // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
    // 		};
    // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
    // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
    // 		const relationTableTsName = tableNamesMap[relationTableName]!;
    // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
    // 		const joinOn = and(
    // 			...normalizedRelation.fields.map((field, i) =>
    // 				eq(
    // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
    // 					aliasedTableColumn(field, tableAlias),
    // 				)
    // 			),
    // 		);
    // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table: fullSchema[relationTableTsName] as PgTable,
    // 			tableConfig: schema[relationTableTsName]!,
    // 			queryConfig: selectedRelationQueryConfig,
    // 			tableAlias: relationTableAlias,
    // 			joinOn,
    // 		});
    // 		const builtRelationSelectionField = sql`case when ${
    // 			sql.identifier(relationTableAlias)
    // 		} is null then '[]' else json_agg(json_build_array(${
    // 			sql.join(
    // 				builtRelationJoin.selection.map(({ field }) =>
    // 					is(field, SQL.Aliased)
    // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
    // 						: is(field, Column)
    // 						? aliasedTableColumn(field, relationTableAlias)
    // 						: field
    // 				),
    // 				sql`, `,
    // 			)
    // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
    // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
    // 		joins.push({
    // 			on: isLateralJoin ? sql`true` : joinOn,
    // 			table: isLateralJoin
    // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
    // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
    // 			alias: relationTableAlias,
    // 			joinType: 'left',
    // 			lateral: isLateralJoin,
    // 		});
    // 		// Build the "from" subquery with the remaining Many relations
    // 		const builtTableFrom = this.buildRelationalQueryWithPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table,
    // 			tableConfig,
    // 			queryConfig: {
    // 				...config,
    // 				where: undefined,
    // 				orderBy: undefined,
    // 				limit: undefined,
    // 				offset: undefined,
    // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
    // 					(result, { tsKey, queryConfig: configValue }) => {
    // 						result[tsKey] = configValue;
    // 						return result;
    // 					},
    // 					{},
    // 				),
    // 			},
    // 			tableAlias,
    // 		});
    // 		selectedRelations.push({
    // 			dbKey: selectedRelationTsKey,
    // 			tsKey: selectedRelationTsKey,
    // 			field: builtRelationSelectionField,
    // 			relationTableTsKey: relationTableTsName,
    // 			isJson: true,
    // 			selection: builtRelationJoin.selection,
    // 		});
    // 		// selection = builtTableFrom.selection.map((item) =>
    // 		// 	is(item.field, SQL.Aliased)
    // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
    // 		// 		: item
    // 		// );
    // 		// selectionForBuild = [{
    // 		// 	dbKey: '*',
    // 		// 	tsKey: '*',
    // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
    // 		// 	selection: [],
    // 		// 	isJson: false,
    // 		// 	relationTableTsKey: undefined,
    // 		// }];
    // 		// const newSelectionItem: (typeof selection)[number] = {
    // 		// 	dbKey: selectedRelationTsKey,
    // 		// 	tsKey: selectedRelationTsKey,
    // 		// 	field,
    // 		// 	relationTableTsKey: relationTableTsName,
    // 		// 	isJson: true,
    // 		// 	selection: builtRelationJoin.selection,
    // 		// };
    // 		// selection.push(newSelectionItem);
    // 		// selectionForBuild.push(newSelectionItem);
    // 		tableFrom = is(builtTableFrom.sql, PgTable)
    // 			? builtTableFrom.sql
    // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
    // 	}
    // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
    // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
    // 	}
    // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
    // 	function prepareSelectedColumns() {
    // 		return selectedColumns.map((key) => ({
    // 			dbKey: tableConfig.columns[key]!.name,
    // 			tsKey: key,
    // 			field: tableConfig.columns[key] as PgColumn,
    // 			relationTableTsKey: undefined,
    // 			isJson: false,
    // 			selection: [],
    // 		}));
    // 	}
    // 	function prepareSelectedExtras() {
    // 		return selectedExtras.map((item) => ({
    // 			dbKey: item.value.fieldAlias,
    // 			tsKey: item.tsKey,
    // 			field: item.value,
    // 			relationTableTsKey: undefined,
    // 			isJson: false,
    // 			selection: [],
    // 		}));
    // 	}
    // 	if (isRoot) {
    // 		selection = [
    // 			...prepareSelectedColumns(),
    // 			...prepareSelectedExtras(),
    // 		];
    // 	}
    // 	if (hasUserDefinedWhere || orderBy.length > 0) {
    // 		tableFrom = new Subquery(
    // 			this.buildSelectQuery({
    // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
    // 				fields: {},
    // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
    // 					path: [],
    // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
    // 				})),
    // 				joins,
    // 				distinct,
    // 			}),
    // 			{},
    // 			tableAlias,
    // 		);
    // 		selectionForBuild = selection.map((item) =>
    // 			is(item.field, SQL.Aliased)
    // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
    // 				: item
    // 		);
    // 		joins = [];
    // 		distinct = undefined;
    // 	}
    // 	const result = this.buildSelectQuery({
    // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
    // 		fields: {},
    // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
    // 			path: [],
    // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
    // 		})),
    // 		where,
    // 		limit,
    // 		offset,
    // 		joins,
    // 		orderBy,
    // 		distinct,
    // 	});
    // 	return {
    // 		tableTsKey: tableConfig.tsName,
    // 		sql: result,
    // 		selection,
    // 	};
    // }
    buildRelationalQueryWithoutPK({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, getOperators())
                    : config.where;
                where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (is(orderByValue, Column)) {
                    return aliasedTableColumn(orderByValue, tableAlias);
                }
                return mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                const joinOn = and(...normalizedRelation.fields.map((field, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQueryWithoutPK({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: is(relation, One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                const field = sql `${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
                joins.push({
                    on: sql `true`,
                    table: new Subquery(builtRelation.sql, {}, relationTableAlias),
                    alias: relationTableAlias,
                    joinType: 'left',
                    lateral: true,
                });
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
            let field = sql `json_build_array(${sql.join(selection.map(({ field, tsKey, isJson }) => isJson
                ? sql `${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier('data')}`
                : is(field, SQL.Aliased)
                    ? field.sql
                    : field), sql `, `)})`;
            if (is(nestedQueryRelation, Many)) {
                field = sql `coalesce(json_agg(${field}${orderBy.length > 0 ? sql ` order by ${sql.join(orderBy, sql `, `)}` : undefined}), '[]'::json)`;
                // orderBy = [];
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field: field.as('data'),
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [{
                            path: [],
                            field: sql.raw('*'),
                        }],
                    where,
                    limit,
                    offset,
                    orderBy,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = [];
            }
            else {
                result = aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
}
_a$d = entityKind;
PgDialect[_a$d] = 'PgDialect';

var _a$c;
class TypedQueryBuilder {
    /** @internal */
    getSelectedFields() {
        return this._.selectedFields;
    }
}
_a$c = entityKind;
TypedQueryBuilder[_a$c] = 'TypedQueryBuilder';

var _a$b, _b$7, _c$5;
class PgSelectBuilder {
    constructor(config) {
        this.withList = [];
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
            this.withList = config.withList;
        }
        this.distinct = config.distinct;
    }
    /**
     * Specify the table, subquery, or other target that you're
     * building a select query against.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM|Postgres from documentation}
     */
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (is(source, Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (is(source, PgViewBase)) {
            fields = source[ViewBaseConfig].selectedFields;
        }
        else if (is(source, SQL)) {
            fields = {};
        }
        else {
            fields = getTableColumns(source);
        }
        return new PgSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
_a$b = entityKind;
PgSelectBuilder[_a$b] = 'PgSelectBuilder';
class PgSelectQueryBuilder extends TypedQueryBuilder {
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        /**
         * For each row of the table, include
         * values from a matching row of the joined
         * table, if there is a matching row. If not,
         * all of the columns of the joined table
         * will be set to null.
         */
        this.leftJoin = this.createJoin('left');
        /**
         * Includes all of the rows of the joined table.
         * If there is no matching row in the main table,
         * all the columns of the main table will be
         * set to null.
         */
        this.rightJoin = this.createJoin('right');
        /**
         * This is the default type of join.
         *
         * For each row of the table, the joined table
         * needs to have a matching row, or it will
         * be excluded from results.
         */
        this.innerJoin = this.createJoin('inner');
        /**
         * Rows from both the main & joined are included,
         * regardless of whether or not they have matching
         * rows in the other table.
         */
        this.fullJoin = this.createJoin('full');
        this.config = {
            withList,
            table,
            fields: { ...fields },
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !is(table, SQL)) {
                    const selection = is(table, Subquery)
                        ? table[SubqueryConfig].selection
                        : is(table, View)
                            ? table[ViewBaseConfig].selectedFields
                            : table[Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            if (!this.config.joins) {
                this.config.joins = [];
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    /**
     * Specify a condition to narrow the result set. Multiple
     * conditions can be combined with the `and` and `or`
     * functions.
     *
     * ## Examples
     *
     * ```ts
     * // Find cars made in the year 2000
     * db.select().from(cars).where(eq(cars.year, 2000));
     * ```
     */
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    /**
     * Sets the HAVING clause of this query, which often
     * used with GROUP BY and filters rows after they've been
     * grouped together and combined.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING|Postgres having clause documentation}
     */
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    /**
     * Set the maximum number of rows that will be
     * returned by this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the first 10 people from this query.
     * db.select().from(people).limit(10);
     * ```
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-LIMIT|Postgres LIMIT documentation}
     */
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    /**
     * Skip a number of rows when returning results
     * from this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the 10th-20th people from this query.
     * db.select().from(people).offset(10).limit(10);
     * ```
     */
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    /**
     * The FOR clause specifies a lock strength for this query
     * that controls how strictly it acquires exclusive access to
     * the rows being queried.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE|Postgres locking clause documentation}
     */
    for(strength, config = {}) {
        if (!this.config.lockingClauses) {
            this.config.lockingClauses = [];
        }
        this.config.lockingClauses.push({ strength, config });
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
_b$7 = entityKind;
PgSelectQueryBuilder[_b$7] = 'PgSelectQueryBuilder';
class PgSelect extends PgSelectQueryBuilder {
    constructor() {
        super(...arguments);
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
    }
    _prepare(name) {
        const { session, config, dialect, joinsNotNullableMap } = this;
        if (!session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            const fieldsList = orderSelectedFields(config.fields);
            const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
            query.joinsNotNullableMap = joinsNotNullableMap;
            return query;
        });
    }
    /**
     * Create a prepared statement for this query. This allows
     * the database to remember this query for the given session
     * and call it by name, rather than specifying the full query.
     *
     * {@link https://www.postgresql.org/docs/current/sql-prepare.html|Postgres prepare documentation}
     */
    prepare(name) {
        return this._prepare(name);
    }
}
_c$5 = entityKind;
PgSelect[_c$5] = 'PgSelect';
applyMixins(PgSelect, [QueryPromise]);

var _a$a;
class QueryBuilder {
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                distinct: true,
            });
        }
        function selectDistinctOn(on, fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                distinct: { on },
            });
        }
        return { select, selectDistinct, selectDistinctOn };
    }
    select(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
        });
    }
    selectDistinct(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: { on },
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new PgDialect();
        }
        return this.dialect;
    }
}
_a$a = entityKind;
QueryBuilder[_a$a] = 'PgQueryBuilder';

var _a$9;
class PgRefreshMaterializedView extends QueryPromise {
    constructor(view, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return tracer.startActiveSpan('drizzle.operation', () => {
                return this._prepare().execute(placeholderValues);
            });
        };
        this.config = { view };
    }
    concurrently() {
        if (this.config.withNoData !== undefined) {
            throw new Error('Cannot use concurrently and withNoData together');
        }
        this.config.concurrently = true;
        return this;
    }
    withNoData() {
        if (this.config.concurrently !== undefined) {
            throw new Error('Cannot use concurrently and withNoData together');
        }
        this.config.withNoData = true;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildRefreshMaterializedViewQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name);
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_a$9 = entityKind;
PgRefreshMaterializedView[_a$9] = 'PgRefreshMaterializedView';

var _a$8, _b$6;
class PgUpdateBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new PgUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
_a$8 = entityKind;
PgUpdateBuilder[_a$8] = 'PgUpdateBuilder';
class PgUpdate extends QueryPromise {
    constructor(table, set, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return this._prepare().execute(placeholderValues);
        };
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[Table.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    _prepare(name) {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    }
    prepare(name) {
        return this._prepare(name);
    }
}
_b$6 = entityKind;
PgUpdate[_b$6] = 'PgUpdate';

var _a$7, _b$5, _c$4, _d$2, _e$1, _f$1, _g, _h, _j;
class DefaultViewBuilderCore {
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
        this.config = {};
    }
    with(config) {
        this.config.with = config;
        return this;
    }
}
_a$7 = entityKind;
DefaultViewBuilderCore[_a$7] = 'PgDefaultViewBuilderCore';
class ViewBuilder extends DefaultViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgView({
            pgConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_b$5 = entityKind;
ViewBuilder[_b$5] = 'PgViewBuilder';
class ManualViewBuilder extends DefaultViewBuilderCore {
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
    }
    existing() {
        return new Proxy(new PgView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new PgView({
            pgConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_c$4 = entityKind;
ManualViewBuilder[_c$4] = 'PgManualViewBuilder';
class MaterializedViewBuilderCore {
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
        this.config = {};
    }
    using(using) {
        this.config.using = using;
        return this;
    }
    with(config) {
        this.config.with = config;
        return this;
    }
    tablespace(tablespace) {
        this.config.tablespace = tablespace;
        return this;
    }
    withNoData() {
        this.config.withNoData = true;
        return this;
    }
}
_d$2 = entityKind;
MaterializedViewBuilderCore[_d$2] = 'PgMaterializedViewBuilderCore';
class MaterializedViewBuilder extends MaterializedViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgMaterializedView({
            pgConfig: {
                with: this.config.with,
                using: this.config.using,
                tablespace: this.config.tablespace,
                withNoData: this.config.withNoData,
            },
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_e$1 = entityKind;
MaterializedViewBuilder[_e$1] = 'PgMaterializedViewBuilder';
class ManualMaterializedViewBuilder extends MaterializedViewBuilderCore {
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
    }
    existing() {
        return new Proxy(new PgMaterializedView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new PgMaterializedView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_f$1 = entityKind;
ManualMaterializedViewBuilder[_f$1] = 'PgManualMaterializedViewBuilder';
class PgViewBase extends View {
}
_g = entityKind;
PgViewBase[_g] = 'PgViewBase';
const PgViewConfig = Symbol.for('drizzle:PgViewConfig');
class PgView extends PgViewBase {
    constructor({ pgConfig, config }) {
        super(config);
        if (pgConfig) {
            this[PgViewConfig] = {
                with: pgConfig.with,
            };
        }
    }
}
_h = entityKind;
PgView[_h] = 'PgView';
const PgMaterializedViewConfig = Symbol.for('drizzle:PgMaterializedViewConfig');
class PgMaterializedView extends PgViewBase {
    constructor({ pgConfig, config }) {
        super(config);
        this[PgMaterializedViewConfig] = {
            with: pgConfig?.with,
            using: pgConfig?.using,
            tablespace: pgConfig?.tablespace,
            withNoData: pgConfig?.withNoData,
        };
    }
}
_j = entityKind;
PgMaterializedView[_j] = 'PgMaterializedView';
/** @internal */
function pgViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualViewBuilder(name, selection, schema);
    }
    return new ViewBuilder(name, schema);
}
/** @internal */
function pgMaterializedViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualMaterializedViewBuilder(name, selection, schema);
    }
    return new MaterializedViewBuilder(name, schema);
}
function pgView(name, columns) {
    return pgViewWithSchema(name, columns, undefined);
}
function pgMaterializedView(name, columns) {
    return pgMaterializedViewWithSchema(name, columns, undefined);
}

var _a$6, _b$4;
class RelationalQueryBuilder {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
    }
    findMany(config) {
        return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many');
    }
    findFirst(config) {
        return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first');
    }
}
_a$6 = entityKind;
RelationalQueryBuilder[_a$6] = 'PgRelationalQueryBuilder';
class PgRelationalQuery extends QueryPromise {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
    }
    _prepare(name) {
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            const { query, builtQuery } = this._toSQL();
            return this.session.prepareQuery(builtQuery, undefined, name, (rawRows, mapColumnValue) => {
                const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
                if (this.mode === 'first') {
                    return rows[0];
                }
                return rows;
            });
        });
    }
    prepare(name) {
        return this._prepare(name);
    }
    _toSQL() {
        const query = this.dialect.buildRelationalQueryWithoutPK({
            fullSchema: this.fullSchema,
            schema: this.schema,
            tableNamesMap: this.tableNamesMap,
            table: this.table,
            tableConfig: this.tableConfig,
            queryConfig: this.config,
            tableAlias: this.tableConfig.tsName,
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
    }
    toSQL() {
        return this._toSQL().builtQuery;
    }
    execute() {
        return tracer.startActiveSpan('drizzle.operation', () => {
            return this._prepare().execute();
        });
    }
}
_b$4 = entityKind;
PgRelationalQuery[_b$4] = 'PgRelationalQuery';

var _a$5;
class PgDatabase {
    constructor(
    /** @internal */
    dialect, 
    /** @internal */
    session, schema) {
        this.dialect = dialect;
        this.session = session;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
            }
        }
    }
    $with(alias) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        return { select };
    }
    select(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
        });
    }
    selectDistinct(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: { on },
        });
    }
    update(table) {
        return new PgUpdateBuilder(table, this.session, this.dialect);
    }
    insert(table) {
        return new PgInsertBuilder(table, this.session, this.dialect);
    }
    delete(table) {
        return new PgDelete(table, this.session, this.dialect);
    }
    refreshMaterializedView(view) {
        return new PgRefreshMaterializedView(view, this.session, this.dialect);
    }
    execute(query) {
        return this.session.execute(query.getSQL());
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}
_a$5 = entityKind;
PgDatabase[_a$5] = 'PgDatabase';

var _a$4;
class PgSchema {
    constructor(schemaName) {
        this.schemaName = schemaName;
        this.table = ((name, columns, extraConfig) => {
            return pgTableWithSchema(name, columns, extraConfig, this.schemaName);
        });
        this.view = ((name, columns) => {
            return pgViewWithSchema(name, columns, this.schemaName);
        });
        this.materializedView = ((name, columns) => {
            return pgMaterializedViewWithSchema(name, columns, this.schemaName);
        });
    }
}
_a$4 = entityKind;
PgSchema[_a$4] = 'PgSchema';
function isPgSchema(obj) {
    return is(obj, PgSchema);
}
function pgSchema(name) {
    if (name === 'public') {
        throw new Error(`You can't specify 'public' as schema name. Postgres is using public schema by default. If you want to use 'public' schema, just use pgTable() instead of creating a schema`);
    }
    return new PgSchema(name);
}

var _a$3, _b$3, _c$3;
class PreparedQuery {
}
_a$3 = entityKind;
PreparedQuery[_a$3] = 'PgPreparedQuery';
class PgSession {
    constructor(dialect) {
        this.dialect = dialect;
    }
    execute(query) {
        return tracer.startActiveSpan('drizzle.operation', () => {
            const prepared = tracer.startActiveSpan('drizzle.prepareQuery', () => {
                return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined);
            });
            return prepared.execute();
        });
    }
    all(query) {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined).all();
    }
}
_b$3 = entityKind;
PgSession[_b$3] = 'PgSession';
class PgTransaction extends PgDatabase {
    constructor(dialect, session, schema, nestedIndex = 0) {
        super(dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new TransactionRollbackError();
    }
    /** @internal */
    getTransactionConfigSQL(config) {
        const chunks = [];
        if (config.isolationLevel) {
            chunks.push(`isolation level ${config.isolationLevel}`);
        }
        if (config.accessMode) {
            chunks.push(config.accessMode);
        }
        if (typeof config.deferrable === 'boolean') {
            chunks.push(config.deferrable ? 'deferrable' : 'not deferrable');
        }
        return sql.raw(chunks.join(' '));
    }
    setTransaction(config) {
        return this.session.execute(sql `set transaction ${this.getTransactionConfigSQL(config)}`);
    }
}
_c$3 = entityKind;
PgTransaction[_c$3] = 'PgTransaction';

var _a$2, _b$2, _c$2, _d$1;
class Relation {
    constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
    }
}
_a$2 = entityKind;
Relation[_a$2] = 'Relation';
class Relations {
    constructor(table, config) {
        this.table = table;
        this.config = config;
    }
}
_b$2 = entityKind;
Relations[_b$2] = 'Relations';
class One extends Relation {
    constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
        this.isNullable = isNullable;
    }
    withFieldName(fieldName) {
        const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
        relation.fieldName = fieldName;
        return relation;
    }
}
_c$2 = entityKind;
One[_c$2] = 'One';
class Many extends Relation {
    constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
    }
    withFieldName(fieldName) {
        const relation = new Many(this.sourceTable, this.referencedTable, this.config);
        relation.fieldName = fieldName;
        return relation;
    }
}
_d$1 = entityKind;
Many[_d$1] = 'Many';
function getOperators() {
    return {
        and,
        between,
        eq,
        exists,
        gt,
        gte,
        ilike,
        inArray,
        isNull,
        isNotNull,
        like,
        lt,
        lte,
        ne,
        not,
        notBetween,
        notExists,
        notLike,
        notIlike,
        notInArray,
        or,
        sql,
    };
}
function getOrderByOperators() {
    return {
        sql,
        asc,
        desc,
    };
}
function extractTablesRelationalConfig(schema, configHelpers) {
    if (Object.keys(schema).length === 1
        && 'default' in schema
        && !is(schema['default'], Table)) {
        schema = schema['default'];
    }
    // table DB name -> schema table key
    const tableNamesMap = {};
    // Table relations found before their tables - need to buffer them until we know the schema table key
    const relationsBuffer = {};
    const tablesConfig = {};
    for (const [key, value] of Object.entries(schema)) {
        if (isTable(value)) {
            const dbName = value[Table.Symbol.Name];
            const bufferedRelations = relationsBuffer[dbName];
            tableNamesMap[dbName] = key;
            tablesConfig[key] = {
                tsName: key,
                dbName: value[Table.Symbol.Name],
                columns: value[Table.Symbol.Columns],
                relations: bufferedRelations?.relations ?? {},
                primaryKey: bufferedRelations?.primaryKey ?? [],
            };
            // Fill in primary keys
            for (const column of Object.values(value[Table.Symbol.Columns])) {
                if (column.primary) {
                    tablesConfig[key].primaryKey.push(column);
                }
            }
            const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
            if (extraConfig) {
                for (const configEntry of Object.values(extraConfig)) {
                    if (is(configEntry, PrimaryKeyBuilder)) {
                        tablesConfig[key].primaryKey.push(...configEntry.columns);
                    }
                }
            }
        }
        else if (is(value, Relations)) {
            const dbName = value.table[Table.Symbol.Name];
            const tableName = tableNamesMap[dbName];
            const relations = value.config(configHelpers(value.table));
            let primaryKey;
            for (const [relationName, relation] of Object.entries(relations)) {
                if (tableName) {
                    const tableConfig = tablesConfig[tableName];
                    tableConfig.relations[relationName] = relation;
                }
                else {
                    if (!(dbName in relationsBuffer)) {
                        relationsBuffer[dbName] = {
                            relations: {},
                            primaryKey,
                        };
                    }
                    relationsBuffer[dbName].relations[relationName] = relation;
                }
            }
        }
    }
    return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations) {
    return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key),
    ])));
}
function createOne(sourceTable) {
    return function one(table, config) {
        return new One(sourceTable, table, config, (config?.fields.reduce((res, f) => res && f.notNull, true)
            ?? false));
    };
}
function createMany(sourceTable) {
    return function many(referencedTable, config) {
        return new Many(sourceTable, referencedTable, config);
    };
}
function normalizeRelation(schema, tableNamesMap, relation) {
    if (is(relation, One) && relation.config) {
        return {
            fields: relation.config.fields,
            references: relation.config.references,
        };
    }
    const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
    if (!referencedTableTsName) {
        throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
    }
    const referencedTableConfig = schema[referencedTableTsName];
    if (!referencedTableConfig) {
        throw new Error(`Table "${referencedTableTsName}" not found in schema`);
    }
    const sourceTable = relation.sourceTable;
    const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
    if (!sourceTableTsName) {
        throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
    }
    const reverseRelations = [];
    for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
        if ((relation.relationName
            && relation !== referencedTableRelation
            && referencedTableRelation.relationName === relation.relationName)
            || (!relation.relationName
                && referencedTableRelation.referencedTable === relation.sourceTable)) {
            reverseRelations.push(referencedTableRelation);
        }
    }
    if (reverseRelations.length > 1) {
        throw relation.relationName
            ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`)
            : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
    }
    if (reverseRelations[0]
        && is(reverseRelations[0], One)
        && reverseRelations[0].config) {
        return {
            fields: reverseRelations[0].config.references,
            references: reverseRelations[0].config.fields,
        };
    }
    throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
    return {
        one: createOne(sourceTable),
        many: createMany(sourceTable),
    };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
    const result = {};
    for (const [selectionItemIndex, selectionItem,] of buildQueryResultSelection.entries()) {
        if (selectionItem.isJson) {
            const relation = tableConfig.relations[selectionItem.tsKey];
            const rawSubRows = row[selectionItemIndex];
            const subRows = typeof rawSubRows === 'string'
                ? JSON.parse(rawSubRows)
                : rawSubRows;
            result[selectionItem.tsKey] = is(relation, One)
                ? subRows
                    && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue)
                : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
        }
        else {
            const value = mapColumnValue(row[selectionItemIndex]);
            const field = selectionItem.field;
            let decoder;
            if (is(field, Column)) {
                decoder = field;
            }
            else if (is(field, SQL)) {
                decoder = field.decoder;
            }
            else {
                decoder = field.sql.decoder;
            }
            result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
        }
    }
    return result;
}

function bindIfParam(value, column) {
    if (isDriverValueEncoder(column)
        && !isSQLWrapper(value)
        && !is(value, Param)
        && !is(value, Placeholder)
        && !is(value, Column)
        && !is(value, Table)
        && !is(value, View)) {
        return new Param(value, column);
    }
    return value;
}
/**
 * Test that two values are equal.
 *
 * Remember that the SQL standard dictates that
 * two NULL values are not equal, so if you want to test
 * whether a value is null, you may want to use
 * `isNull` instead.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made by Ford
 * db.select().from(cars)
 *   .where(eq(cars.make, 'Ford'))
 * ```
 *
 * @see isNull for a way to test equality to NULL.
 */
const eq = (left, right) => {
    return sql `${left} = ${bindIfParam(right, left)}`;
};
/**
 * Test that two values are not equal.
 *
 * Remember that the SQL standard dictates that
 * two NULL values are not equal, so if you want to test
 * whether a value is not null, you may want to use
 * `isNotNull` instead.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars not made by Ford
 * db.select().from(cars)
 *   .where(ne(cars.make, 'Ford'))
 * ```
 *
 * @see isNotNull for a way to test whether a value is not null.
 */
const ne = (left, right) => {
    return sql `${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
    const conditions = unfilteredConditions.filter((c) => c !== undefined);
    if (conditions.length === 0) {
        return undefined;
    }
    if (conditions.length === 1) {
        return new SQL(conditions);
    }
    return new SQL([
        new StringChunk('('),
        sql.join(conditions, new StringChunk(' and ')),
        new StringChunk(')'),
    ]);
}
function or(...unfilteredConditions) {
    const conditions = unfilteredConditions.filter((c) => c !== undefined);
    if (conditions.length === 0) {
        return undefined;
    }
    if (conditions.length === 1) {
        return new SQL(conditions);
    }
    return new SQL([
        new StringChunk('('),
        sql.join(conditions, new StringChunk(' or ')),
        new StringChunk(')'),
    ]);
}
/**
 * Negate the meaning of an expression using the `not` keyword.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars _not_ made by GM or Ford.
 * db.select().from(cars)
 *   .where(not(inArray(cars.make, ['GM', 'Ford'])))
 * ```
 */
function not(condition) {
    return sql `not ${condition}`;
}
/**
 * Test that the first expression passed is greater than
 * the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made after 2000.
 * db.select().from(cars)
 *   .where(gt(cars.year, 2000))
 * ```
 *
 * @see gte for greater-than-or-equal
 */
const gt = (left, right) => {
    return sql `${left} > ${bindIfParam(right, left)}`;
};
/**
 * Test that the first expression passed is greater than
 * or equal to the second expression. Use `gt` to
 * test whether an expression is strictly greater
 * than another.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made on or after 2000.
 * db.select().from(cars)
 *   .where(gte(cars.year, 2000))
 * ```
 *
 * @see gt for a strictly greater-than condition
 */
const gte = (left, right) => {
    return sql `${left} >= ${bindIfParam(right, left)}`;
};
/**
 * Test that the first expression passed is less than
 * the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made before 2000.
 * db.select().from(cars)
 *   .where(lt(cars.year, 2000))
 * ```
 *
 * @see lte for greater-than-or-equal
 */
const lt = (left, right) => {
    return sql `${left} < ${bindIfParam(right, left)}`;
};
/**
 * Test that the first expression passed is less than
 * or equal to the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made before 2000.
 * db.select().from(cars)
 *   .where(lte(cars.year, 2000))
 * ```
 *
 * @see lt for a strictly less-than condition
 */
const lte = (left, right) => {
    return sql `${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('inArray requires at least one value');
        }
        return sql `${column} in ${values.map((v) => bindIfParam(v, column))}`;
    }
    return sql `${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('notInArray requires at least one value');
        }
        return sql `${column} not in ${values.map((v) => bindIfParam(v, column))}`;
    }
    return sql `${column} not in ${bindIfParam(values, column)}`;
}
/**
 * Test whether an expression is NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have no discontinuedAt date.
 * db.select().from(cars)
 *   .where(isNull(cars.discontinuedAt))
 * ```
 *
 * @see isNotNull for the inverse of this test
 */
function isNull(value) {
    return sql `${value} is null`;
}
/**
 * Test whether an expression is not NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have been discontinued.
 * db.select().from(cars)
 *   .where(isNotNull(cars.discontinuedAt))
 * ```
 *
 * @see isNull for the inverse of this test
 */
function isNotNull(value) {
    return sql `${value} is not null`;
}
/**
 * Test whether a subquery evaluates to have any rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column has a match in a cities
 * // table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     exists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see notExists for the inverse of this test
 */
function exists(subquery) {
    return sql `exists (${subquery})`;
}
/**
 * Test whether a subquery doesn't include any result
 * rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column doesn't match
 * // a row in the cities table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     notExists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see exists for the inverse of this test
 */
function notExists(subquery) {
    return sql `not exists (${subquery})`;
}
function between(column, min, max) {
    return sql `${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
    return sql `${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
/**
 * Compare a column to a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(like(cars.name, '%Turbo%'))
 * ```
 *
 * @see ilike for a case-insensitive version of this condition
 */
function like(column, value) {
    return sql `${column} like ${value}`;
}
/**
 * The inverse of like - this tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "ROver" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see like for the inverse condition
 * @see notIlike for a case-insensitive version of this condition
 */
function notLike(column, value) {
    return sql `${column} not like ${value}`;
}
/**
 * Case-insensitively compare a column to a pattern,
 * which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * Unlike like, this performs a case-insensitive comparison.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(ilike(cars.name, '%Turbo%'))
 * ```
 *
 * @see like for a case-sensitive version of this condition
 */
function ilike(column, value) {
    return sql `${column} ilike ${value}`;
}
/**
 * The inverse of ilike - this case-insensitively tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "Rover" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see ilike for the inverse condition
 * @see notLike for a case-sensitive version of this condition
 */
function notIlike(column, value) {
    return sql `${column} not ilike ${value}`;
}
function arrayContains(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('arrayContains requires at least one value');
        }
        const array = sql `${bindIfParam(values, column)}`;
        return sql `${column} @> ${array}`;
    }
    return sql `${column} @> ${bindIfParam(values, column)}`;
}
function arrayContained(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('arrayContained requires at least one value');
        }
        const array = sql `${bindIfParam(values, column)}`;
        return sql `${column} <@ ${array}`;
    }
    return sql `${column} <@ ${bindIfParam(values, column)}`;
}
function arrayOverlaps(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('arrayOverlaps requires at least one value');
        }
        const array = sql `${bindIfParam(values, column)}`;
        return sql `${column} && ${array}`;
    }
    return sql `${column} && ${bindIfParam(values, column)}`;
}

/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in ascending
 * order. By the SQL standard, ascending order is the
 * default, so it is not usually necessary to specify
 * ascending sort order.
 *
 * ## Examples
 *
 * ```ts
 * // Return cars, starting with the oldest models
 * // and going in ascending order to the newest.
 * db.select().from(cars)
 *   .orderBy(asc(cars.year));
 * ```
 *
 * @see desc to sort in descending order
 */
function asc(column) {
    return sql `${column} asc`;
}
/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in descending
 * order.
 *
 * ## Examples
 *
 * ```ts
 * // Select users, with the most recently created
 * // records coming first.
 * db.select().from(users)
 *   .orderBy(desc(users.createdAt));
 * ```
 *
 * @see asc to sort in ascending order
 */
function desc(column) {
    return sql `${column} desc`;
}

var _a$1, _b$1, _c$1, _d, _e, _f;
/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
class FakePrimitiveParam {
}
_a$1 = entityKind;
FakePrimitiveParam[_a$1] = 'FakePrimitiveParam';
function isSQLWrapper(value) {
    return typeof value === 'object' && value !== null && 'getSQL' in value
        && typeof value.getSQL === 'function';
}
function mergeQueries(queries) {
    const result = { sql: '', params: [] };
    for (const query of queries) {
        result.sql += query.sql;
        result.params.push(...query.params);
        if (query.typings?.length) {
            if (!result.typings) {
                result.typings = [];
            }
            result.typings.push(...query.typings);
        }
    }
    return result;
}
class StringChunk {
    constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
    }
    getSQL() {
        return new SQL([this]);
    }
}
_b$1 = entityKind;
StringChunk[_b$1] = 'StringChunk';
class SQL {
    constructor(queryChunks) {
        this.queryChunks = queryChunks;
        /** @internal */
        this.decoder = noopDecoder;
        this.shouldInlineParams = false;
    }
    append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
    }
    toQuery(config) {
        return tracer.startActiveSpan('drizzle.buildSQL', (span) => {
            const query = this.buildQueryFromSourceParams(this.queryChunks, config);
            span?.setAttributes({
                'drizzle.query.text': query.sql,
                'drizzle.query.params': JSON.stringify(query.params),
            });
            return query;
        });
    }
    buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
            inlineParams: _config.inlineParams || this.shouldInlineParams,
            paramStartIndex: _config.paramStartIndex || { value: 0 },
        });
        const { escapeName, escapeParam, prepareTyping, inlineParams, paramStartIndex, } = config;
        return mergeQueries(chunks.map((chunk) => {
            if (is(chunk, StringChunk)) {
                return { sql: chunk.value.join(''), params: [] };
            }
            if (is(chunk, Name)) {
                return { sql: escapeName(chunk.value), params: [] };
            }
            if (chunk === undefined) {
                return { sql: '', params: [] };
            }
            if (Array.isArray(chunk)) {
                const result = [new StringChunk('(')];
                for (const [i, p] of chunk.entries()) {
                    result.push(p);
                    if (i < chunk.length - 1) {
                        result.push(new StringChunk(', '));
                    }
                }
                result.push(new StringChunk(')'));
                return this.buildQueryFromSourceParams(result, config);
            }
            if (is(chunk, SQL)) {
                return this.buildQueryFromSourceParams(chunk.queryChunks, {
                    ...config,
                    inlineParams: inlineParams || chunk.shouldInlineParams,
                });
            }
            if (is(chunk, Table)) {
                const schemaName = chunk[Table.Symbol.Schema];
                const tableName = chunk[Table.Symbol.Name];
                return {
                    sql: schemaName === undefined
                        ? escapeName(tableName)
                        : escapeName(schemaName) + '.' + escapeName(tableName),
                    params: [],
                };
            }
            if (is(chunk, Column)) {
                return { sql: escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(chunk.name), params: [] };
            }
            if (is(chunk, View)) {
                const schemaName = chunk[ViewBaseConfig].schema;
                const viewName = chunk[ViewBaseConfig].name;
                return {
                    sql: schemaName === undefined
                        ? escapeName(viewName)
                        : escapeName(schemaName) + '.' + escapeName(viewName),
                    params: [],
                };
            }
            if (is(chunk, Param)) {
                const mappedValue = (chunk.value === null) ? null : chunk.encoder.mapToDriverValue(chunk.value);
                if (is(mappedValue, SQL)) {
                    return this.buildQueryFromSourceParams([mappedValue], config);
                }
                if (inlineParams) {
                    return { sql: this.mapInlineParam(mappedValue, config), params: [] };
                }
                let typings;
                if (prepareTyping !== undefined) {
                    typings = [prepareTyping(chunk.encoder)];
                }
                return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
            }
            if (is(chunk, Placeholder)) {
                return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
            }
            if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
                return { sql: escapeName(chunk.fieldAlias), params: [] };
            }
            if (is(chunk, Subquery)) {
                if (chunk[SubqueryConfig].isWith) {
                    return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
                }
                return this.buildQueryFromSourceParams([
                    new StringChunk('('),
                    chunk[SubqueryConfig].sql,
                    new StringChunk(') '),
                    new Name(chunk[SubqueryConfig].alias),
                ], config);
            }
            // if (is(chunk, Placeholder)) {
            // 	return {sql: escapeParam}
            if (isSQLWrapper(chunk)) {
                return this.buildQueryFromSourceParams([
                    new StringChunk('('),
                    chunk.getSQL(),
                    new StringChunk(')'),
                ], config);
            }
            if (is(chunk, Relation)) {
                return this.buildQueryFromSourceParams([
                    chunk.sourceTable,
                    new StringChunk('.'),
                    sql.identifier(chunk.fieldName),
                ], config);
            }
            if (inlineParams) {
                return { sql: this.mapInlineParam(chunk, config), params: [] };
            }
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
        }));
    }
    mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
            return 'null';
        }
        if (typeof chunk === 'number' || typeof chunk === 'boolean') {
            return chunk.toString();
        }
        if (typeof chunk === 'string') {
            return escapeString(chunk);
        }
        if (typeof chunk === 'object') {
            const mappedValueAsString = chunk.toString();
            if (mappedValueAsString === '[object Object]') {
                return escapeString(JSON.stringify(chunk));
            }
            return escapeString(mappedValueAsString);
        }
        throw new Error('Unexpected param value: ' + chunk);
    }
    getSQL() {
        return this;
    }
    as(alias) {
        // TODO: remove with deprecated overloads
        if (alias === undefined) {
            return this;
        }
        return new SQL.Aliased(this, alias);
    }
    mapWith(decoder) {
        this.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;
        return this;
    }
    inlineParams() {
        this.shouldInlineParams = true;
        return this;
    }
}
_c$1 = entityKind;
SQL[_c$1] = 'SQL';
/**
 * Any DB name (table, column, index etc.)
 */
class Name {
    constructor(value) {
        this.value = value;
    }
    getSQL() {
        return new SQL([this]);
    }
}
_d = entityKind;
Name[_d] = 'Name';
/**
 * Any DB name (table, column, index etc.)
 * @deprecated Use `sql.identifier` instead.
 */
function name(value) {
    return new Name(value);
}
function isDriverValueEncoder(value) {
    return typeof value === 'object' && value !== null && 'mapToDriverValue' in value
        && typeof value.mapToDriverValue === 'function';
}
const noopDecoder = {
    mapFromDriverValue: (value) => value,
};
const noopEncoder = {
    mapToDriverValue: (value) => value,
};
const noopMapper = {
    ...noopDecoder,
    ...noopEncoder,
};
/** Parameter value that is optionally bound to an encoder (for example, a column). */
class Param {
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value, encoder = noopEncoder) {
        this.value = value;
        this.encoder = encoder;
    }
    getSQL() {
        return new SQL([this]);
    }
}
_e = entityKind;
Param[_e] = 'Param';
/** @deprecated Use `sql.param` instead. */
function param(value, encoder) {
    return new Param(value, encoder);
}
/*
    The type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -
    in runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values
    which will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload
    specify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and
    the type checker happy.
*/
function sql(strings, ...params) {
    const queryChunks = [];
    if (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {
        queryChunks.push(new StringChunk(strings[0]));
    }
    for (const [paramIndex, param] of params.entries()) {
        queryChunks.push(param, new StringChunk(strings[paramIndex + 1]));
    }
    return new SQL(queryChunks);
}
(function (sql) {
    function empty() {
        return new SQL([]);
    }
    sql.empty = empty;
    /** @deprecated - use `sql.join()` */
    function fromList(list) {
        return new SQL(list);
    }
    sql.fromList = fromList;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str) {
        return new SQL([new StringChunk(str)]);
    }
    sql.raw = raw;
    /**
     * Join a list of SQL chunks with a separator.
     * @example
     * ```ts
     * const query = sql.join([sql`a`, sql`b`, sql`c`]);
     * // sql`abc`
     * ```
     * @example
     * ```ts
     * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);
     * // sql`a, b, c`
     * ```
     */
    function join(chunks, separator) {
        const result = [];
        for (const [i, chunk] of chunks.entries()) {
            if (i > 0 && separator !== undefined) {
                result.push(separator);
            }
            result.push(chunk);
        }
        return new SQL(result);
    }
    sql.join = join;
    /**
     * Create a SQL chunk that represents a DB identifier (table, column, index etc.).
     * When used in a query, the identifier will be escaped based on the DB engine.
     * For example, in PostgreSQL, identifiers are escaped with double quotes.
     *
     * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**
     *
     * @example ```ts
     * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;
     * // 'SELECT * FROM "my-table"'
     * ```
     */
    function identifier(value) {
        return new Name(value);
    }
    sql.identifier = identifier;
    function placeholder(name) {
        return new Placeholder(name);
    }
    sql.placeholder = placeholder;
    function param(value, encoder) {
        return new Param(value, encoder);
    }
    sql.param = param;
})(sql || (sql = {}));
(function (SQL) {
    var _g;
    class Aliased {
        constructor(sql, fieldAlias) {
            this.sql = sql;
            this.fieldAlias = fieldAlias;
            /** @internal */
            this.isSelectionField = false;
        }
        getSQL() {
            return this.sql;
        }
        /** @internal */
        clone() {
            return new Aliased(this.sql, this.fieldAlias);
        }
    }
    _g = entityKind;
    Aliased[_g] = 'SQL.Aliased';
    SQL.Aliased = Aliased;
})(SQL || (SQL = {}));
class Placeholder {
    constructor(name) {
        this.name = name;
    }
    getSQL() {
        return new SQL([this]);
    }
}
_f = entityKind;
Placeholder[_f] = 'Placeholder';
/** @deprecated Use `sql.placeholder` instead. */
function placeholder(name) {
    return new Placeholder(name);
}
function fillPlaceholders(params, values) {
    return params.map((p) => {
        if (is(p, Placeholder)) {
            if (!(p.name in values)) {
                throw new Error(`No value for placeholder "${p.name}" was provided`);
            }
            return values[p.name];
        }
        return p;
    });
}
// Defined separately from the Column class to resolve circular dependency
Column.prototype.getSQL = function () {
    return new SQL([this]);
};

var _a, _b, _c;
class ColumnAliasProxyHandler {
    constructor(table) {
        this.table = table;
    }
    get(columnObj, prop) {
        if (prop === 'table') {
            return this.table;
        }
        return columnObj[prop];
    }
}
_a = entityKind;
ColumnAliasProxyHandler[_a] = 'ColumnAliasProxyHandler';
class TableAliasProxyHandler {
    constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
    }
    get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
            return true;
        }
        if (prop === Table.Symbol.Name) {
            return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
            return this.alias;
        }
        if (prop === ViewBaseConfig) {
            return {
                ...target[ViewBaseConfig],
                name: this.alias,
                isAlias: true,
            };
        }
        if (prop === Table.Symbol.Columns) {
            const columns = target[Table.Symbol.Columns];
            if (!columns) {
                return columns;
            }
            const proxiedColumns = {};
            Object.keys(columns).map((key) => {
                proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
            });
            return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
            return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
    }
}
_b = entityKind;
TableAliasProxyHandler[_b] = 'TableAliasProxyHandler';
class RelationTableAliasProxyHandler {
    constructor(alias) {
        this.alias = alias;
    }
    get(target, prop) {
        if (prop === 'sourceTable') {
            return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
    }
}
_c = entityKind;
RelationTableAliasProxyHandler[_c] = 'RelationTableAliasProxyHandler';
function aliasedTable(table, tableAlias) {
    return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedRelation(relation, tableAlias) {
    return new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));
}
function aliasedTableColumn(column, tableAlias) {
    return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
    return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
    return sql.join(query.queryChunks.map((c) => {
        if (is(c, Column)) {
            return aliasedTableColumn(c, alias);
        }
        if (is(c, SQL)) {
            return mapColumnsInSQLToAlias(c, alias);
        }
        if (is(c, SQL.Aliased)) {
            return mapColumnsInAliasedSQLToAlias(c, alias);
        }
        return c;
    }));
}

exports.BaseName = BaseName;
exports.Check = Check;
exports.CheckBuilder = CheckBuilder;
exports.Column = Column;
exports.ColumnAliasProxyHandler = ColumnAliasProxyHandler;
exports.ColumnBuilder = ColumnBuilder;
exports.Columns = Columns;
exports.ConsoleLogWriter = ConsoleLogWriter;
exports.DefaultLogger = DefaultLogger;
exports.DefaultViewBuilderCore = DefaultViewBuilderCore;
exports.DrizzleError = DrizzleError;
exports.ExtraConfigBuilder = ExtraConfigBuilder;
exports.FakePrimitiveParam = FakePrimitiveParam;
exports.ForeignKey = ForeignKey;
exports.ForeignKeyBuilder = ForeignKeyBuilder;
exports.Index = Index;
exports.IndexBuilder = IndexBuilder;
exports.IndexBuilderOn = IndexBuilderOn;
exports.InlineForeignKeys = InlineForeignKeys;
exports.IsAlias = IsAlias;
exports.ManualMaterializedViewBuilder = ManualMaterializedViewBuilder;
exports.ManualViewBuilder = ManualViewBuilder;
exports.Many = Many;
exports.MaterializedViewBuilder = MaterializedViewBuilder;
exports.MaterializedViewBuilderCore = MaterializedViewBuilderCore;
exports.Name = Name;
exports.NoopLogger = NoopLogger;
exports.One = One;
exports.OriginalName = OriginalName;
exports.Param = Param;
exports.PgArray = PgArray;
exports.PgArrayBuilder = PgArrayBuilder;
exports.PgBigInt53 = PgBigInt53;
exports.PgBigInt53Builder = PgBigInt53Builder;
exports.PgBigInt64 = PgBigInt64;
exports.PgBigInt64Builder = PgBigInt64Builder;
exports.PgBigSerial53 = PgBigSerial53;
exports.PgBigSerial53Builder = PgBigSerial53Builder;
exports.PgBigSerial64 = PgBigSerial64;
exports.PgBigSerial64Builder = PgBigSerial64Builder;
exports.PgBoolean = PgBoolean;
exports.PgBooleanBuilder = PgBooleanBuilder;
exports.PgChar = PgChar;
exports.PgCharBuilder = PgCharBuilder;
exports.PgCidr = PgCidr;
exports.PgCidrBuilder = PgCidrBuilder;
exports.PgColumn = PgColumn;
exports.PgColumnBuilder = PgColumnBuilder;
exports.PgCustomColumn = PgCustomColumn;
exports.PgCustomColumnBuilder = PgCustomColumnBuilder;
exports.PgDatabase = PgDatabase;
exports.PgDate = PgDate;
exports.PgDateBuilder = PgDateBuilder;
exports.PgDateString = PgDateString;
exports.PgDateStringBuilder = PgDateStringBuilder;
exports.PgDelete = PgDelete;
exports.PgDialect = PgDialect;
exports.PgDoublePrecision = PgDoublePrecision;
exports.PgDoublePrecisionBuilder = PgDoublePrecisionBuilder;
exports.PgEnumColumn = PgEnumColumn;
exports.PgEnumColumnBuilder = PgEnumColumnBuilder;
exports.PgInet = PgInet;
exports.PgInetBuilder = PgInetBuilder;
exports.PgInsert = PgInsert;
exports.PgInsertBuilder = PgInsertBuilder;
exports.PgInteger = PgInteger;
exports.PgIntegerBuilder = PgIntegerBuilder;
exports.PgInterval = PgInterval;
exports.PgIntervalBuilder = PgIntervalBuilder;
exports.PgJson = PgJson;
exports.PgJsonBuilder = PgJsonBuilder;
exports.PgJsonb = PgJsonb;
exports.PgJsonbBuilder = PgJsonbBuilder;
exports.PgMacaddr = PgMacaddr;
exports.PgMacaddr8 = PgMacaddr8;
exports.PgMacaddr8Builder = PgMacaddr8Builder;
exports.PgMacaddrBuilder = PgMacaddrBuilder;
exports.PgMaterializedView = PgMaterializedView;
exports.PgMaterializedViewConfig = PgMaterializedViewConfig;
exports.PgNumeric = PgNumeric;
exports.PgNumericBuilder = PgNumericBuilder;
exports.PgReal = PgReal;
exports.PgRealBuilder = PgRealBuilder;
exports.PgRefreshMaterializedView = PgRefreshMaterializedView;
exports.PgSchema = PgSchema;
exports.PgSelect = PgSelect;
exports.PgSelectBuilder = PgSelectBuilder;
exports.PgSelectQueryBuilder = PgSelectQueryBuilder;
exports.PgSerial = PgSerial;
exports.PgSerialBuilder = PgSerialBuilder;
exports.PgSession = PgSession;
exports.PgSmallInt = PgSmallInt;
exports.PgSmallIntBuilder = PgSmallIntBuilder;
exports.PgSmallSerial = PgSmallSerial;
exports.PgSmallSerialBuilder = PgSmallSerialBuilder;
exports.PgTable = PgTable;
exports.PgText = PgText;
exports.PgTextBuilder = PgTextBuilder;
exports.PgTime = PgTime;
exports.PgTimeBuilder = PgTimeBuilder;
exports.PgTimestamp = PgTimestamp;
exports.PgTimestampBuilder = PgTimestampBuilder;
exports.PgTimestampString = PgTimestampString;
exports.PgTimestampStringBuilder = PgTimestampStringBuilder;
exports.PgTransaction = PgTransaction;
exports.PgUUID = PgUUID;
exports.PgUUIDBuilder = PgUUIDBuilder;
exports.PgUpdate = PgUpdate;
exports.PgUpdateBuilder = PgUpdateBuilder;
exports.PgVarchar = PgVarchar;
exports.PgVarcharBuilder = PgVarcharBuilder;
exports.PgView = PgView;
exports.PgViewBase = PgViewBase;
exports.PgViewConfig = PgViewConfig;
exports.Placeholder = Placeholder;
exports.PreparedQuery = PreparedQuery;
exports.PrimaryKey = PrimaryKey;
exports.PrimaryKeyBuilder = PrimaryKeyBuilder;
exports.QueryBuilder = QueryBuilder;
exports.QueryPromise = QueryPromise;
exports.Relation = Relation;
exports.RelationTableAliasProxyHandler = RelationTableAliasProxyHandler;
exports.Relations = Relations;
exports.SQL = SQL;
exports.Schema = Schema;
exports.SelectionProxyHandler = SelectionProxyHandler;
exports.StringChunk = StringChunk;
exports.Subquery = Subquery;
exports.SubqueryConfig = SubqueryConfig;
exports.Table = Table;
exports.TableAliasProxyHandler = TableAliasProxyHandler;
exports.TableName = TableName;
exports.TransactionRollbackError = TransactionRollbackError;
exports.TypedQueryBuilder = TypedQueryBuilder;
exports.UniqueConstraint = UniqueConstraint;
exports.UniqueConstraintBuilder = UniqueConstraintBuilder;
exports.UniqueOnConstraintBuilder = UniqueOnConstraintBuilder;
exports.View = View;
exports.ViewBaseConfig = ViewBaseConfig;
exports.ViewBuilder = ViewBuilder;
exports.WithSubquery = WithSubquery;
exports.aliasedRelation = aliasedRelation;
exports.aliasedTable = aliasedTable;
exports.aliasedTableColumn = aliasedTableColumn;
exports.and = and;
exports.applyMixins = applyMixins;
exports.arrayContained = arrayContained;
exports.arrayContains = arrayContains;
exports.arrayOverlaps = arrayOverlaps;
exports.asc = asc;
exports.between = between;
exports.bigint = bigint;
exports.bigserial = bigserial;
exports.bindIfParam = bindIfParam;
exports.boolean = boolean;
exports.char = char;
exports.check = check;
exports.cidr = cidr;
exports.createMany = createMany;
exports.createOne = createOne;
exports.createTableRelationsHelpers = createTableRelationsHelpers;
exports.customType = customType;
exports.date = date;
exports.decimal = decimal;
exports.desc = desc;
exports.doublePrecision = doublePrecision;
exports.entityKind = entityKind;
exports.eq = eq;
exports.exists = exists;
exports.extractTablesRelationalConfig = extractTablesRelationalConfig;
exports.fillPlaceholders = fillPlaceholders;
exports.foreignKey = foreignKey;
exports.getMaterializedViewConfig = getMaterializedViewConfig;
exports.getOperators = getOperators;
exports.getOrderByOperators = getOrderByOperators;
exports.getTableColumns = getTableColumns;
exports.getTableConfig = getTableConfig;
exports.getTableLikeName = getTableLikeName;
exports.getTableName = getTableName;
exports.getViewConfig = getViewConfig;
exports.gt = gt;
exports.gte = gte;
exports.hasOwnEntityKind = hasOwnEntityKind;
exports.iife = iife;
exports.ilike = ilike;
exports.inArray = inArray;
exports.index = index;
exports.inet = inet;
exports.integer = integer;
exports.interval = interval;
exports.is = is;
exports.isDriverValueEncoder = isDriverValueEncoder;
exports.isNotNull = isNotNull;
exports.isNull = isNull;
exports.isPgEnum = isPgEnum;
exports.isPgSchema = isPgSchema;
exports.isSQLWrapper = isSQLWrapper;
exports.isTable = isTable;
exports.json = json;
exports.jsonb = jsonb;
exports.like = like;
exports.lt = lt;
exports.lte = lte;
exports.macaddr = macaddr;
exports.macaddr8 = macaddr8;
exports.makePgArray = makePgArray;
exports.mapColumnsInAliasedSQLToAlias = mapColumnsInAliasedSQLToAlias;
exports.mapColumnsInSQLToAlias = mapColumnsInSQLToAlias;
exports.mapRelationalRow = mapRelationalRow;
exports.mapResultRow = mapResultRow;
exports.mapUpdateSet = mapUpdateSet;
exports.name = name;
exports.ne = ne;
exports.noopDecoder = noopDecoder;
exports.noopEncoder = noopEncoder;
exports.noopMapper = noopMapper;
exports.normalizeRelation = normalizeRelation;
exports.not = not;
exports.notBetween = notBetween;
exports.notExists = notExists;
exports.notIlike = notIlike;
exports.notInArray = notInArray;
exports.notLike = notLike;
exports.numeric = numeric;
exports.or = or;
exports.orderSelectedFields = orderSelectedFields;
exports.param = param;
exports.parsePgArray = parsePgArray;
exports.parsePgNestedArray = parsePgNestedArray;
exports.pgEnum = pgEnum;
exports.pgMaterializedView = pgMaterializedView;
exports.pgMaterializedViewWithSchema = pgMaterializedViewWithSchema;
exports.pgSchema = pgSchema;
exports.pgTable = pgTable;
exports.pgTableCreator = pgTableCreator;
exports.pgTableWithSchema = pgTableWithSchema;
exports.pgView = pgView;
exports.pgViewWithSchema = pgViewWithSchema;
exports.placeholder = placeholder;
exports.primaryKey = primaryKey;
exports.real = real;
exports.relations = relations;
exports.serial = serial;
exports.smallint = smallint;
exports.smallserial = smallserial;
exports.sql = sql;
exports.text = text;
exports.time = time;
exports.timestamp = timestamp;
exports.tracer = tracer;
exports.unique = unique;
exports.uniqueIndex = uniqueIndex;
exports.uniqueKeyName = uniqueKeyName;
exports.uuid = uuid;
exports.varchar = varchar;
//# sourceMappingURL=index-1899b9ae.cjs.map
