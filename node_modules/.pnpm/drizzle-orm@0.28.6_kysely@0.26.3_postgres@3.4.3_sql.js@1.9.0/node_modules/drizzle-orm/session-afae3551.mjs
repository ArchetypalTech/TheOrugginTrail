import { T as Table, e as entityKind, Q as QueryPromise, o as orderSelectedFields, i as is, S as SQL, b as Param, s as sql, d as mapUpdateSet, C as ColumnBuilder, p as Column, j as SelectionProxyHandler, I as getTableColumns, v as View, q as getTableName, r as Subquery, u as SubqueryConfig, V as ViewBaseConfig, w as aliasedTableColumn, x as getOperators, y as mapColumnsInSQLToAlias, z as mapColumnsInAliasedSQLToAlias, A as getOrderByOperators, B as normalizeRelation, E as and, F as eq, O as One, D as DrizzleError, M as Many, G as aliasedTable, H as applyMixins, J as TypedQueryBuilder, K as getTableLikeName, W as WithSubquery, g as mapRelationalRow, l as TransactionRollbackError } from './alias-cf8e03cd.mjs';

/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:SQLiteInlineForeignKeys');
class SQLiteTable extends Table {
    static [entityKind] = 'SQLiteTable';
    /** @internal */
    static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys,
    });
    /** @internal */
    [Table.Symbol.Columns];
    /** @internal */
    [InlineForeignKeys] = [];
    /** @internal */
    [Table.Symbol.ExtraConfigBuilder] = undefined;
}
function sqliteTableBase(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new SQLiteTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilderBase]) => {
        const colBuilder = colBuilderBase;
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const sqliteTable = (name, columns, extraConfig) => {
    return sqliteTableBase(name, columns, extraConfig);
};
function sqliteTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return sqliteTableBase(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

class SQLiteDelete extends QueryPromise {
    table;
    session;
    dialect;
    static [entityKind] = 'SQLiteDelete';
    /** @internal */
    config;
    constructor(table, session, dialect) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? 'all' : 'run');
    }
    run = (placeholderValues) => {
        return this.prepare(true).run(placeholderValues);
    };
    all = (placeholderValues) => {
        return this.prepare(true).all(placeholderValues);
    };
    get = (placeholderValues) => {
        return this.prepare(true).get(placeholderValues);
    };
    values = (placeholderValues) => {
        return this.prepare(true).values(placeholderValues);
    };
    async execute(placeholderValues) {
        return this.prepare(true).execute(placeholderValues);
    }
}

class SQLiteInsertBuilder {
    table;
    session;
    dialect;
    static [entityKind] = 'SQLiteInsertBuilder';
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
            }
            return result;
        });
        // if (mappedValues.length > 1 && mappedValues.some((t) => Object.keys(t).length === 0)) {
        // 	throw new Error(
        // 		`One of the values you want to insert is empty. In SQLite you can insert only one empty object per statement. For this case Drizzle with use "INSERT INTO ... DEFAULT VALUES" syntax`,
        // 	);
        // }
        return new SQLiteInsert(this.table, mappedValues, this.session, this.dialect);
    }
}
class SQLiteInsert extends QueryPromise {
    session;
    dialect;
    static [entityKind] = 'SQLiteInsert';
    /** @internal */
    config;
    constructor(table, values, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table, values };
    }
    returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    onConflictDoNothing(config = {}) {
        if (config.target === undefined) {
            this.config.onConflict = sql `do nothing`;
        }
        else {
            const targetSql = Array.isArray(config.target) ? sql `${config.target}` : sql `${[config.target]}`;
            const whereSql = config.where ? sql ` where ${config.where}` : sql ``;
            this.config.onConflict = sql `${targetSql} do nothing${whereSql}`;
        }
        return this;
    }
    onConflictDoUpdate(config) {
        const targetSql = Array.isArray(config.target) ? sql `${config.target}` : sql `${[config.target]}`;
        const whereSql = config.where ? sql ` where ${config.where}` : sql ``;
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = sql `${targetSql} do update set ${setSql}${whereSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? 'all' : 'run');
    }
    run = (placeholderValues) => {
        return this.prepare(true).run(placeholderValues);
    };
    all = (placeholderValues) => {
        return this.prepare(true).all(placeholderValues);
    };
    get = (placeholderValues) => {
        return this.prepare(true).get(placeholderValues);
    };
    values = (placeholderValues) => {
        return this.prepare(true).values(placeholderValues);
    };
    async execute() {
        return (this.config.returning ? this.all() : this.run());
    }
}

class ForeignKeyBuilder {
    static [entityKind] = 'SQLiteForeignKeyBuilder';
    /** @internal */
    reference;
    /** @internal */
    _onUpdate;
    /** @internal */
    _onDelete;
    constructor(config, actions) {
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
class ForeignKey {
    table;
    static [entityKind] = 'SQLiteForeignKey';
    reference;
    onUpdate;
    onDelete;
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[SQLiteTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[SQLiteTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config();
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

function uniqueKeyName(table, columns) {
    return `${table[SQLiteTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
class UniqueConstraintBuilder {
    name;
    static [entityKind] = 'SQLiteUniqueConstraintBuilder';
    /** @internal */
    columns;
    constructor(columns, name) {
        this.name = name;
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.name);
    }
}
class UniqueOnConstraintBuilder {
    static [entityKind] = 'SQLiteUniqueOnConstraintBuilder';
    /** @internal */
    name;
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
class UniqueConstraint {
    table;
    static [entityKind] = 'SQLiteUniqueConstraint';
    columns;
    name;
    constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    }
    getName() {
        return this.name;
    }
}

class SQLiteColumnBuilder extends ColumnBuilder {
    static [entityKind] = 'SQLiteColumnBuilder';
    foreignKeyConfigs = [];
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return ((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            })(ref, actions);
        });
    }
}
// To understand how to use `SQLiteColumn` and `AnySQLiteColumn`, see `Column` and `AnyColumn` documentation.
class SQLiteColumn extends Column {
    table;
    static [entityKind] = 'SQLiteColumn';
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}

class ViewBuilderCore {
    name;
    static [entityKind] = 'SQLiteViewBuilderCore';
    constructor(name) {
        this.name = name;
    }
    config = {};
}
class ViewBuilder extends ViewBuilderCore {
    static [entityKind] = 'SQLiteViewBuilder';
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        // const aliasedSelectedFields = new Proxy(qb.getSelectedFields(), selectionProxy);
        const aliasedSelectedFields = qb.getSelectedFields();
        return new Proxy(new SQLiteView({
            sqliteConfig: this.config,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: aliasedSelectedFields,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
class ManualViewBuilder extends ViewBuilderCore {
    static [entityKind] = 'SQLiteManualViewBuilder';
    columns;
    constructor(name, columns) {
        super(name);
        this.columns = getTableColumns(sqliteTable(name, columns));
    }
    existing() {
        return new Proxy(new SQLiteView({
            sqliteConfig: undefined,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new SQLiteView({
            sqliteConfig: this.config,
            config: {
                name: this.name,
                schema: undefined,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
class SQLiteViewBase extends View {
    static [entityKind] = 'SQLiteViewBase';
}
const SQLiteViewConfig = Symbol.for('drizzle:SQLiteViewConfig');
class SQLiteView extends SQLiteViewBase {
    static [entityKind] = 'SQLiteView';
    /** @internal */
    [SQLiteViewConfig];
    constructor({ sqliteConfig, config }) {
        super(config);
        this[SQLiteViewConfig] = sqliteConfig;
    }
}
function sqliteView(name, selection) {
    if (selection) {
        return new ManualViewBuilder(name, selection);
    }
    return new ViewBuilder(name);
}
const view = sqliteView;

class SQLiteDialect {
    static [entityKind] = 'SQLiteDialect';
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(_num) {
        return '?';
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql.join(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[Table.Symbol.Columns][colName];
            const res = sql `${sql.identifier(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (is(field, SQL.Aliased) && field.isSelectionField) {
                chunk.push(sql.identifier(field.fieldAlias));
            }
            else if (is(field, SQL.Aliased) || is(field, SQL)) {
                const query = is(field, SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new SQL(query.queryChunks.map((c) => {
                        if (is(c, Column)) {
                            return sql.identifier(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (is(field, SQL.Aliased)) {
                    chunk.push(sql ` as ${sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (is(field, Column)) {
                const tableName = field.table[Table.Symbol.Name];
                const columnName = field.name;
                if (isSingleTable) {
                    chunk.push(sql.identifier(columnName));
                }
                else {
                    chunk.push(sql `${sql.identifier(tableName)}.${sql.identifier(columnName)}`);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(sql `, `);
            }
            return chunk;
        });
        return sql.join(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, distinct }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (is(f.field, Column)
                && getTableName(f.field.table)
                    !== (is(table, Subquery)
                        ? table[SubqueryConfig].alias
                        : is(table, SQLiteViewBase)
                            ? table[ViewBaseConfig].name
                            : is(table, SQL)
                                ? undefined
                                : getTableName(table))
                && !((table) => joins?.some(({ alias }) => alias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(sql `${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(sql `, `);
                }
            }
            withSqlChunks.push(sql ` `);
            withSql = sql.join(withSqlChunks);
        }
        const distinctSql = distinct ? sql ` distinct` : undefined;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
                return sql `${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        if (joins) {
            for (const [index, joinMeta] of joins.entries()) {
                if (index === 0) {
                    joinsArray.push(sql ` `);
                }
                const table = joinMeta.table;
                if (is(table, SQLiteTable)) {
                    const tableName = table[SQLiteTable.Symbol.Name];
                    const tableSchema = table[SQLiteTable.Symbol.Schema];
                    const origTableName = table[SQLiteTable.Symbol.OriginalName];
                    const alias = tableName === origTableName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join ${tableSchema ? sql `${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else {
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join ${table} on ${joinMeta.on}`);
                }
                if (index < joins.length - 1) {
                    joinsArray.push(sql ` `);
                }
            }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql ` where ${where}` : undefined;
        const havingSql = having ? sql ` having ${having}` : undefined;
        const orderByList = [];
        if (orderBy) {
            for (const [index, orderByValue] of orderBy.entries()) {
                orderByList.push(orderByValue);
                if (index < orderBy.length - 1) {
                    orderByList.push(sql `, `);
                }
            }
        }
        const groupByList = [];
        if (groupBy) {
            for (const [index, groupByValue] of groupBy.entries()) {
                groupByList.push(groupByValue);
                if (index < groupBy.length - 1) {
                    groupByList.push(sql `, `);
                }
            }
        }
        const groupBySql = groupByList.length > 0 ? sql ` group by ${sql.join(groupByList)}` : undefined;
        const orderBySql = orderByList.length > 0 ? sql ` order by ${sql.join(orderByList)}` : undefined;
        const limitSql = limit ? sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? sql ` offset ${offset}` : undefined;
        return sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        // const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {
                    let defaultValue;
                    if (col.default !== null && col.default !== undefined) {
                        defaultValue = is(col.default, SQL) ? col.default : sql.param(col.default, col);
                        // eslint-disable-next-line unicorn/no-negated-condition
                    }
                    else if (col.defaultFn !== undefined) {
                        const defaultFnResult = col.defaultFn();
                        defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                    }
                    else {
                        defaultValue = sql `null`;
                    }
                    valueList.push(defaultValue);
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(sql `, `);
            }
        }
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? sql ` on conflict ${onConflict}` : undefined;
        // if (isSingleValue && valuesSqlList.length === 0){
        // 	return sql`insert into ${table} default values ${onConflictSql}${returningSql}`;
        // }
        return sql `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
        });
    }
    buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, getOperators())
                    : config.where;
                where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (is(orderByValue, Column)) {
                    return aliasedTableColumn(orderByValue, tableAlias);
                }
                return mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                // const relationTable = schema[relationTableTsName]!;
                const joinOn = and(...normalizedRelation.fields.map((field, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQuery({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: is(relation, One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                const field = (sql `(${builtRelation.sql})`).as(selectedRelationTsKey);
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
            let field = sql `json_array(${sql.join(selection.map(({ field }) => is(field, SQLiteColumn) ? sql.identifier(field.name) : is(field, SQL.Aliased) ? field.sql : field), sql `, `)})`;
            if (is(nestedQueryRelation, Many)) {
                field = sql `coalesce(json_group_array(${field}), json_array())`;
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field: field.as('data'),
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [
                        {
                            path: [],
                            field: sql.raw('*'),
                        },
                    ],
                    where,
                    limit,
                    offset,
                    orderBy,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = undefined;
            }
            else {
                result = aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: is(result, SQLiteTable) ? result : new Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
}
class SQLiteSyncDialect extends SQLiteDialect {
    static [entityKind] = 'SQLiteSyncDialect';
    migrate(migrations, session) {
        const migrationTableCreate = sql `
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        session.run(migrationTableCreate);
        const dbMigrations = session.values(sql `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = dbMigrations[0] ?? undefined;
        session.run(sql `BEGIN`);
        try {
            for (const migration of migrations) {
                if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        session.run(sql.raw(stmt));
                    }
                    session.run(sql `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
            session.run(sql `COMMIT`);
        }
        catch (e) {
            session.run(sql `ROLLBACK`);
            throw e;
        }
    }
}
class SQLiteAsyncDialect extends SQLiteDialect {
    static [entityKind] = 'SQLiteAsyncDialect';
    async migrate(migrations, session) {
        const migrationTableCreate = sql `
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
        await session.run(migrationTableCreate);
        const dbMigrations = await session.values(sql `SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
        const lastDbMigration = dbMigrations[0] ?? undefined;
        await session.transaction(async (tx) => {
            for (const migration of migrations) {
                if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.run(sql.raw(stmt));
                    }
                    await tx.run(sql `INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
}

class SQLiteSelectBuilder {
    static [entityKind] = 'SQLiteSelectBuilder';
    fields;
    session;
    dialect;
    withList;
    distinct;
    constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        this.withList = config.withList;
        this.distinct = config.distinct;
    }
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (is(source, Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (is(source, SQLiteViewBase)) {
            fields = source[ViewBaseConfig].selectedFields;
        }
        else if (is(source, SQL)) {
            fields = {};
        }
        else {
            fields = getTableColumns(source);
        }
        return new SQLiteSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
class SQLiteSelectQueryBuilder extends TypedQueryBuilder {
    static [entityKind] = 'SQLiteSelectQueryBuilder';
    _;
    /** @internal */
    config;
    joinsNotNullableMap;
    tableName;
    isPartialSelect;
    session;
    dialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
            withList,
            table,
            fields: { ...fields },
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !is(table, SQL)) {
                    const selection = is(table, Subquery)
                        ? table[SubqueryConfig].selection
                        : is(table, View)
                            ? table[ViewBaseConfig].selectedFields
                            : table[Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            if (!this.config.joins) {
                this.config.joins = [];
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    leftJoin = this.createJoin('left');
    rightJoin = this.createJoin('right');
    innerJoin = this.createJoin('inner');
    fullJoin = this.createJoin('full');
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
    getSelectedFields() {
        return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
class SQLiteSelect extends SQLiteSelectQueryBuilder {
    static [entityKind] = 'SQLiteSelect';
    prepare(isOneTimeQuery) {
        if (!this.session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), fieldsList, 'all');
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
    }
    run = (placeholderValues) => {
        return this.prepare(true).run(placeholderValues);
    };
    all = (placeholderValues) => {
        return this.prepare(true).all(placeholderValues);
    };
    get = (placeholderValues) => {
        return this.prepare(true).get(placeholderValues);
    };
    values = (placeholderValues) => {
        return this.prepare(true).values(placeholderValues);
    };
    async execute() {
        return this.all();
    }
}
applyMixins(SQLiteSelect, [QueryPromise]);

class QueryBuilder {
    static [entityKind] = 'SQLiteQueryBuilder';
    dialect;
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
    }
    selectDistinct(fields) {
        return new SQLiteSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new SQLiteSyncDialect();
        }
        return this.dialect;
    }
}

class SQLiteUpdateBuilder {
    table;
    session;
    dialect;
    static [entityKind] = 'SQLiteUpdateBuilder';
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new SQLiteUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
class SQLiteUpdate extends QueryPromise {
    session;
    dialect;
    static [entityKind] = 'SQLiteUpdate';
    /** @internal */
    config;
    constructor(table, set, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
        this.config.returning = orderSelectedFields(fields);
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare(isOneTimeQuery) {
        return this.session[isOneTimeQuery ? 'prepareOneTimeQuery' : 'prepareQuery'](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? 'all' : 'run');
    }
    run = (placeholderValues) => {
        return this.prepare(true).run(placeholderValues);
    };
    all = (placeholderValues) => {
        return this.prepare(true).all(placeholderValues);
    };
    get = (placeholderValues) => {
        return this.prepare(true).get(placeholderValues);
    };
    values = (placeholderValues) => {
        return this.prepare(true).values(placeholderValues);
    };
    async execute() {
        return (this.config.returning ? this.all() : this.run());
    }
}

class RelationalQueryBuilder {
    mode;
    fullSchema;
    schema;
    tableNamesMap;
    table;
    tableConfig;
    dialect;
    session;
    static [entityKind] = 'SQLiteAsyncRelationalQueryBuilder';
    constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
        this.mode = mode;
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
    }
    findMany(config) {
        return (this.mode === 'sync'
            ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many')
            : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many'));
    }
    findFirst(config) {
        return (this.mode === 'sync'
            ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first')
            : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first'));
    }
}
class SQLiteRelationalQuery extends QueryPromise {
    fullSchema;
    schema;
    tableNamesMap;
    table;
    tableConfig;
    dialect;
    session;
    config;
    static [entityKind] = 'SQLiteAsyncRelationalQuery';
    /** @internal */
    mode;
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.mode = mode;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildRelationalQuery({
            fullSchema: this.fullSchema,
            schema: this.schema,
            tableNamesMap: this.tableNamesMap,
            table: this.table,
            tableConfig: this.tableConfig,
            queryConfig: this.config,
            tableAlias: this.tableConfig.tsName,
        }).sql;
    }
    prepare() {
        const { query, builtQuery } = this._toSQL();
        return this.session.prepareQuery(builtQuery, undefined, this.mode === 'first' ? 'get' : 'all', (rawRows, mapColumnValue) => {
            const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
            if (this.mode === 'first') {
                return rows[0];
            }
            return rows;
        });
    }
    _toSQL() {
        const query = this.dialect.buildRelationalQuery({
            fullSchema: this.fullSchema,
            schema: this.schema,
            tableNamesMap: this.tableNamesMap,
            table: this.table,
            tableConfig: this.tableConfig,
            queryConfig: this.config,
            tableAlias: this.tableConfig.tsName,
        });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { query, builtQuery };
    }
    toSQL() {
        return this._toSQL().builtQuery;
    }
    /** @internal */
    executeRaw() {
        if (this.mode === 'first') {
            return this.prepare().get();
        }
        return this.prepare().all();
    }
    async execute() {
        return this.executeRaw();
    }
}
class SQLiteSyncRelationalQuery extends SQLiteRelationalQuery {
    static [entityKind] = 'SQLiteSyncRelationalQuery';
    sync() {
        return this.executeRaw();
    }
}

class SQLiteRaw extends QueryPromise {
    cb;
    getSQLCb;
    static [entityKind] = 'SQLiteRaw';
    /** @internal */
    config;
    constructor(cb, getSQLCb, action) {
        super();
        this.cb = cb;
        this.getSQLCb = getSQLCb;
        this.config = { action };
    }
    /** @internal */
    getSQL() {
        return this.getSQLCb();
    }
    async execute() {
        return this.cb();
    }
}

class BaseSQLiteDatabase {
    resultKind;
    dialect;
    session;
    static [entityKind] = 'BaseSQLiteDatabase';
    query;
    constructor(resultKind, 
    /** @internal */
    dialect, 
    /** @internal */
    session, schema) {
        this.resultKind = resultKind;
        this.dialect = dialect;
        this.session = session;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] = new RelationalQueryBuilder(resultKind, schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
            }
        }
    }
    $with(alias) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new SQLiteSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
    }
    selectDistinct(fields) {
        return new SQLiteSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    update(table) {
        return new SQLiteUpdateBuilder(table, this.session, this.dialect);
    }
    insert(into) {
        return new SQLiteInsertBuilder(into, this.session, this.dialect);
    }
    delete(from) {
        return new SQLiteDelete(from, this.session, this.dialect);
    }
    run(query) {
        const sql = query.getSQL();
        if (this.resultKind === 'async') {
            return new SQLiteRaw(async () => this.session.run(sql), () => sql, 'run');
        }
        return this.session.run(sql);
    }
    all(query) {
        const sql = query.getSQL();
        if (this.resultKind === 'async') {
            return new SQLiteRaw(async () => this.session.all(sql), () => sql, 'all');
        }
        return this.session.all(sql);
    }
    get(query) {
        const sql = query.getSQL();
        if (this.resultKind === 'async') {
            return new SQLiteRaw(async () => this.session.get(sql), () => sql, 'get');
        }
        return this.session.get(sql);
    }
    values(query) {
        const sql = query.getSQL();
        if (this.resultKind === 'async') {
            return new SQLiteRaw(async () => this.session.values(sql), () => sql, 'values');
        }
        return this.session.values(sql);
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}

class ExecuteResultSync extends QueryPromise {
    resultCb;
    static [entityKind] = 'ExecuteResultSync';
    constructor(resultCb) {
        super();
        this.resultCb = resultCb;
    }
    async execute() {
        return this.resultCb();
    }
    sync() {
        return this.resultCb();
    }
}
let PreparedQuery$1 = class PreparedQuery {
    mode;
    executeMethod;
    static [entityKind] = 'PreparedQuery';
    /** @internal */
    joinsNotNullableMap;
    constructor(mode, executeMethod) {
        this.mode = mode;
        this.executeMethod = executeMethod;
    }
    execute(placeholderValues) {
        if (this.mode === 'async') {
            return this[this.executeMethod](placeholderValues);
        }
        return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
    }
};
class SQLiteSession {
    dialect;
    static [entityKind] = 'SQLiteSession';
    constructor(
    /** @internal */
    dialect) {
        this.dialect = dialect;
    }
    prepareOneTimeQuery(query, fields, executeMethod) {
        return this.prepareQuery(query, fields, executeMethod);
    }
    run(query) {
        const staticQuery = this.dialect.sqlToQuery(query);
        try {
            return this.prepareOneTimeQuery(staticQuery, undefined, 'run').run();
        }
        catch (err) {
            throw DrizzleError.wrap(err, `Failed to run the query '${staticQuery.sql}'`);
        }
    }
    all(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run').all();
    }
    get(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run').get();
    }
    values(query) {
        return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, 'run').values();
    }
}
class SQLiteTransaction extends BaseSQLiteDatabase {
    schema;
    nestedIndex;
    static [entityKind] = 'SQLiteTransaction';
    constructor(resultType, dialect, session, schema, nestedIndex = 0) {
        super(resultType, dialect, session, schema);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new TransactionRollbackError();
    }
}

export { ViewBuilder as A, BaseSQLiteDatabase as B, SQLiteViewBase as C, SQLiteView as D, ExecuteResultSync as E, ForeignKeyBuilder as F, sqliteView as G, view as H, InlineForeignKeys as I, ManualViewBuilder as M, PreparedQuery$1 as P, QueryBuilder as Q, SQLiteSession as S, UniqueConstraintBuilder as U, ViewBuilderCore as V, SQLiteTransaction as a, SQLiteSyncDialect as b, SQLiteAsyncDialect as c, SQLiteSelect as d, SQLiteInsert as e, SQLiteUpdate as f, SQLiteDelete as g, SQLiteRaw as h, SQLiteRelationalQuery as i, SQLiteColumnBuilder as j, SQLiteColumn as k, SQLiteTable as l, SQLiteViewConfig as m, SQLiteDialect as n, ForeignKey as o, foreignKey as p, SQLiteInsertBuilder as q, SQLiteSelectBuilder as r, SQLiteSelectQueryBuilder as s, SQLiteUpdateBuilder as t, sqliteTable as u, sqliteTableCreator as v, uniqueKeyName as w, unique as x, UniqueOnConstraintBuilder as y, UniqueConstraint as z };
//# sourceMappingURL=session-afae3551.mjs.map
