'use strict';

var index = require('./index-1899b9ae.cjs');

var _a$C, _b$y, _c$9;
/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:MySqlInlineForeignKeys');
class MySqlTable extends index.Table {
    constructor() {
        super(...arguments);
        /** @internal */
        this[_b$y] = [];
        /** @internal */
        this[_c$9] = undefined;
    }
}
_a$C = index.entityKind, index.Table.Symbol.Columns, _b$y = InlineForeignKeys, _c$9 = index.Table.Symbol.ExtraConfigBuilder;
MySqlTable[_a$C] = 'MySqlTable';
/** @internal */
MySqlTable.Symbol = Object.assign({}, index.Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys,
});
function mysqlTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new MySqlTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilderBase]) => {
        const colBuilder = colBuilderBase;
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[index.Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[MySqlTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const mysqlTable = (name, columns, extraConfig) => {
    return mysqlTableWithSchema(name, columns, extraConfig, undefined, name);
};
function mysqlTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return mysqlTableWithSchema(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

var _a$B, _b$x;
class ForeignKeyBuilder {
    constructor(config, actions) {
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
_a$B = index.entityKind;
ForeignKeyBuilder[_a$B] = 'MySqlForeignKeyBuilder';
class ForeignKey {
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[MySqlTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[MySqlTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
_b$x = index.entityKind;
ForeignKey[_b$x] = 'MySqlForeignKey';
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config;
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

var _a$A, _b$w, _c$8;
function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
    return `${table[MySqlTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
class UniqueConstraintBuilder {
    constructor(columns, name) {
        this.name = name;
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.name);
    }
}
_a$A = index.entityKind;
UniqueConstraintBuilder[_a$A] = 'MySqlUniqueConstraintBuilder';
class UniqueOnConstraintBuilder {
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
_b$w = index.entityKind;
UniqueOnConstraintBuilder[_b$w] = 'MySqlUniqueOnConstraintBuilder';
class UniqueConstraint {
    constructor(table, columns, name) {
        this.table = table;
        this.nullsNotDistinct = false;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    }
    getName() {
        return this.name;
    }
}
_c$8 = index.entityKind;
UniqueConstraint[_c$8] = 'MySqlUniqueConstraint';

var _a$z, _b$v, _c$7, _d$5;
class MySqlColumnBuilder extends index.ColumnBuilder {
    constructor() {
        super(...arguments);
        this.foreignKeyConfigs = [];
    }
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return ((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            })(ref, actions);
        });
    }
}
_a$z = index.entityKind;
MySqlColumnBuilder[_a$z] = 'MySqlColumnBuilder';
// To understand how to use `MySqlColumn` and `AnyMySqlColumn`, see `Column` and `AnyColumn` documentation.
class MySqlColumn extends index.Column {
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}
_b$v = index.entityKind;
MySqlColumn[_b$v] = 'MySqlColumn';
class MySqlColumnBuilderWithAutoIncrement extends MySqlColumnBuilder {
    constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
    }
    autoincrement() {
        this.config.autoIncrement = true;
        this.config.hasDefault = true;
        return this;
    }
}
_c$7 = index.entityKind;
MySqlColumnBuilderWithAutoIncrement[_c$7] = 'MySqlColumnBuilderWithAutoIncrement';
class MySqlColumnWithAutoIncrement extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.autoIncrement = this.config.autoIncrement;
    }
}
_d$5 = index.entityKind;
MySqlColumnWithAutoIncrement[_d$5] = 'MySqlColumnWithAutoIncrement';

var _a$y, _b$u, _c$6, _d$4;
class MySqlBigInt53Builder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlBigInt53');
    }
    /** @internal */
    build(table) {
        return new MySqlBigInt53(table, this.config);
    }
}
_a$y = index.entityKind;
MySqlBigInt53Builder[_a$y] = 'MySqlBigInt53Builder';
class MySqlBigInt53 extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'bigint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'number') {
            return value;
        }
        return Number(value);
    }
}
_b$u = index.entityKind;
MySqlBigInt53[_b$u] = 'MySqlBigInt53';
class MySqlBigInt64Builder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'bigint', 'MySqlBigInt64');
    }
    /** @internal */
    build(table) {
        return new MySqlBigInt64(table, this.config);
    }
}
_c$6 = index.entityKind;
MySqlBigInt64Builder[_c$6] = 'MySqlBigInt64Builder';
class MySqlBigInt64 extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'bigint';
    }
    // eslint-disable-next-line unicorn/prefer-native-coercion-functions
    mapFromDriverValue(value) {
        return BigInt(value);
    }
}
_d$4 = index.entityKind;
MySqlBigInt64[_d$4] = 'MySqlBigInt64';
function bigint(name, config) {
    if (config.mode === 'number') {
        return new MySqlBigInt53Builder(name);
    }
    return new MySqlBigInt64Builder(name);
}

var _a$x, _b$t;
class MySqlBinaryBuilder extends MySqlColumnBuilder {
    constructor(name, length) {
        super(name, 'string', 'MySqlBinary');
        this.config.length = length;
    }
    /** @internal */
    build(table) {
        return new MySqlBinary(table, this.config);
    }
}
_a$x = index.entityKind;
MySqlBinaryBuilder[_a$x] = 'MySqlBinaryBuilder';
class MySqlBinary extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
    }
    getSQLType() {
        return this.length === undefined ? `binary` : `binary(${this.length})`;
    }
}
_b$t = index.entityKind;
MySqlBinary[_b$t] = 'MySqlBinary';
function binary(name, config = {}) {
    return new MySqlBinaryBuilder(name, config.length);
}

var _a$w, _b$s;
class MySqlBooleanBuilder extends MySqlColumnBuilder {
    constructor(name) {
        super(name, 'boolean', 'MySqlBoolean');
    }
    /** @internal */
    build(table) {
        return new MySqlBoolean(table, this.config);
    }
}
_a$w = index.entityKind;
MySqlBooleanBuilder[_a$w] = 'MySqlBooleanBuilder';
class MySqlBoolean extends MySqlColumn {
    getSQLType() {
        return 'boolean';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'boolean') {
            return value;
        }
        return value === 1;
    }
}
_b$s = index.entityKind;
MySqlBoolean[_b$s] = 'MySqlBoolean';
function boolean(name) {
    return new MySqlBooleanBuilder(name);
}

var _a$v, _b$r;
class MySqlCharBuilder extends MySqlColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'MySqlChar');
        this.config.length = config.length;
        this.config.enum = config.enum;
    }
    /** @internal */
    build(table) {
        return new MySqlChar(table, this.config);
    }
}
_a$v = index.entityKind;
MySqlCharBuilder[_a$v] = 'MySqlCharBuilder';
class MySqlChar extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
        this.enumValues = this.config.enum;
    }
    getSQLType() {
        return this.length === undefined ? `char` : `char(${this.length})`;
    }
}
_b$r = index.entityKind;
MySqlChar[_b$r] = 'MySqlChar';
function char(name, config = {}) {
    return new MySqlCharBuilder(name, config);
}

var _a$u, _b$q;
class MySqlCustomColumnBuilder extends MySqlColumnBuilder {
    constructor(name, fieldConfig, customTypeParams) {
        super(name, 'custom', 'MySqlCustomColumn');
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new MySqlCustomColumn(table, this.config);
    }
}
_a$u = index.entityKind;
MySqlCustomColumnBuilder[_a$u] = 'MySqlCustomColumnBuilder';
class MySqlCustomColumn extends MySqlColumn {
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
_b$q = index.entityKind;
MySqlCustomColumn[_b$q] = 'MySqlCustomColumn';
/**
 * Custom mysql database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new MySqlCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

var _a$t, _b$p, _c$5, _d$3;
class MySqlDateBuilder extends MySqlColumnBuilder {
    constructor(name) {
        super(name, 'date', 'MySqlDate');
    }
    /** @internal */
    build(table) {
        return new MySqlDate(table, this.config);
    }
}
_a$t = index.entityKind;
MySqlDateBuilder[_a$t] = 'MySqlDateBuilder';
class MySqlDate extends MySqlColumn {
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return `date`;
    }
    mapFromDriverValue(value) {
        return new Date(value);
    }
}
_b$p = index.entityKind;
MySqlDate[_b$p] = 'MySqlDate';
class MySqlDateStringBuilder extends MySqlColumnBuilder {
    constructor(name) {
        super(name, 'string', 'MySqlDateString');
    }
    /** @internal */
    build(table) {
        return new MySqlDateString(table, this.config);
    }
}
_c$5 = index.entityKind;
MySqlDateStringBuilder[_c$5] = 'MySqlDateStringBuilder';
class MySqlDateString extends MySqlColumn {
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return `date`;
    }
}
_d$3 = index.entityKind;
MySqlDateString[_d$3] = 'MySqlDateString';
function date(name, config = {}) {
    if (config.mode === 'string') {
        return new MySqlDateStringBuilder(name);
    }
    return new MySqlDateBuilder(name);
}

var _a$s, _b$o, _c$4, _d$2;
class MySqlDateTimeBuilder extends MySqlColumnBuilder {
    constructor(name, config) {
        super(name, 'date', 'MySqlDateTime');
        this.config.fsp = config?.fsp;
    }
    /** @internal */
    build(table) {
        return new MySqlDateTime(table, this.config);
    }
}
_a$s = index.entityKind;
MySqlDateTimeBuilder[_a$s] = 'MySqlDateTimeBuilder';
class MySqlDateTime extends MySqlColumn {
    constructor(table, config) {
        super(table, config);
        this.fsp = config.fsp;
    }
    getSQLType() {
        const precision = this.fsp === undefined ? '' : `(${this.fsp})`;
        return `datetime${precision}`;
    }
    mapToDriverValue(value) {
        return value.toISOString().replace('T', ' ').replace('Z', '');
    }
    mapFromDriverValue(value) {
        return new Date(value.replace(' ', 'T') + 'Z');
    }
}
_b$o = index.entityKind;
MySqlDateTime[_b$o] = 'MySqlDateTime';
class MySqlDateTimeStringBuilder extends MySqlColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'MySqlDateTimeString');
        this.config.fsp = config?.fsp;
    }
    /** @internal */
    build(table) {
        return new MySqlDateTimeString(table, this.config);
    }
}
_c$4 = index.entityKind;
MySqlDateTimeStringBuilder[_c$4] = 'MySqlDateTimeStringBuilder';
class MySqlDateTimeString extends MySqlColumn {
    constructor(table, config) {
        super(table, config);
        this.fsp = config.fsp;
    }
    getSQLType() {
        const precision = this.fsp === undefined ? '' : `(${this.fsp})`;
        return `datetime${precision}`;
    }
}
_d$2 = index.entityKind;
MySqlDateTimeString[_d$2] = 'MySqlDateTimeString';
function datetime(name, config = {}) {
    if (config.mode === 'string') {
        return new MySqlDateTimeStringBuilder(name, config);
    }
    return new MySqlDateTimeBuilder(name, config);
}

var _a$r, _b$n;
class MySqlDecimalBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name, precision, scale) {
        super(name, 'string', 'MySqlDecimal');
        this.config.precision = precision;
        this.config.scale = scale;
    }
    /** @internal */
    build(table) {
        return new MySqlDecimal(table, this.config);
    }
}
_a$r = index.entityKind;
MySqlDecimalBuilder[_a$r] = 'MySqlDecimalBuilder';
class MySqlDecimal extends MySqlColumnWithAutoIncrement {
    constructor() {
        super(...arguments);
        this.precision = this.config.precision;
        this.scale = this.config.scale;
    }
    getSQLType() {
        if (this.precision !== undefined && this.scale !== undefined) {
            return `decimal(${this.precision},${this.scale})`;
        }
        else if (this.precision === undefined) {
            return 'decimal';
        }
        else {
            return `decimal(${this.precision})`;
        }
    }
}
_b$n = index.entityKind;
MySqlDecimal[_b$n] = 'MySqlDecimal';
function decimal(name, config = {}) {
    return new MySqlDecimalBuilder(name, config.precision, config.scale);
}

var _a$q, _b$m;
class MySqlDoubleBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name, config) {
        super(name, 'number', 'MySqlDouble');
        this.config.precision = config?.precision;
        this.config.scale = config?.scale;
    }
    /** @internal */
    build(table) {
        return new MySqlDouble(table, this.config);
    }
}
_a$q = index.entityKind;
MySqlDoubleBuilder[_a$q] = 'MySqlDoubleBuilder';
class MySqlDouble extends MySqlColumnWithAutoIncrement {
    constructor() {
        super(...arguments);
        this.precision = this.config.precision;
        this.scale = this.config.scale;
    }
    getSQLType() {
        if (this.precision !== undefined && this.scale !== undefined) {
            return `double(${this.precision},${this.scale})`;
        }
        else if (this.precision === undefined) {
            return 'double';
        }
        else {
            return `double(${this.precision})`;
        }
    }
}
_b$m = index.entityKind;
MySqlDouble[_b$m] = 'MySqlDouble';
function double(name, config) {
    return new MySqlDoubleBuilder(name, config);
}

var _a$p, _b$l;
class MySqlEnumColumnBuilder extends MySqlColumnBuilder {
    constructor(name, values) {
        super(name, 'string', 'MySqlEnumColumn');
        this.config.enumValues = values;
    }
    /** @internal */
    build(table) {
        return new MySqlEnumColumn(table, this.config);
    }
}
_a$p = index.entityKind;
MySqlEnumColumnBuilder[_a$p] = 'MySqlEnumColumnBuilder';
class MySqlEnumColumn extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return `enum(${this.enumValues.map((value) => `'${value}'`).join(',')})`;
    }
}
_b$l = index.entityKind;
MySqlEnumColumn[_b$l] = 'MySqlEnumColumn';
function mysqlEnum(name, values) {
    if (values.length === 0) {
        throw new Error(`You have an empty array for "${name}" enum values`);
    }
    return new MySqlEnumColumnBuilder(name, values);
}

var _a$o, _b$k;
class MySqlFloatBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlFloat');
    }
    /** @internal */
    build(table) {
        return new MySqlFloat(table, this.config);
    }
}
_a$o = index.entityKind;
MySqlFloatBuilder[_a$o] = 'MySqlFloatBuilder';
class MySqlFloat extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'float';
    }
}
_b$k = index.entityKind;
MySqlFloat[_b$k] = 'MySqlFloat';
function float(name) {
    return new MySqlFloatBuilder(name);
}

var _a$n, _b$j;
class MySqlIntBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlInt');
    }
    /** @internal */
    build(table) {
        return new MySqlInt(table, this.config);
    }
}
_a$n = index.entityKind;
MySqlIntBuilder[_a$n] = 'MySqlIntBuilder';
class MySqlInt extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'int';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number(value);
        }
        return value;
    }
}
_b$j = index.entityKind;
MySqlInt[_b$j] = 'MySqlInt';
function int(name) {
    return new MySqlIntBuilder(name);
}

var _a$m, _b$i;
class MySqlJsonBuilder extends MySqlColumnBuilder {
    constructor(name) {
        super(name, 'json', 'MySqlJson');
    }
    /** @internal */
    build(table) {
        return new MySqlJson(table, this.config);
    }
}
_a$m = index.entityKind;
MySqlJsonBuilder[_a$m] = 'MySqlJsonBuilder';
class MySqlJson extends MySqlColumn {
    getSQLType() {
        return 'json';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
}
_b$i = index.entityKind;
MySqlJson[_b$i] = 'MySqlJson';
function json(name) {
    return new MySqlJsonBuilder(name);
}

var _a$l, _b$h;
class MySqlMediumIntBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlMediumInt');
    }
    /** @internal */
    build(table) {
        return new MySqlMediumInt(table, this.config);
    }
}
_a$l = index.entityKind;
MySqlMediumIntBuilder[_a$l] = 'MySqlMediumIntBuilder';
class MySqlMediumInt extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'mediumint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number(value);
        }
        return value;
    }
}
_b$h = index.entityKind;
MySqlMediumInt[_b$h] = 'MySqlMediumInt';
function mediumint(name) {
    return new MySqlMediumIntBuilder(name);
}

var _a$k, _b$g;
class MySqlRealBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name, config) {
        super(name, 'number', 'MySqlReal');
        this.config.precision = config?.precision;
        this.config.scale = config?.scale;
    }
    /** @internal */
    build(table) {
        return new MySqlReal(table, this.config);
    }
}
_a$k = index.entityKind;
MySqlRealBuilder[_a$k] = 'MySqlRealBuilder';
class MySqlReal extends MySqlColumnWithAutoIncrement {
    constructor() {
        super(...arguments);
        this.precision = this.config.precision;
        this.scale = this.config.scale;
    }
    getSQLType() {
        if (this.precision !== undefined && this.scale !== undefined) {
            return `real(${this.precision}, ${this.scale})`;
        }
        else if (this.precision === undefined) {
            return 'real';
        }
        else {
            return `real(${this.precision})`;
        }
    }
}
_b$g = index.entityKind;
MySqlReal[_b$g] = 'MySqlReal';
function real(name, config = {}) {
    return new MySqlRealBuilder(name, config);
}

var _a$j, _b$f;
class MySqlSerialBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlSerial');
        this.config.hasDefault = true;
        this.config.autoIncrement = true;
    }
    /** @internal */
    build(table) {
        return new MySqlSerial(table, this.config);
    }
}
_a$j = index.entityKind;
MySqlSerialBuilder[_a$j] = 'MySqlSerialBuilder';
class MySqlSerial extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'serial';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number(value);
        }
        return value;
    }
}
_b$f = index.entityKind;
MySqlSerial[_b$f] = 'MySqlSerial';
function serial(name) {
    return new MySqlSerialBuilder(name);
}

var _a$i, _b$e;
class MySqlSmallIntBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlSmallInt');
    }
    /** @internal */
    build(table) {
        return new MySqlSmallInt(table, this.config);
    }
}
_a$i = index.entityKind;
MySqlSmallIntBuilder[_a$i] = 'MySqlSmallIntBuilder';
class MySqlSmallInt extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'smallint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number(value);
        }
        return value;
    }
}
_b$e = index.entityKind;
MySqlSmallInt[_b$e] = 'MySqlSmallInt';
function smallint(name) {
    return new MySqlSmallIntBuilder(name);
}

var _a$h, _b$d;
class MySqlTextBuilder extends MySqlColumnBuilder {
    constructor(name, textType, config) {
        super(name, 'string', 'MySqlText');
        this.config.textType = textType;
        this.config.enumValues = config.enum;
    }
    /** @internal */
    build(table) {
        return new MySqlText(table, this.config);
    }
}
_a$h = index.entityKind;
MySqlTextBuilder[_a$h] = 'MySqlTextBuilder';
class MySqlText extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.textType = this.config.textType;
        this.enumValues = this.config.enumValues;
    }
    getSQLType() {
        return this.textType;
    }
}
_b$d = index.entityKind;
MySqlText[_b$d] = 'MySqlText';
function text(name, config = {}) {
    return new MySqlTextBuilder(name, 'text', config);
}
function tinytext(name, config = {}) {
    return new MySqlTextBuilder(name, 'tinytext', config);
}
function mediumtext(name, config = {}) {
    return new MySqlTextBuilder(name, 'mediumtext', config);
}
function longtext(name, config = {}) {
    return new MySqlTextBuilder(name, 'longtext', config);
}

var _a$g, _b$c;
class MySqlTimeBuilder extends MySqlColumnBuilder {
    constructor(name, config) {
        super(name, 'string', 'MySqlTime');
        this.config.fsp = config?.fsp;
    }
    /** @internal */
    build(table) {
        return new MySqlTime(table, this.config);
    }
}
_a$g = index.entityKind;
MySqlTimeBuilder[_a$g] = 'MySqlTimeBuilder';
class MySqlTime extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.fsp = this.config.fsp;
    }
    getSQLType() {
        const precision = this.fsp === undefined ? '' : `(${this.fsp})`;
        return `time${precision}`;
    }
}
_b$c = index.entityKind;
MySqlTime[_b$c] = 'MySqlTime';
function time(name, config) {
    return new MySqlTimeBuilder(name, config);
}

var _a$f, _b$b;
class MySqlDateColumnBaseBuilder extends MySqlColumnBuilder {
    defaultNow() {
        return this.default(index.sql `(now())`);
    }
    // "on update now" also adds an implicit default value to the column - https://dev.mysql.com/doc/refman/8.0/en/timestamp-initialization.html
    onUpdateNow() {
        this.config.hasOnUpdateNow = true;
        this.config.hasDefault = true;
        return this;
    }
}
_a$f = index.entityKind;
MySqlDateColumnBaseBuilder[_a$f] = 'MySqlDateColumnBuilder';
class MySqlDateBaseColumn extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.hasOnUpdateNow = this.config.hasOnUpdateNow;
    }
}
_b$b = index.entityKind;
MySqlDateBaseColumn[_b$b] = 'MySqlDateColumn';

var _a$e, _b$a, _c$3, _d$1;
class MySqlTimestampBuilder extends MySqlDateColumnBaseBuilder {
    constructor(name, config) {
        super(name, 'date', 'MySqlTimestamp');
        this.config.fsp = config?.fsp;
    }
    /** @internal */
    build(table) {
        return new MySqlTimestamp(table, this.config);
    }
}
_a$e = index.entityKind;
MySqlTimestampBuilder[_a$e] = 'MySqlTimestampBuilder';
class MySqlTimestamp extends MySqlDateBaseColumn {
    constructor() {
        super(...arguments);
        this.fsp = this.config.fsp;
    }
    getSQLType() {
        const precision = this.fsp === undefined ? '' : `(${this.fsp})`;
        return `timestamp${precision}`;
    }
    mapFromDriverValue(value) {
        return new Date(value + '+0000');
    }
    mapToDriverValue(value) {
        return value.toISOString().slice(0, -1).replace('T', ' ');
    }
}
_b$a = index.entityKind;
MySqlTimestamp[_b$a] = 'MySqlTimestamp';
class MySqlTimestampStringBuilder extends MySqlDateColumnBaseBuilder {
    constructor(name, config) {
        super(name, 'string', 'MySqlTimestampString');
        this.config.fsp = config?.fsp;
    }
    /** @internal */
    build(table) {
        return new MySqlTimestampString(table, this.config);
    }
}
_c$3 = index.entityKind;
MySqlTimestampStringBuilder[_c$3] = 'MySqlTimestampStringBuilder';
class MySqlTimestampString extends MySqlDateBaseColumn {
    constructor() {
        super(...arguments);
        this.fsp = this.config.fsp;
    }
    getSQLType() {
        const precision = this.fsp === undefined ? '' : `(${this.fsp})`;
        return `timestamp${precision}`;
    }
}
_d$1 = index.entityKind;
MySqlTimestampString[_d$1] = 'MySqlTimestampString';
function timestamp(name, config = {}) {
    if (config.mode === 'string') {
        return new MySqlTimestampStringBuilder(name, config);
    }
    return new MySqlTimestampBuilder(name, config);
}

var _a$d, _b$9;
class MySqlTinyIntBuilder extends MySqlColumnBuilderWithAutoIncrement {
    constructor(name) {
        super(name, 'number', 'MySqlTinyInt');
    }
    /** @internal */
    build(table) {
        return new MySqlTinyInt(table, this.config);
    }
}
_a$d = index.entityKind;
MySqlTinyIntBuilder[_a$d] = 'MySqlTinyIntBuilder';
class MySqlTinyInt extends MySqlColumnWithAutoIncrement {
    getSQLType() {
        return 'tinyint';
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            return Number(value);
        }
        return value;
    }
}
_b$9 = index.entityKind;
MySqlTinyInt[_b$9] = 'MySqlTinyInt';
function tinyint(name) {
    return new MySqlTinyIntBuilder(name);
}

var _a$c, _b$8;
class MySqlVarBinaryBuilder extends MySqlColumnBuilder {
    /** @internal */
    constructor(name, config) {
        super(name, 'string', 'MySqlVarBinary');
        this.config.length = config?.length;
    }
    /** @internal */
    build(table) {
        return new MySqlVarBinary(table, this.config);
    }
}
_a$c = index.entityKind;
MySqlVarBinaryBuilder[_a$c] = 'MySqlVarBinaryBuilder';
class MySqlVarBinary extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
    }
    getSQLType() {
        return this.length === undefined ? `varbinary` : `varbinary(${this.length})`;
    }
}
_b$8 = index.entityKind;
MySqlVarBinary[_b$8] = 'MySqlVarBinary';
function varbinary(name, options) {
    return new MySqlVarBinaryBuilder(name, options);
}

var _a$b, _b$7;
class MySqlVarCharBuilder extends MySqlColumnBuilder {
    /** @internal */
    constructor(name, config) {
        super(name, 'string', 'MySqlVarChar');
        this.config.length = config.length;
        this.config.enum = config.enum;
    }
    /** @internal */
    build(table) {
        return new MySqlVarChar(table, this.config);
    }
}
_a$b = index.entityKind;
MySqlVarCharBuilder[_a$b] = 'MySqlVarCharBuilder';
class MySqlVarChar extends MySqlColumn {
    constructor() {
        super(...arguments);
        this.length = this.config.length;
        this.enumValues = this.config.enum;
    }
    getSQLType() {
        return this.length === undefined ? `varchar` : `varchar(${this.length})`;
    }
}
_b$7 = index.entityKind;
MySqlVarChar[_b$7] = 'MySqlVarChar';
function varchar(name, config) {
    return new MySqlVarCharBuilder(name, config);
}

var _a$a, _b$6;
class MySqlYearBuilder extends MySqlColumnBuilder {
    constructor(name) {
        super(name, 'number', 'MySqlYear');
    }
    /** @internal */
    build(table) {
        return new MySqlYear(table, this.config);
    }
}
_a$a = index.entityKind;
MySqlYearBuilder[_a$a] = 'MySqlYearBuilder';
class MySqlYear extends MySqlColumn {
    getSQLType() {
        return `year`;
    }
}
_b$6 = index.entityKind;
MySqlYear[_b$6] = 'MySqlYear';
function year(name) {
    return new MySqlYearBuilder(name);
}

var _a$9;
class MySqlDelete extends index.QueryPromise {
    constructor(table, session, dialect) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return this.prepare().execute(placeholderValues);
        };
        this.createIterator = () => {
            const self = this;
            return async function* (placeholderValues) {
                yield* self.prepare().iterator(placeholderValues);
            };
        };
        this.iterator = this.createIterator();
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
}
_a$9 = index.entityKind;
MySqlDelete[_a$9] = 'MySqlDelete';

var _a$8, _b$5;
class MySqlInsertBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.shouldIgnore = false;
    }
    ignore() {
        this.shouldIgnore = true;
        return this;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[index.Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = index.is(colValue, index.SQL) ? colValue : new index.Param(colValue, cols[colKey]);
            }
            return result;
        });
        return new MySqlInsert(this.table, mappedValues, this.shouldIgnore, this.session, this.dialect);
    }
}
_a$8 = index.entityKind;
MySqlInsertBuilder[_a$8] = 'MySqlInsertBuilder';
class MySqlInsert extends index.QueryPromise {
    constructor(table, values, ignore, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return this.prepare().execute(placeholderValues);
        };
        this.createIterator = () => {
            const self = this;
            return async function* (placeholderValues) {
                yield* self.prepare().iterator(placeholderValues);
            };
        };
        this.iterator = this.createIterator();
        this.config = { table, values, ignore };
    }
    onDuplicateKeyUpdate(config) {
        const setSql = this.dialect.buildUpdateSet(this.config.table, index.mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = index.sql `update ${setSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined);
    }
}
_b$5 = index.entityKind;
MySqlInsert[_b$5] = 'MySqlInsert';

var _a$7;
// TODO find out how to use all/values. Seems like I need those functions
// Build project
// copy runtime tests to be sure it's working
// Add mysql to drizzle-kit
// Add Planetscale Driver and create example repo
class MySqlDialect {
    async migrate(migrations, session, config) {
        const migrationsTable = config.migrationsTable ?? '__drizzle_migrations';
        const migrationTableCreate = index.sql `
			create table if not exists ${index.sql.identifier(migrationsTable)} (
				id serial primary key,
				hash text not null,
				created_at bigint
			)
		`;
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(index.sql `select id, hash, created_at from ${index.sql.identifier(migrationsTable)} order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
            for (const migration of migrations) {
                if (!lastDbMigration
                    || Number(lastDbMigration.created_at) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.execute(index.sql.raw(stmt));
                    }
                    await tx.execute(index.sql `insert into ${index.sql.identifier(migrationsTable)} (\`hash\`, \`created_at\`) values(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
    escapeName(name) {
        return `\`${name}\``;
    }
    escapeParam(_num) {
        return `?`;
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? index.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? index.sql ` where ${where}` : undefined;
        return index.sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return index.sql.join(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[index.Table.Symbol.Columns][colName];
            const res = index.sql `${index.sql.identifier(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, index.sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? index.sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? index.sql ` where ${where}` : undefined;
        return index.sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (index.is(field, index.SQL.Aliased) && field.isSelectionField) {
                chunk.push(index.sql.identifier(field.fieldAlias));
            }
            else if (index.is(field, index.SQL.Aliased) || index.is(field, index.SQL)) {
                const query = index.is(field, index.SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new index.SQL(query.queryChunks.map((c) => {
                        if (index.is(c, MySqlColumn)) {
                            return index.sql.identifier(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (index.is(field, index.SQL.Aliased)) {
                    chunk.push(index.sql ` as ${index.sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (index.is(field, index.Column)) {
                if (isSingleTable) {
                    chunk.push(index.sql.identifier(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(index.sql `, `);
            }
            return chunk;
        });
        return index.sql.join(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClause, distinct, }) {
        const fieldsList = fieldsFlat ?? index.orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (index.is(f.field, index.Column)
                && index.getTableName(f.field.table)
                    !== (index.is(table, index.Subquery)
                        ? table[index.SubqueryConfig].alias
                        : index.is(table, MySqlViewBase)
                            ? table[index.ViewBaseConfig].name
                            : index.is(table, index.SQL)
                                ? undefined
                                : index.getTableName(table))
                && !((table) => joins?.some(({ alias }) => alias === (table[index.Table.Symbol.IsAlias] ? index.getTableName(table) : table[index.Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = index.getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [index.sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(index.sql `${index.sql.identifier(w[index.SubqueryConfig].alias)} as (${w[index.SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(index.sql `, `);
                }
            }
            withSqlChunks.push(index.sql ` `);
            withSql = index.sql.join(withSqlChunks);
        }
        const distinctSql = distinct ? index.sql ` distinct` : undefined;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (index.is(table, index.Table) && table[index.Table.Symbol.OriginalName] !== table[index.Table.Symbol.Name]) {
                return index.sql `${index.sql.identifier(table[index.Table.Symbol.OriginalName])} ${index.sql.identifier(table[index.Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        if (joins) {
            for (const [index$1, joinMeta] of joins.entries()) {
                if (index$1 === 0) {
                    joinsArray.push(index.sql ` `);
                }
                const table = joinMeta.table;
                const lateralSql = joinMeta.lateral ? index.sql ` lateral` : undefined;
                if (index.is(table, MySqlTable)) {
                    const tableName = table[MySqlTable.Symbol.Name];
                    const tableSchema = table[MySqlTable.Symbol.Schema];
                    const origTableName = table[MySqlTable.Symbol.OriginalName];
                    const alias = tableName === origTableName ? undefined : joinMeta.alias;
                    joinsArray.push(index.sql `${index.sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? index.sql `${index.sql.identifier(tableSchema)}.` : undefined}${index.sql.identifier(origTableName)}${alias && index.sql ` ${index.sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else if (index.is(table, index.View)) {
                    const viewName = table[index.ViewBaseConfig].name;
                    const viewSchema = table[index.ViewBaseConfig].schema;
                    const origViewName = table[index.ViewBaseConfig].originalName;
                    const alias = viewName === origViewName ? undefined : joinMeta.alias;
                    joinsArray.push(index.sql `${index.sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? index.sql `${index.sql.identifier(viewSchema)}.` : undefined}${index.sql.identifier(origViewName)}${alias && index.sql ` ${index.sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else {
                    joinsArray.push(index.sql `${index.sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`);
                }
                if (index$1 < joins.length - 1) {
                    joinsArray.push(index.sql ` `);
                }
            }
        }
        const joinsSql = index.sql.join(joinsArray);
        const whereSql = where ? index.sql ` where ${where}` : undefined;
        const havingSql = having ? index.sql ` having ${having}` : undefined;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
            orderBySql = index.sql ` order by ${index.sql.join(orderBy, index.sql `, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
            groupBySql = index.sql ` group by ${index.sql.join(groupBy, index.sql `, `)}`;
        }
        const limitSql = limit ? index.sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? index.sql ` offset ${offset}` : undefined;
        let lockingClausesSql;
        if (lockingClause) {
            const { config, strength } = lockingClause;
            lockingClausesSql = index.sql ` for ${index.sql.raw(strength)}`;
            if (config.noWait) {
                lockingClausesSql.append(index.sql ` no wait`);
            }
            else if (config.skipLocked) {
                lockingClausesSql.append(index.sql ` skip locked`);
            }
        }
        return index.sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
    }
    buildInsertQuery({ table, values, ignore, onConflict }) {
        // const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[index.Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => index.sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (index.is(colValue, index.Param) && colValue.value === undefined)) {
                    // eslint-disable-next-line unicorn/no-negated-condition
                    if (col.defaultFn !== undefined) {
                        const defaultFnResult = col.defaultFn();
                        const defaultValue = index.is(defaultFnResult, index.SQL) ? defaultFnResult : index.sql.param(defaultFnResult, col);
                        valueList.push(defaultValue);
                    }
                    else {
                        valueList.push(index.sql `default`);
                    }
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(index.sql `, `);
            }
        }
        const valuesSql = index.sql.join(valuesSqlList);
        const ignoreSql = ignore ? index.sql ` ignore` : undefined;
        const onConflictSql = onConflict ? index.sql ` on duplicate key ${onConflict}` : undefined;
        return index.sql `insert${ignoreSql} into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
        });
    }
    buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy, where;
        const joins = [];
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: index.aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, index.aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, index.getOperators())
                    : config.where;
                where = whereSql && index.mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql: index.sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: index.mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: index.is(value, index.SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: index.is(value, index.Column) ? index.aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, index.getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (index.is(orderByValue, index.Column)) {
                    return index.aliasedTableColumn(orderByValue, tableAlias);
                }
                return index.mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = index.normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[index.Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                const joinOn = index.and(...normalizedRelation.fields.map((field, i) => index.eq(index.aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), index.aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQuery({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: index.is(relation, index.One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                const field = index.sql `${index.sql.identifier(relationTableAlias)}.${index.sql.identifier('data')}`.as(selectedRelationTsKey);
                joins.push({
                    on: index.sql `true`,
                    table: new index.Subquery(builtRelation.sql, {}, relationTableAlias),
                    alias: relationTableAlias,
                    joinType: 'left',
                    lateral: true,
                });
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new index.DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
        }
        let result;
        where = index.and(joinOn, where);
        if (nestedQueryRelation) {
            let field = index.sql `json_array(${index.sql.join(selection.map(({ field, tsKey, isJson }) => isJson
                ? index.sql `${index.sql.identifier(`${tableAlias}_${tsKey}`)}.${index.sql.identifier('data')}`
                : index.is(field, index.SQL.Aliased)
                    ? field.sql
                    : field), index.sql `, `)})`;
            if (index.is(nestedQueryRelation, index.Many)) {
                field = index.sql `coalesce(json_arrayagg(${field}), json_array())`;
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field: field.as('data'),
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || (orderBy?.length ?? 0) > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: index.aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [
                        {
                            path: [],
                            field: index.sql.raw('*'),
                        },
                        ...(((orderBy?.length ?? 0) > 0)
                            ? [{
                                    path: [],
                                    field: index.sql `row_number() over (order by ${index.sql.join(orderBy, index.sql `, `)})`,
                                }]
                            : []),
                    ],
                    where,
                    limit,
                    offset,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = undefined;
            }
            else {
                result = index.aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: index.is(result, MySqlTable) ? result : new index.Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: index.is(field, index.Column) ? index.aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: index.aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: index.is(field, index.Column) ? index.aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
    buildRelationalQueryWithoutLateralSubqueries({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: index.aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, index.aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, index.getOperators())
                    : config.where;
                where = whereSql && index.mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql: index.sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: index.mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: index.is(value, index.SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: index.is(value, index.Column) ? index.aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, index.getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (index.is(orderByValue, index.Column)) {
                    return index.aliasedTableColumn(orderByValue, tableAlias);
                }
                return index.mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = index.normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[index.Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                const joinOn = index.and(...normalizedRelation.fields.map((field, i) => index.eq(index.aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), index.aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQueryWithoutLateralSubqueries({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: index.is(relation, index.One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                let fieldSql = index.sql `(${builtRelation.sql})`;
                if (index.is(relation, index.Many)) {
                    fieldSql = index.sql `coalesce(${fieldSql}, json_array())`;
                }
                const field = fieldSql.as(selectedRelationTsKey);
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new index.DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
        }
        let result;
        where = index.and(joinOn, where);
        if (nestedQueryRelation) {
            let field = index.sql `json_array(${index.sql.join(selection.map(({ field }) => index.is(field, MySqlColumn) ? index.sql.identifier(field.name) : index.is(field, index.SQL.Aliased) ? field.sql : field), index.sql `, `)})`;
            if (index.is(nestedQueryRelation, index.Many)) {
                field = index.sql `json_arrayagg(${field})`;
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field,
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: index.aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [
                        {
                            path: [],
                            field: index.sql.raw('*'),
                        },
                        ...(orderBy.length > 0)
                            ? [{
                                    path: [],
                                    field: index.sql `row_number() over (order by ${index.sql.join(orderBy, index.sql `, `)})`,
                                }]
                            : [],
                    ],
                    where,
                    limit,
                    offset,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = undefined;
            }
            else {
                result = index.aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: index.is(result, MySqlTable) ? result : new index.Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: index.is(field, index.Column) ? index.aliasedTableColumn(field, tableAlias) : field,
                })),
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: index.aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: index.is(field, index.Column) ? index.aliasedTableColumn(field, tableAlias) : field,
                })),
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
}
_a$7 = index.entityKind;
MySqlDialect[_a$7] = 'MySqlDialect';

var _a$6, _b$4, _c$2;
class MySqlSelectBuilder {
    constructor(config) {
        this.withList = [];
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
            this.withList = config.withList;
        }
        this.distinct = config.distinct;
    }
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (index.is(source, index.Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[index.SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (index.is(source, MySqlViewBase)) {
            fields = source[index.ViewBaseConfig].selectedFields;
        }
        else if (index.is(source, index.SQL)) {
            fields = {};
        }
        else {
            fields = index.getTableColumns(source);
        }
        return new MySqlSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
_a$6 = index.entityKind;
MySqlSelectBuilder[_a$6] = 'MySqlSelectBuilder';
class MySqlSelectQueryBuilder extends index.TypedQueryBuilder {
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.leftJoin = this.createJoin('left');
        this.rightJoin = this.createJoin('right');
        this.innerJoin = this.createJoin('inner');
        this.fullJoin = this.createJoin('full');
        this.config = {
            withList,
            table,
            fields: { ...fields },
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = index.getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = index.getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !index.is(table, index.SQL)) {
                    const selection = index.is(table, index.Subquery)
                        ? table[index.SubqueryConfig].selection
                        : index.is(table, index.View)
                            ? table[index.ViewBaseConfig].selectedFields
                            : table[index.Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new index.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            if (!this.config.joins) {
                this.config.joins = [];
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new index.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new index.SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new index.SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new index.SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    for(strength, config = {}) {
        this.config.lockingClause = { strength, config };
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new index.Subquery(this.getSQL(), this.config.fields, alias), new index.SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
_b$4 = index.entityKind;
MySqlSelectQueryBuilder[_b$4] = 'MySqlSelectQueryBuilder';
class MySqlSelect extends MySqlSelectQueryBuilder {
    constructor() {
        super(...arguments);
        this.execute = ((placeholderValues) => {
            return this.prepare().execute(placeholderValues);
        });
        this.createIterator = () => {
            const self = this;
            return async function* (placeholderValues) {
                yield* self.prepare().iterator(placeholderValues);
            };
        };
        this.iterator = this.createIterator();
    }
    prepare() {
        if (!this.session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        const fieldsList = index.orderSelectedFields(this.config.fields);
        const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), fieldsList);
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
    }
}
_c$2 = index.entityKind;
MySqlSelect[_c$2] = 'MySqlSelect';
index.applyMixins(MySqlSelect, [index.QueryPromise]);

var _a$5;
class QueryBuilder {
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new index.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new index.SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
    }
    selectDistinct(fields) {
        return new MySqlSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new MySqlDialect();
        }
        return this.dialect;
    }
}
_a$5 = index.entityKind;
QueryBuilder[_a$5] = 'MySqlQueryBuilder';

var _a$4, _b$3;
class RelationalQueryBuilder {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, mode) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.mode = mode;
    }
    findMany(config) {
        return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many', this.mode);
    }
    findFirst(config) {
        return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first', this.mode);
    }
}
_a$4 = index.entityKind;
RelationalQueryBuilder[_a$4] = 'MySqlRelationalQueryBuilder';
class MySqlRelationalQuery extends index.QueryPromise {
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, queryMode, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.queryMode = queryMode;
        this.mode = mode;
    }
    prepare() {
        const { query, builtQuery } = this._toSQL();
        return this.session.prepareQuery(builtQuery, undefined, (rawRows) => {
            const rows = rawRows.map((row) => index.mapRelationalRow(this.schema, this.tableConfig, row, query.selection));
            if (this.queryMode === 'first') {
                return rows[0];
            }
            return rows;
        });
    }
    _toSQL() {
        const query = this.mode === 'planetscale'
            ? this.dialect.buildRelationalQueryWithoutLateralSubqueries({
                fullSchema: this.fullSchema,
                schema: this.schema,
                tableNamesMap: this.tableNamesMap,
                table: this.table,
                tableConfig: this.tableConfig,
                queryConfig: this.config,
                tableAlias: this.tableConfig.tsName,
            })
            : this.dialect.buildRelationalQuery({
                fullSchema: this.fullSchema,
                schema: this.schema,
                tableNamesMap: this.tableNamesMap,
                table: this.table,
                tableConfig: this.tableConfig,
                queryConfig: this.config,
                tableAlias: this.tableConfig.tsName,
            });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return { builtQuery, query };
    }
    toSQL() {
        return this._toSQL().builtQuery;
    }
    execute() {
        return this.prepare().execute();
    }
}
_b$3 = index.entityKind;
MySqlRelationalQuery[_b$3] = 'MySqlRelationalQuery';

var _a$3;
class MySqlDatabase {
    constructor(
    /** @internal */
    dialect, 
    /** @internal */
    session, schema, mode) {
        this.dialect = dialect;
        this.session = session;
        this.mode = mode;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] =
                    new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session, this.mode);
            }
        }
    }
    $with(alias) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new index.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new index.SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
    }
    selectDistinct(fields) {
        return new MySqlSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    update(table) {
        return new MySqlUpdateBuilder(table, this.session, this.dialect);
    }
    insert(table) {
        return new MySqlInsertBuilder(table, this.session, this.dialect);
    }
    delete(table) {
        return new MySqlDelete(table, this.session, this.dialect);
    }
    execute(query) {
        return this.session.execute(query.getSQL());
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}
_a$3 = index.entityKind;
MySqlDatabase[_a$3] = 'MySqlDatabase';

var _a$2, _b$2, _c$1;
class PreparedQuery {
}
_a$2 = index.entityKind;
PreparedQuery[_a$2] = 'MySqlPreparedQuery';
class MySqlSession {
    constructor(dialect) {
        this.dialect = dialect;
    }
    execute(query) {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined).execute();
    }
    getSetTransactionSQL(config) {
        const parts = [];
        if (config.isolationLevel) {
            parts.push(`isolation level ${config.isolationLevel}`);
        }
        return parts.length ? index.sql.join(['set transaction ', parts.join(' ')]) : undefined;
    }
    getStartTransactionSQL(config) {
        const parts = [];
        if (config.withConsistentSnapshot) {
            parts.push('with consistent snapshot');
        }
        if (config.accessMode) {
            parts.push(config.accessMode);
        }
        return parts.length ? index.sql.join(['start transaction ', parts.join(' ')]) : undefined;
    }
}
_b$2 = index.entityKind;
MySqlSession[_b$2] = 'MySqlSession';
class MySqlTransaction extends MySqlDatabase {
    constructor(dialect, session, schema, nestedIndex, mode) {
        super(dialect, session, schema, mode);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new index.TransactionRollbackError();
    }
}
_c$1 = index.entityKind;
MySqlTransaction[_c$1] = 'MySqlTransaction';

var _a$1, _b$1;
class MySqlUpdateBuilder {
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new MySqlUpdate(this.table, index.mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
_a$1 = index.entityKind;
MySqlUpdateBuilder[_a$1] = 'MySqlUpdateBuilder';
class MySqlUpdate extends index.QueryPromise {
    constructor(table, set, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.execute = (placeholderValues) => {
            return this.prepare().execute(placeholderValues);
        };
        this.createIterator = () => {
            const self = this;
            return async function* (placeholderValues) {
                yield* self.prepare().iterator(placeholderValues);
            };
        };
        this.iterator = this.createIterator();
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
}
_b$1 = index.entityKind;
MySqlUpdate[_b$1] = 'MySqlUpdate';

var _a, _b, _c, _d, _e;
class ViewBuilderCore {
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
        this.config = {};
    }
    algorithm(algorithm) {
        this.config.algorithm = algorithm;
        return this;
    }
    definer(definer) {
        this.config.definer = definer;
        return this;
    }
    sqlSecurity(sqlSecurity) {
        this.config.sqlSecurity = sqlSecurity;
        return this;
    }
    withCheckOption(withCheckOption) {
        this.config.withCheckOption = withCheckOption ?? 'cascaded';
        return this;
    }
}
_a = index.entityKind;
ViewBuilderCore[_a] = 'MySqlViewBuilder';
class ViewBuilder extends ViewBuilderCore {
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new index.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new MySqlView({
            mysqlConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
_b = index.entityKind;
ViewBuilder[_b] = 'MySqlViewBuilder';
class ManualViewBuilder extends ViewBuilderCore {
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = index.getTableColumns(mysqlTable(name, columns));
    }
    existing() {
        return new Proxy(new MySqlView({
            mysqlConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new index.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new MySqlView({
            mysqlConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new index.SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
_c = index.entityKind;
ManualViewBuilder[_c] = 'MySqlManualViewBuilder';
class MySqlViewBase extends index.View {
}
_d = index.entityKind;
MySqlViewBase[_d] = 'MySqlViewBase';
const MySqlViewConfig = Symbol.for('drizzle:MySqlViewConfig');
class MySqlView extends MySqlViewBase {
    constructor({ mysqlConfig, config }) {
        super(config);
        this[MySqlViewConfig] = mysqlConfig;
    }
}
_e = index.entityKind;
MySqlView[_e] = 'MySqlView';
/** @internal */
function mysqlViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualViewBuilder(name, selection, schema);
    }
    return new ViewBuilder(name, schema);
}
function mysqlView(name, selection) {
    return mysqlViewWithSchema(name, selection, undefined);
}

exports.ForeignKey = ForeignKey;
exports.ForeignKeyBuilder = ForeignKeyBuilder;
exports.InlineForeignKeys = InlineForeignKeys;
exports.ManualViewBuilder = ManualViewBuilder;
exports.MySqlBigInt53 = MySqlBigInt53;
exports.MySqlBigInt53Builder = MySqlBigInt53Builder;
exports.MySqlBigInt64 = MySqlBigInt64;
exports.MySqlBigInt64Builder = MySqlBigInt64Builder;
exports.MySqlBinary = MySqlBinary;
exports.MySqlBinaryBuilder = MySqlBinaryBuilder;
exports.MySqlBoolean = MySqlBoolean;
exports.MySqlBooleanBuilder = MySqlBooleanBuilder;
exports.MySqlChar = MySqlChar;
exports.MySqlCharBuilder = MySqlCharBuilder;
exports.MySqlColumn = MySqlColumn;
exports.MySqlColumnBuilder = MySqlColumnBuilder;
exports.MySqlColumnBuilderWithAutoIncrement = MySqlColumnBuilderWithAutoIncrement;
exports.MySqlColumnWithAutoIncrement = MySqlColumnWithAutoIncrement;
exports.MySqlCustomColumn = MySqlCustomColumn;
exports.MySqlCustomColumnBuilder = MySqlCustomColumnBuilder;
exports.MySqlDatabase = MySqlDatabase;
exports.MySqlDate = MySqlDate;
exports.MySqlDateBuilder = MySqlDateBuilder;
exports.MySqlDateString = MySqlDateString;
exports.MySqlDateStringBuilder = MySqlDateStringBuilder;
exports.MySqlDateTime = MySqlDateTime;
exports.MySqlDateTimeBuilder = MySqlDateTimeBuilder;
exports.MySqlDateTimeString = MySqlDateTimeString;
exports.MySqlDateTimeStringBuilder = MySqlDateTimeStringBuilder;
exports.MySqlDecimal = MySqlDecimal;
exports.MySqlDecimalBuilder = MySqlDecimalBuilder;
exports.MySqlDelete = MySqlDelete;
exports.MySqlDialect = MySqlDialect;
exports.MySqlDouble = MySqlDouble;
exports.MySqlDoubleBuilder = MySqlDoubleBuilder;
exports.MySqlEnumColumn = MySqlEnumColumn;
exports.MySqlEnumColumnBuilder = MySqlEnumColumnBuilder;
exports.MySqlFloat = MySqlFloat;
exports.MySqlFloatBuilder = MySqlFloatBuilder;
exports.MySqlInsert = MySqlInsert;
exports.MySqlInsertBuilder = MySqlInsertBuilder;
exports.MySqlInt = MySqlInt;
exports.MySqlIntBuilder = MySqlIntBuilder;
exports.MySqlJson = MySqlJson;
exports.MySqlJsonBuilder = MySqlJsonBuilder;
exports.MySqlMediumInt = MySqlMediumInt;
exports.MySqlMediumIntBuilder = MySqlMediumIntBuilder;
exports.MySqlReal = MySqlReal;
exports.MySqlRealBuilder = MySqlRealBuilder;
exports.MySqlSelect = MySqlSelect;
exports.MySqlSelectBuilder = MySqlSelectBuilder;
exports.MySqlSelectQueryBuilder = MySqlSelectQueryBuilder;
exports.MySqlSerial = MySqlSerial;
exports.MySqlSerialBuilder = MySqlSerialBuilder;
exports.MySqlSession = MySqlSession;
exports.MySqlSmallInt = MySqlSmallInt;
exports.MySqlSmallIntBuilder = MySqlSmallIntBuilder;
exports.MySqlTable = MySqlTable;
exports.MySqlText = MySqlText;
exports.MySqlTextBuilder = MySqlTextBuilder;
exports.MySqlTime = MySqlTime;
exports.MySqlTimeBuilder = MySqlTimeBuilder;
exports.MySqlTimestamp = MySqlTimestamp;
exports.MySqlTimestampBuilder = MySqlTimestampBuilder;
exports.MySqlTimestampString = MySqlTimestampString;
exports.MySqlTimestampStringBuilder = MySqlTimestampStringBuilder;
exports.MySqlTinyInt = MySqlTinyInt;
exports.MySqlTinyIntBuilder = MySqlTinyIntBuilder;
exports.MySqlTransaction = MySqlTransaction;
exports.MySqlUpdate = MySqlUpdate;
exports.MySqlUpdateBuilder = MySqlUpdateBuilder;
exports.MySqlVarBinary = MySqlVarBinary;
exports.MySqlVarBinaryBuilder = MySqlVarBinaryBuilder;
exports.MySqlVarChar = MySqlVarChar;
exports.MySqlVarCharBuilder = MySqlVarCharBuilder;
exports.MySqlView = MySqlView;
exports.MySqlViewBase = MySqlViewBase;
exports.MySqlViewConfig = MySqlViewConfig;
exports.MySqlYear = MySqlYear;
exports.MySqlYearBuilder = MySqlYearBuilder;
exports.PreparedQuery = PreparedQuery;
exports.QueryBuilder = QueryBuilder;
exports.UniqueConstraint = UniqueConstraint;
exports.UniqueConstraintBuilder = UniqueConstraintBuilder;
exports.UniqueOnConstraintBuilder = UniqueOnConstraintBuilder;
exports.ViewBuilder = ViewBuilder;
exports.ViewBuilderCore = ViewBuilderCore;
exports.bigint = bigint;
exports.binary = binary;
exports.boolean = boolean;
exports.char = char;
exports.customType = customType;
exports.date = date;
exports.datetime = datetime;
exports.decimal = decimal;
exports.double = double;
exports.float = float;
exports.foreignKey = foreignKey;
exports.int = int;
exports.json = json;
exports.longtext = longtext;
exports.mediumint = mediumint;
exports.mediumtext = mediumtext;
exports.mysqlEnum = mysqlEnum;
exports.mysqlTable = mysqlTable;
exports.mysqlTableCreator = mysqlTableCreator;
exports.mysqlTableWithSchema = mysqlTableWithSchema;
exports.mysqlView = mysqlView;
exports.mysqlViewWithSchema = mysqlViewWithSchema;
exports.real = real;
exports.serial = serial;
exports.smallint = smallint;
exports.text = text;
exports.time = time;
exports.timestamp = timestamp;
exports.tinyint = tinyint;
exports.tinytext = tinytext;
exports.unique = unique;
exports.uniqueKeyName = uniqueKeyName;
exports.varbinary = varbinary;
exports.varchar = varchar;
exports.year = year;
//# sourceMappingURL=view-975e4aa4.cjs.map
