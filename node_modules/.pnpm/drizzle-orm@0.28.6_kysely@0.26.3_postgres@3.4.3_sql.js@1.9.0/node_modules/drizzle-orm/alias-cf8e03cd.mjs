const entityKind = Symbol.for('drizzle:entityKind');
const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');
function is(value, type) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof
        return true;
    }
    if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
        throw new Error(`Class "${type.name ?? '<unknown>'}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
    }
    let cls = value.constructor;
    if (cls) {
        // Traverse the prototype chain to find the entityKind
        while (cls) {
            if (entityKind in cls && cls[entityKind] === type[entityKind]) {
                return true;
            }
            cls = Object.getPrototypeOf(cls);
        }
    }
    return false;
}

/*
    `Column` only accepts a full `ColumnConfig` as its generic.
    To infer parts of the config, use `AnyColumn` that accepts a partial config.
    See `GetColumnData` for example usage of inferring.
*/
class Column {
    table;
    static [entityKind] = 'Column';
    name;
    primary;
    notNull;
    default;
    defaultFn;
    hasDefault;
    isUnique;
    uniqueName;
    uniqueType;
    dataType;
    columnType;
    enumValues = undefined;
    config;
    constructor(table, config) {
        this.table = table;
        this.config = config;
        this.name = config.name;
        this.notNull = config.notNull;
        this.default = config.default;
        this.defaultFn = config.defaultFn;
        this.hasDefault = config.hasDefault;
        this.primary = config.primaryKey;
        this.isUnique = config.isUnique;
        this.uniqueName = config.uniqueName;
        this.uniqueType = config.uniqueType;
        this.dataType = config.dataType;
        this.columnType = config.columnType;
    }
    mapFromDriverValue(value) {
        return value;
    }
    mapToDriverValue(value) {
        return value;
    }
}

const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');
class View {
    static [entityKind] = 'View';
    /** @internal */
    [ViewBaseConfig];
    constructor({ name, schema, selectedFields, query }) {
        this[ViewBaseConfig] = {
            name,
            originalName: name,
            schema,
            selectedFields,
            query: query,
            isExisting: !query,
            isAlias: false,
        };
    }
    getSQL() {
        return new SQL([this]);
    }
}

const SubqueryConfig = Symbol.for('drizzle:SubqueryConfig');
class Subquery {
    static [entityKind] = 'Subquery';
    /** @internal */
    [SubqueryConfig];
    constructor(sql, selection, alias, isWith = false) {
        this[SubqueryConfig] = {
            sql,
            selection,
            alias,
            isWith,
        };
    }
    getSQL() {
        return new SQL([this]);
    }
}
class WithSubquery extends Subquery {
    static [entityKind] = 'WithSubquery';
}
class SelectionProxyHandler {
    static [entityKind] = 'SelectionProxyHandler';
    config;
    constructor(config) {
        this.config = { ...config };
    }
    get(subquery, prop) {
        if (prop === SubqueryConfig) {
            return {
                ...subquery[SubqueryConfig],
                selection: new Proxy(subquery[SubqueryConfig].selection, this),
            };
        }
        if (prop === ViewBaseConfig) {
            return {
                ...subquery[ViewBaseConfig],
                selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this),
            };
        }
        if (typeof prop === 'symbol') {
            return subquery[prop];
        }
        const columns = is(subquery, Subquery)
            ? subquery[SubqueryConfig].selection
            : is(subquery, View)
                ? subquery[ViewBaseConfig].selectedFields
                : subquery;
        const value = columns[prop];
        if (is(value, SQL.Aliased)) {
            // Never return the underlying SQL expression for a field previously selected in a subquery
            if (this.config.sqlAliasedBehavior === 'sql' && !value.isSelectionField) {
                return value.sql;
            }
            const newValue = value.clone();
            newValue.isSelectionField = true;
            return newValue;
        }
        if (is(value, SQL)) {
            if (this.config.sqlBehavior === 'sql') {
                return value;
            }
            throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
        }
        if (is(value, Column)) {
            if (this.config.alias) {
                return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
            }
            return value;
        }
        if (typeof value !== 'object' || value === null) {
            return value;
        }
        return new Proxy(value, new SelectionProxyHandler(this.config));
    }
}

/** @internal */
function mapResultRow(columns, row, joinsNotNullableMap) {
    // Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise
    const nullifyMap = {};
    const result = columns.reduce((result, { path, field }, columnIndex) => {
        let decoder;
        if (is(field, Column)) {
            decoder = field;
        }
        else if (is(field, SQL)) {
            decoder = field.decoder;
        }
        else {
            decoder = field.sql.decoder;
        }
        let node = result;
        for (const [pathChunkIndex, pathChunk] of path.entries()) {
            if (pathChunkIndex < path.length - 1) {
                if (!(pathChunk in node)) {
                    node[pathChunk] = {};
                }
                node = node[pathChunk];
            }
            else {
                const rawValue = row[columnIndex];
                const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
                if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
                    const objectName = path[0];
                    if (!(objectName in nullifyMap)) {
                        nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
                    }
                    else if (typeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)) {
                        nullifyMap[objectName] = false;
                    }
                }
            }
        }
        return result;
    }, {});
    // Nullify all nested objects from nullifyMap that are nullable
    if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
        for (const [objectName, tableName] of Object.entries(nullifyMap)) {
            if (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {
                result[objectName] = null;
            }
        }
    }
    return result;
}
/** @internal */
function orderSelectedFields(fields, pathPrefix) {
    return Object.entries(fields).reduce((result, [name, field]) => {
        if (typeof name !== 'string') {
            return result;
        }
        const newPath = pathPrefix ? [...pathPrefix, name] : [name];
        if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
            result.push({ path: newPath, field });
        }
        else if (is(field, Table)) {
            result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
        }
        else {
            result.push(...orderSelectedFields(field, newPath));
        }
        return result;
    }, []);
}
/** @internal */
function mapUpdateSet(table, values) {
    const entries = Object.entries(values)
        .filter(([, value]) => value !== undefined)
        .map(([key, value]) => {
        // eslint-disable-next-line unicorn/prefer-ternary
        if (is(value, SQL)) {
            return [key, value];
        }
        else {
            return [key, new Param(value, table[Table.Symbol.Columns][key])];
        }
    });
    if (entries.length === 0) {
        throw new Error('No values to set');
    }
    return Object.fromEntries(entries);
}
/** @internal */
function applyMixins(baseClass, extendedClasses) {
    for (const extendedClass of extendedClasses) {
        for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
            Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null));
        }
    }
}
function getTableColumns(table) {
    return table[Table.Symbol.Columns];
}
/** @internal */
function getTableLikeName(table) {
    return is(table, Subquery)
        ? table[SubqueryConfig].alias
        : is(table, View)
            ? table[ViewBaseConfig].name
            : is(table, SQL)
                ? undefined
                : table[Table.Symbol.IsAlias]
                    ? table[Table.Symbol.Name]
                    : table[Table.Symbol.BaseName];
}
function iife(fn, ...args) {
    return fn(...args);
}

/** @internal */
const TableName = Symbol.for('drizzle:Name');
/** @internal */
const Schema = Symbol.for('drizzle:Schema');
/** @internal */
const Columns = Symbol.for('drizzle:Columns');
/** @internal */
const OriginalName = Symbol.for('drizzle:OriginalName');
/** @internal */
const BaseName = Symbol.for('drizzle:BaseName');
/** @internal */
const IsAlias = Symbol.for('drizzle:IsAlias');
/** @internal */
const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');
const IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');
class Table {
    static [entityKind] = 'Table';
    /** @internal */
    static Symbol = {
        Name: TableName,
        Schema: Schema,
        OriginalName: OriginalName,
        Columns: Columns,
        BaseName: BaseName,
        IsAlias: IsAlias,
        ExtraConfigBuilder: ExtraConfigBuilder,
    };
    /**
     * @internal
     * Can be changed if the table is aliased.
     */
    [TableName];
    /**
     * @internal
     * Used to store the original name of the table, before any aliasing.
     */
    [OriginalName];
    /** @internal */
    [Schema];
    /** @internal */
    [Columns];
    /**
     *  @internal
     * Used to store the table name before the transformation via the `tableCreator` functions.
     */
    [BaseName];
    /** @internal */
    [IsAlias] = false;
    /** @internal */
    [ExtraConfigBuilder] = undefined;
    [IsDrizzleTable] = true;
    constructor(name, schema, baseName) {
        this[TableName] = this[OriginalName] = name;
        this[Schema] = schema;
        this[BaseName] = baseName;
    }
    getSQL() {
        return new SQL([this]);
    }
}
function isTable(table) {
    return typeof table === 'object' && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
    return table[TableName];
}

class QueryPromise {
    static [entityKind] = 'QueryPromise';
    [Symbol.toStringTag] = 'QueryPromise';
    catch(onRejected) {
        return this.then(undefined, onRejected);
    }
    finally(onFinally) {
        return this.then((value) => {
            onFinally?.();
            return value;
        }, (reason) => {
            onFinally?.();
            throw reason;
        });
    }
    then(onFulfilled, onRejected) {
        return this.execute().then(onFulfilled, onRejected);
    }
}

/** @internal */
const tracer = {
    startActiveSpan(name, fn) {
        {
            return fn();
        }
    },
};

class DrizzleError extends Error {
    static [entityKind] = 'DrizzleError';
    constructor(message) {
        super(message);
        this.name = 'DrizzleError';
    }
    static wrap(error, message) {
        return error instanceof Error // eslint-disable-line no-instanceof/no-instanceof
            ? new DrizzleError(message ? `${message}: ${error.message}` : error.message)
            : new DrizzleError(message ?? String(error));
    }
}
class TransactionRollbackError extends DrizzleError {
    static [entityKind] = 'TransactionRollbackError';
    constructor() {
        super('Rollback');
    }
}

/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');
class PgTable extends Table {
    static [entityKind] = 'PgTable';
    /** @internal */
    static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys,
    });
    /**@internal */
    [InlineForeignKeys] = [];
    /** @internal */
    [Table.Symbol.ExtraConfigBuilder] = undefined;
}
/** @internal */
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new PgTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilderBase]) => {
        const colBuilder = colBuilderBase;
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const pgTable = (name, columns, extraConfig) => {
    return pgTableWithSchema(name, columns, extraConfig, undefined);
};
function pgTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return pgTableWithSchema(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

class CheckBuilder {
    name;
    value;
    static [entityKind] = 'PgCheckBuilder';
    brand;
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    /** @internal */
    build(table) {
        return new Check(table, this);
    }
}
class Check {
    table;
    static [entityKind] = 'PgCheck';
    name;
    value;
    constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
    }
}
function check(name, value) {
    return new CheckBuilder(name, value);
}

class ForeignKeyBuilder {
    static [entityKind] = 'PgForeignKeyBuilder';
    /** @internal */
    reference;
    /** @internal */
    _onUpdate = 'no action';
    /** @internal */
    _onDelete = 'no action';
    constructor(config, actions) {
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action === undefined ? 'no action' : action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action === undefined ? 'no action' : action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
class ForeignKey {
    table;
    static [entityKind] = 'PgForeignKey';
    reference;
    onUpdate;
    onDelete;
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[PgTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[PgTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config;
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

class IndexBuilderOn {
    unique;
    name;
    static [entityKind] = 'PgIndexBuilderOn';
    constructor(unique, name) {
        this.unique = unique;
        this.name = name;
    }
    on(...columns) {
        return new IndexBuilder(columns, this.unique, false, this.name);
    }
    onOnly(...columns) {
        return new IndexBuilder(columns, this.unique, true, this.name);
    }
}
class IndexBuilder {
    static [entityKind] = 'PgIndexBuilder';
    /** @internal */
    config;
    constructor(columns, unique, only, name) {
        this.config = {
            name,
            columns,
            unique,
            only,
        };
    }
    concurrently() {
        this.config.concurrently = true;
        return this;
    }
    using(method) {
        this.config.using = method;
        return this;
    }
    asc() {
        this.config.order = 'asc';
        return this;
    }
    desc() {
        this.config.order = 'desc';
        return this;
    }
    nullsFirst() {
        this.config.nulls = 'first';
        return this;
    }
    nullsLast() {
        this.config.nulls = 'last';
        return this;
    }
    where(condition) {
        this.config.where = condition;
        return this;
    }
    /** @internal */
    build(table) {
        return new Index(this.config, table);
    }
}
class Index {
    static [entityKind] = 'PgIndex';
    config;
    constructor(config, table) {
        this.config = { ...config, table };
    }
}
function index(name) {
    return new IndexBuilderOn(false, name);
}
function uniqueIndex(name) {
    return new IndexBuilderOn(true, name);
}

function primaryKey(...columns) {
    return new PrimaryKeyBuilder(columns);
}
class PrimaryKeyBuilder {
    static [entityKind] = 'PgPrimaryKeyBuilder';
    /** @internal */
    columns;
    constructor(columns) {
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new PrimaryKey(table, this.columns);
    }
}
class PrimaryKey {
    table;
    static [entityKind] = 'PgPrimaryKey';
    columns;
    constructor(table, columns) {
        this.table = table;
        this.columns = columns;
    }
    getName() {
        return `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;
    }
}

function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
    return `${table[PgTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
class UniqueConstraintBuilder {
    name;
    static [entityKind] = 'PgUniqueConstraintBuilder';
    /** @internal */
    columns;
    /** @internal */
    nullsNotDistinctConfig = false;
    constructor(columns, name) {
        this.name = name;
        this.columns = columns;
    }
    nullsNotDistinct() {
        this.nullsNotDistinctConfig = true;
        return this;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);
    }
}
class UniqueOnConstraintBuilder {
    static [entityKind] = 'PgUniqueOnConstraintBuilder';
    /** @internal */
    name;
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
class UniqueConstraint {
    table;
    static [entityKind] = 'PgUniqueConstraint';
    columns;
    name;
    nullsNotDistinct = false;
    constructor(table, columns, nullsNotDistinct, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
        this.nullsNotDistinct = nullsNotDistinct;
    }
    getName() {
        return this.name;
    }
}

function getTableConfig(table) {
    const columns = Object.values(table[Table.Symbol.Columns]);
    const indexes = [];
    const checks = [];
    const primaryKeys = [];
    const foreignKeys = Object.values(table[PgTable.Symbol.InlineForeignKeys]);
    const uniqueConstraints = [];
    const name = table[Table.Symbol.Name];
    const schema = table[Table.Symbol.Schema];
    const extraConfigBuilder = table[PgTable.Symbol.ExtraConfigBuilder];
    if (extraConfigBuilder !== undefined) {
        const extraConfig = extraConfigBuilder(table[Table.Symbol.Columns]);
        for (const builder of Object.values(extraConfig)) {
            if (is(builder, IndexBuilder)) {
                indexes.push(builder.build(table));
            }
            else if (is(builder, CheckBuilder)) {
                checks.push(builder.build(table));
            }
            else if (is(builder, UniqueConstraintBuilder)) {
                uniqueConstraints.push(builder.build(table));
            }
            else if (is(builder, PrimaryKeyBuilder)) {
                primaryKeys.push(builder.build(table));
            }
            else if (is(builder, ForeignKeyBuilder)) {
                foreignKeys.push(builder.build(table));
            }
        }
    }
    return {
        columns,
        indexes,
        foreignKeys,
        checks,
        primaryKeys,
        uniqueConstraints,
        name,
        schema,
    };
}
function getViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[PgViewConfig],
    };
}
function getMaterializedViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[PgMaterializedViewConfig],
    };
}
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
    for (let i = startFrom; i < arrayString.length; i++) {
        const char = arrayString[i];
        if (char === '\\') {
            i++;
            continue;
        }
        if (char === '"') {
            return [arrayString.slice(startFrom, i).replace(/\\/g, ''), i + 1];
        }
        if (inQuotes) {
            continue;
        }
        if (char === ',' || char === '}') {
            return [arrayString.slice(startFrom, i).replace(/\\/g, ''), i];
        }
    }
    return [arrayString.slice(startFrom).replace(/\\/g, ''), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
    const result = [];
    let i = startFrom;
    let lastCharIsComma = false;
    while (i < arrayString.length) {
        const char = arrayString[i];
        if (char === ',') {
            if (lastCharIsComma || i === startFrom) {
                result.push('');
            }
            lastCharIsComma = true;
            i++;
            continue;
        }
        lastCharIsComma = false;
        if (char === '\\') {
            i += 2;
            continue;
        }
        if (char === '"') {
            const [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);
            result.push(value);
            i = startFrom;
            continue;
        }
        if (char === '}') {
            return [result, i + 1];
        }
        if (char === '{') {
            const [value, startFrom] = parsePgNestedArray(arrayString, i + 1);
            result.push(value);
            i = startFrom;
            continue;
        }
        const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
        result.push(value);
        i = newStartFrom;
    }
    return [result, i];
}
function parsePgArray(arrayString) {
    const [result] = parsePgNestedArray(arrayString, 1);
    return result;
}
function makePgArray(array) {
    return `{${array.map((item) => {
        if (Array.isArray(item)) {
            return makePgArray(item);
        }
        if (typeof item === 'string' && item.includes(',')) {
            return `"${item.replace(/"/g, '\\"')}"`;
        }
        return `${item}`;
    }).join(',')}}`;
}

// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.
class ColumnBuilder {
    static [entityKind] = 'ColumnBuilder';
    config;
    constructor(name, dataType, columnType) {
        this.config = {
            name,
            notNull: false,
            default: undefined,
            hasDefault: false,
            primaryKey: false,
            isUnique: false,
            uniqueName: undefined,
            uniqueType: undefined,
            dataType,
            columnType,
        };
    }
    /**
     * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.
     *
     * @example
     * ```ts
     * const users = pgTable('users', {
     * 	id: integer('id').$type<UserId>().primaryKey(),
     * 	details: json('details').$type<UserDetails>().notNull(),
     * });
     * ```
     */
    $type() {
        return this;
    }
    /**
     * Adds a `not null` clause to the column definition.
     *
     * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.
     */
    notNull() {
        this.config.notNull = true;
        return this;
    }
    /**
     * Adds a `default <value>` clause to the column definition.
     *
     * Affects the `insert` model of the table - columns *with* `default` are optional on insert.
     *
     * If you need to set a dynamic default value, use {@link $defaultFn} instead.
     */
    default(value) {
        this.config.default = value;
        this.config.hasDefault = true;
        return this;
    }
    /**
     * Adds a dynamic default value to the column.
     * The function will be called when the row is inserted, and the returned value will be used as the column value.
     *
     * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.
     */
    $defaultFn(fn) {
        this.config.defaultFn = fn;
        this.config.hasDefault = true;
        return this;
    }
    /**
     * Alias for {@link $defaultFn}.
     */
    $default = this.$defaultFn;
    /**
     * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.
     *
     * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.
     */
    primaryKey() {
        this.config.primaryKey = true;
        this.config.notNull = true;
        return this;
    }
}

class PgColumnBuilder extends ColumnBuilder {
    foreignKeyConfigs = [];
    static [entityKind] = 'PgColumnBuilder';
    array(size) {
        return new PgArrayBuilder(this.config.name, this, size);
    }
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name, config) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        this.config.uniqueType = config?.nulls;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return iife((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            }, ref, actions);
        });
    }
}
// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.
class PgColumn extends Column {
    table;
    static [entityKind] = 'PgColumn';
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}

class PgArrayBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgArrayBuilder';
    constructor(name, baseBuilder, size) {
        super(name, 'array', 'PgArray');
        this.config.baseBuilder = baseBuilder;
        this.config.size = size;
    }
    /** @internal */
    build(table) {
        const baseColumn = this.config.baseBuilder.build(table);
        return new PgArray(table, this.config, baseColumn);
    }
}
class PgArray extends PgColumn {
    baseColumn;
    range;
    size;
    static [entityKind] = 'PgArray';
    constructor(table, config, baseColumn, range) {
        super(table, config);
        this.baseColumn = baseColumn;
        this.range = range;
        this.size = config.size;
    }
    getSQLType() {
        return `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            // Thank you node-postgres for not parsing enum arrays
            value = parsePgArray(value);
        }
        return value.map((v) => this.baseColumn.mapFromDriverValue(v));
    }
    mapToDriverValue(value, isNestedArray = false) {
        const a = value.map((v) => v === null
            ? null
            : is(this.baseColumn, PgArray)
                ? this.baseColumn.mapToDriverValue(v, true)
                : this.baseColumn.mapToDriverValue(v));
        if (isNestedArray)
            return a;
        return makePgArray(a);
    }
}

class PgDateColumnBaseBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgDateColumnBaseBuilder';
    defaultNow() {
        return this.default(sql `now()`);
    }
}

class PgDateBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = 'PgDateBuilder';
    constructor(name) {
        super(name, 'date', 'PgDate');
    }
    /** @internal */
    build(table) {
        return new PgDate(table, this.config);
    }
}
class PgDate extends PgColumn {
    static [entityKind] = 'PgDate';
    getSQLType() {
        return 'date';
    }
    mapFromDriverValue(value) {
        return new Date(value);
    }
    mapToDriverValue(value) {
        return value.toISOString();
    }
}
class PgDateStringBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = 'PgDateStringBuilder';
    constructor(name) {
        super(name, 'string', 'PgDateString');
    }
    /** @internal */
    build(table) {
        return new PgDateString(table, this.config);
    }
}
class PgDateString extends PgColumn {
    static [entityKind] = 'PgDateString';
    getSQLType() {
        return 'date';
    }
}
function date(name, config) {
    if (config?.mode === 'date') {
        return new PgDateBuilder(name);
    }
    return new PgDateStringBuilder(name);
}

class PgJsonBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgJsonBuilder';
    constructor(name) {
        super(name, 'json', 'PgJson');
    }
    /** @internal */
    build(table) {
        return new PgJson(table, this.config);
    }
}
class PgJson extends PgColumn {
    static [entityKind] = 'PgJson';
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'json';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return value;
    }
}
function json(name) {
    return new PgJsonBuilder(name);
}

class PgJsonbBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgJsonbBuilder';
    constructor(name) {
        super(name, 'json', 'PgJsonb');
    }
    /** @internal */
    build(table) {
        return new PgJsonb(table, this.config);
    }
}
class PgJsonb extends PgColumn {
    static [entityKind] = 'PgJsonb';
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return 'jsonb';
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
    mapFromDriverValue(value) {
        if (typeof value === 'string') {
            try {
                return JSON.parse(value);
            }
            catch {
                return value;
            }
        }
        return value;
    }
}
function jsonb(name) {
    return new PgJsonbBuilder(name);
}

class PgNumericBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgNumericBuilder';
    constructor(name, precision, scale) {
        super(name, 'string', 'PgNumeric');
        this.config.precision = precision;
        this.config.scale = scale;
    }
    /** @internal */
    build(table) {
        return new PgNumeric(table, this.config);
    }
}
class PgNumeric extends PgColumn {
    static [entityKind] = 'PgNumeric';
    precision;
    scale;
    constructor(table, config) {
        super(table, config);
        this.precision = config.precision;
        this.scale = config.scale;
    }
    getSQLType() {
        if (this.precision !== undefined && this.scale !== undefined) {
            return `numeric(${this.precision}, ${this.scale})`;
        }
        else if (this.precision === undefined) {
            return 'numeric';
        }
        else {
            return `numeric(${this.precision})`;
        }
    }
}
function numeric(name, config) {
    return new PgNumericBuilder(name, config?.precision, config?.scale);
}
const decimal = numeric;

class PgTimeBuilder extends PgDateColumnBaseBuilder {
    withTimezone;
    precision;
    static [entityKind] = 'PgTimeBuilder';
    constructor(name, withTimezone, precision) {
        super(name, 'string', 'PgTime');
        this.withTimezone = withTimezone;
        this.precision = precision;
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTime(table, this.config);
    }
}
class PgTime extends PgColumn {
    static [entityKind] = 'PgTime';
    withTimezone;
    precision;
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : `(${this.precision})`;
        return `time${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
function time(name, config = {}) {
    return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

class PgTimestampBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = 'PgTimestampBuilder';
    constructor(name, withTimezone, precision) {
        super(name, 'date', 'PgTimestamp');
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTimestamp(table, this.config);
    }
}
class PgTimestamp extends PgColumn {
    static [entityKind] = 'PgTimestamp';
    withTimezone;
    precision;
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : ` (${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
    mapFromDriverValue = (value) => {
        return new Date(this.withTimezone ? value : value + '+0000');
    };
    mapToDriverValue = (value) => {
        return this.withTimezone ? value.toUTCString() : value.toISOString();
    };
}
class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
    static [entityKind] = 'PgTimestampStringBuilder';
    constructor(name, withTimezone, precision) {
        super(name, 'string', 'PgTimestampString');
        this.config.withTimezone = withTimezone;
        this.config.precision = precision;
    }
    /** @internal */
    build(table) {
        return new PgTimestampString(table, this.config);
    }
}
class PgTimestampString extends PgColumn {
    static [entityKind] = 'PgTimestampString';
    withTimezone;
    precision;
    constructor(table, config) {
        super(table, config);
        this.withTimezone = config.withTimezone;
        this.precision = config.precision;
    }
    getSQLType() {
        const precision = this.precision === undefined ? '' : `(${this.precision})`;
        return `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;
    }
}
function timestamp(name, config = {}) {
    if (config.mode === 'string') {
        return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
    }
    return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
}

class PgUUIDBuilder extends PgColumnBuilder {
    static [entityKind] = 'PgUUIDBuilder';
    constructor(name) {
        super(name, 'string', 'PgUUID');
    }
    /**
     * Adds `default gen_random_uuid()` to the column definition.
     */
    defaultRandom() {
        return this.default(sql `gen_random_uuid()`);
    }
    /** @internal */
    build(table) {
        return new PgUUID(table, this.config);
    }
}
class PgUUID extends PgColumn {
    static [entityKind] = 'PgUUID';
    getSQLType() {
        return 'uuid';
    }
}
function uuid(name) {
    return new PgUUIDBuilder(name);
}

class PgDialect {
    static [entityKind] = 'PgDialect';
    async migrate(migrations, session) {
        const migrationTableCreate = sql `
			CREATE TABLE IF NOT EXISTS "drizzle"."__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
        await session.execute(sql `CREATE SCHEMA IF NOT EXISTS "drizzle"`);
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(sql `select id, hash, created_at from "drizzle"."__drizzle_migrations" order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
            for await (const migration of migrations) {
                if (!lastDbMigration
                    || Number(lastDbMigration.created_at) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.execute(sql.raw(stmt));
                    }
                    await tx.execute(sql `insert into "drizzle"."__drizzle_migrations" ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
    escapeName(name) {
        return `"${name}"`;
    }
    escapeParam(num) {
        return `$${num + 1}`;
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql.join(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[Table.Symbol.Columns][colName];
            const res = sql `${sql.identifier(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (is(field, SQL.Aliased) && field.isSelectionField) {
                chunk.push(sql.identifier(field.fieldAlias));
            }
            else if (is(field, SQL.Aliased) || is(field, SQL)) {
                const query = is(field, SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new SQL(query.queryChunks.map((c) => {
                        if (is(c, PgColumn)) {
                            return sql.identifier(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (is(field, SQL.Aliased)) {
                    chunk.push(sql ` as ${sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (is(field, Column)) {
                if (isSingleTable) {
                    chunk.push(sql.identifier(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(sql `, `);
            }
            return chunk;
        });
        return sql.join(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClauses, distinct, }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (is(f.field, Column)
                && getTableName(f.field.table)
                    !== (is(table, Subquery)
                        ? table[SubqueryConfig].alias
                        : is(table, PgViewBase)
                            ? table[ViewBaseConfig].name
                            : is(table, SQL)
                                ? undefined
                                : getTableName(table))
                && !((table) => joins?.some(({ alias }) => alias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(sql `${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(sql `, `);
                }
            }
            withSqlChunks.push(sql ` `);
            withSql = sql.join(withSqlChunks);
        }
        let distinctSql;
        if (distinct) {
            distinctSql = distinct === true ? sql ` distinct` : sql ` distinct on (${sql.join(distinct.on, ', ')})`;
        }
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
                let fullName = sql `${sql.identifier(table[Table.Symbol.OriginalName])}`;
                if (table[Table.Symbol.Schema]) {
                    fullName = sql `${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
                }
                return sql `${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        if (joins) {
            for (const [index, joinMeta] of joins.entries()) {
                if (index === 0) {
                    joinsArray.push(sql ` `);
                }
                const table = joinMeta.table;
                const lateralSql = joinMeta.lateral ? sql ` lateral` : undefined;
                if (is(table, PgTable)) {
                    const tableName = table[PgTable.Symbol.Name];
                    const tableSchema = table[PgTable.Symbol.Schema];
                    const origTableName = table[PgTable.Symbol.OriginalName];
                    const alias = tableName === origTableName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql `${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else if (is(table, View)) {
                    const viewName = table[ViewBaseConfig].name;
                    const viewSchema = table[ViewBaseConfig].schema;
                    const origViewName = table[ViewBaseConfig].originalName;
                    const alias = viewName === origViewName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql `${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else {
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`);
                }
                if (index < joins.length - 1) {
                    joinsArray.push(sql ` `);
                }
            }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql ` where ${where}` : undefined;
        const havingSql = having ? sql ` having ${having}` : undefined;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
            orderBySql = sql ` order by ${sql.join(orderBy, sql `, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
            groupBySql = sql ` group by ${sql.join(groupBy, sql `, `)}`;
        }
        const limitSql = limit ? sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? sql ` offset ${offset}` : undefined;
        const lockingClausesSql = sql.empty();
        if (lockingClauses) {
            for (const { strength, config } of lockingClauses) {
                const clauseSql = sql ` for ${sql.raw(strength)}`;
                if (config.of) {
                    clauseSql.append(sql ` of ${config.of}`);
                }
                if (config.noWait) {
                    clauseSql.append(sql ` no wait`);
                }
                else if (config.skipLocked) {
                    clauseSql.append(sql ` skip locked`);
                }
                lockingClausesSql.append(clauseSql);
            }
        }
        return sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
    }
    buildInsertQuery({ table, values, onConflict, returning }) {
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName, col] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {
                    // eslint-disable-next-line unicorn/no-negated-condition
                    if (col.defaultFn !== undefined) {
                        const defaultFnResult = col.defaultFn();
                        const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
                        valueList.push(defaultValue);
                    }
                    else {
                        valueList.push(sql `default`);
                    }
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(sql `, `);
            }
        }
        const valuesSql = sql.join(valuesSqlList);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const onConflictSql = onConflict ? sql ` on conflict ${onConflict}` : undefined;
        return sql `insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
    }
    buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
        const concurrentlySql = concurrently ? sql ` concurrently` : undefined;
        const withNoDataSql = withNoData ? sql ` with no data` : undefined;
        return sql `refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
    }
    prepareTyping(encoder) {
        if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
            return 'json';
        }
        else if (is(encoder, PgNumeric)) {
            return 'decimal';
        }
        else if (is(encoder, PgTime)) {
            return 'time';
        }
        else if (is(encoder, PgTimestamp)) {
            return 'timestamp';
        }
        else if (is(encoder, PgDate)) {
            return 'date';
        }
        else if (is(encoder, PgUUID)) {
            return 'uuid';
        }
        else {
            return 'none';
        }
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
            prepareTyping: this.prepareTyping,
        });
    }
    // buildRelationalQueryWithPK({
    // 	fullSchema,
    // 	schema,
    // 	tableNamesMap,
    // 	table,
    // 	tableConfig,
    // 	queryConfig: config,
    // 	tableAlias,
    // 	isRoot = false,
    // 	joinOn,
    // }: {
    // 	fullSchema: Record<string, unknown>;
    // 	schema: TablesRelationalConfig;
    // 	tableNamesMap: Record<string, string>;
    // 	table: PgTable;
    // 	tableConfig: TableRelationalConfig;
    // 	queryConfig: true | DBQueryConfig<'many', true>;
    // 	tableAlias: string;
    // 	isRoot?: boolean;
    // 	joinOn?: SQL;
    // }): BuildRelationalQueryResult<PgTable, PgColumn> {
    // 	// For { "<relation>": true }, return a table with selection of all columns
    // 	if (config === true) {
    // 		const selectionEntries = Object.entries(tableConfig.columns);
    // 		const selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((
    // 			[key, value],
    // 		) => ({
    // 			dbKey: value.name,
    // 			tsKey: key,
    // 			field: value as PgColumn,
    // 			relationTableTsKey: undefined,
    // 			isJson: false,
    // 			selection: [],
    // 		}));
    // 		return {
    // 			tableTsKey: tableConfig.tsName,
    // 			sql: table,
    // 			selection,
    // 		};
    // 	}
    // 	// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
    // 	// let selectionForBuild = selection;
    // 	const aliasedColumns = Object.fromEntries(
    // 		Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),
    // 	);
    // 	const aliasedRelations = Object.fromEntries(
    // 		Object.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),
    // 	);
    // 	const aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);
    // 	let where, hasUserDefinedWhere;
    // 	if (config.where) {
    // 		const whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;
    // 		where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
    // 		hasUserDefinedWhere = !!where;
    // 	}
    // 	where = and(joinOn, where);
    // 	// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];
    // 	let joins: Join[] = [];
    // 	let selectedColumns: string[] = [];
    // 	// Figure out which columns to select
    // 	if (config.columns) {
    // 		let isIncludeMode = false;
    // 		for (const [field, value] of Object.entries(config.columns)) {
    // 			if (value === undefined) {
    // 				continue;
    // 			}
    // 			if (field in tableConfig.columns) {
    // 				if (!isIncludeMode && value === true) {
    // 					isIncludeMode = true;
    // 				}
    // 				selectedColumns.push(field);
    // 			}
    // 		}
    // 		if (selectedColumns.length > 0) {
    // 			selectedColumns = isIncludeMode
    // 				? selectedColumns.filter((c) => config.columns?.[c] === true)
    // 				: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
    // 		}
    // 	} else {
    // 		// Select all columns if selection is not specified
    // 		selectedColumns = Object.keys(tableConfig.columns);
    // 	}
    // 	// for (const field of selectedColumns) {
    // 	// 	const column = tableConfig.columns[field]! as PgColumn;
    // 	// 	fieldsSelection.push({ tsKey: field, value: column });
    // 	// }
    // 	let initiallySelectedRelations: {
    // 		tsKey: string;
    // 		queryConfig: true | DBQueryConfig<'many', false>;
    // 		relation: Relation;
    // 	}[] = [];
    // 	// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];
    // 	// Figure out which relations to select
    // 	if (config.with) {
    // 		initiallySelectedRelations = Object.entries(config.with)
    // 			.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])
    // 			.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));
    // 	}
    // 	const manyRelations = initiallySelectedRelations.filter((r) =>
    // 		is(r.relation, Many)
    // 		&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0
    // 	);
    // 	// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level
    // 	const isInnermostQuery = manyRelations.length < 2;
    // 	const selectedExtras: {
    // 		tsKey: string;
    // 		value: SQL.Aliased;
    // 	}[] = [];
    // 	// Figure out which extras to select
    // 	if (isInnermostQuery && config.extras) {
    // 		const extras = typeof config.extras === 'function'
    // 			? config.extras(aliasedFields, { sql })
    // 			: config.extras;
    // 		for (const [tsKey, value] of Object.entries(extras)) {
    // 			selectedExtras.push({
    // 				tsKey,
    // 				value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
    // 			});
    // 		}
    // 	}
    // 	// Transform `fieldsSelection` into `selection`
    // 	// `fieldsSelection` shouldn't be used after this point
    // 	// for (const { tsKey, value, isExtra } of fieldsSelection) {
    // 	// 	selection.push({
    // 	// 		dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,
    // 	// 		tsKey,
    // 	// 		field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
    // 	// 		relationTableTsKey: undefined,
    // 	// 		isJson: false,
    // 	// 		isExtra,
    // 	// 		selection: [],
    // 	// 	});
    // 	// }
    // 	let orderByOrig = typeof config.orderBy === 'function'
    // 		? config.orderBy(aliasedFields, orderByOperators)
    // 		: config.orderBy ?? [];
    // 	if (!Array.isArray(orderByOrig)) {
    // 		orderByOrig = [orderByOrig];
    // 	}
    // 	const orderBy = orderByOrig.map((orderByValue) => {
    // 		if (is(orderByValue, Column)) {
    // 			return aliasedTableColumn(orderByValue, tableAlias) as PgColumn;
    // 		}
    // 		return mapColumnsInSQLToAlias(orderByValue, tableAlias);
    // 	});
    // 	const limit = isInnermostQuery ? config.limit : undefined;
    // 	const offset = isInnermostQuery ? config.offset : undefined;
    // 	// For non-root queries without additional config except columns, return a table with selection
    // 	if (
    // 		!isRoot
    // 		&& initiallySelectedRelations.length === 0
    // 		&& selectedExtras.length === 0
    // 		&& !where
    // 		&& orderBy.length === 0
    // 		&& limit === undefined
    // 		&& offset === undefined
    // 	) {
    // 		return {
    // 			tableTsKey: tableConfig.tsName,
    // 			sql: table,
    // 			selection: selectedColumns.map((key) => ({
    // 				dbKey: tableConfig.columns[key]!.name,
    // 				tsKey: key,
    // 				field: tableConfig.columns[key] as PgColumn,
    // 				relationTableTsKey: undefined,
    // 				isJson: false,
    // 				selection: [],
    // 			})),
    // 		};
    // 	}
    // 	const selectedRelationsWithoutPK:
    // 	// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level
    // 	for (
    // 		const {
    // 			tsKey: selectedRelationTsKey,
    // 			queryConfig: selectedRelationConfigValue,
    // 			relation,
    // 		} of initiallySelectedRelations
    // 	) {
    // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
    // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
    // 		const relationTableTsName = tableNamesMap[relationTableName]!;
    // 		const relationTable = schema[relationTableTsName]!;
    // 		if (relationTable.primaryKey.length > 0) {
    // 			continue;
    // 		}
    // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
    // 		const joinOn = and(
    // 			...normalizedRelation.fields.map((field, i) =>
    // 				eq(
    // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
    // 					aliasedTableColumn(field, tableAlias),
    // 				)
    // 			),
    // 		);
    // 		const builtRelation = this.buildRelationalQueryWithoutPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table: fullSchema[relationTableTsName] as PgTable,
    // 			tableConfig: schema[relationTableTsName]!,
    // 			queryConfig: selectedRelationConfigValue,
    // 			tableAlias: relationTableAlias,
    // 			joinOn,
    // 			nestedQueryRelation: relation,
    // 		});
    // 		const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
    // 		joins.push({
    // 			on: sql`true`,
    // 			table: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),
    // 			alias: relationTableAlias,
    // 			joinType: 'left',
    // 			lateral: true,
    // 		});
    // 		selectedRelations.push({
    // 			dbKey: selectedRelationTsKey,
    // 			tsKey: selectedRelationTsKey,
    // 			field,
    // 			relationTableTsKey: relationTableTsName,
    // 			isJson: true,
    // 			selection: builtRelation.selection,
    // 		});
    // 	}
    // 	const oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>
    // 		is(r.relation, One)
    // 	);
    // 	// Process all One relations with PKs, because they can all be joined on the same level
    // 	for (
    // 		const {
    // 			tsKey: selectedRelationTsKey,
    // 			queryConfig: selectedRelationConfigValue,
    // 			relation,
    // 		} of oneRelations
    // 	) {
    // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
    // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
    // 		const relationTableTsName = tableNamesMap[relationTableName]!;
    // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
    // 		const relationTable = schema[relationTableTsName]!;
    // 		if (relationTable.primaryKey.length === 0) {
    // 			continue;
    // 		}
    // 		const joinOn = and(
    // 			...normalizedRelation.fields.map((field, i) =>
    // 				eq(
    // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
    // 					aliasedTableColumn(field, tableAlias),
    // 				)
    // 			),
    // 		);
    // 		const builtRelation = this.buildRelationalQueryWithPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table: fullSchema[relationTableTsName] as PgTable,
    // 			tableConfig: schema[relationTableTsName]!,
    // 			queryConfig: selectedRelationConfigValue,
    // 			tableAlias: relationTableAlias,
    // 			joinOn,
    // 		});
    // 		const field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${
    // 			sql.join(
    // 				builtRelation.selection.map(({ field }) =>
    // 					is(field, SQL.Aliased)
    // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
    // 						: is(field, Column)
    // 						? aliasedTableColumn(field, relationTableAlias)
    // 						: field
    // 				),
    // 				sql`, `,
    // 			)
    // 		}) end`.as(selectedRelationTsKey);
    // 		const isLateralJoin = is(builtRelation.sql, SQL);
    // 		joins.push({
    // 			on: isLateralJoin ? sql`true` : joinOn,
    // 			table: is(builtRelation.sql, SQL)
    // 				? new Subquery(builtRelation.sql, {}, relationTableAlias)
    // 				: aliasedTable(builtRelation.sql, relationTableAlias),
    // 			alias: relationTableAlias,
    // 			joinType: 'left',
    // 			lateral: is(builtRelation.sql, SQL),
    // 		});
    // 		selectedRelations.push({
    // 			dbKey: selectedRelationTsKey,
    // 			tsKey: selectedRelationTsKey,
    // 			field,
    // 			relationTableTsKey: relationTableTsName,
    // 			isJson: true,
    // 			selection: builtRelation.selection,
    // 		});
    // 	}
    // 	let distinct: PgSelectConfig['distinct'];
    // 	let tableFrom: PgTable | Subquery = table;
    // 	// Process first Many relation - each one requires a nested subquery
    // 	const manyRelation = manyRelations[0];
    // 	if (manyRelation) {
    // 		const {
    // 			tsKey: selectedRelationTsKey,
    // 			queryConfig: selectedRelationQueryConfig,
    // 			relation,
    // 		} = manyRelation;
    // 		distinct = {
    // 			on: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),
    // 		};
    // 		const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
    // 		const relationTableName = relation.referencedTable[Table.Symbol.Name];
    // 		const relationTableTsName = tableNamesMap[relationTableName]!;
    // 		const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
    // 		const joinOn = and(
    // 			...normalizedRelation.fields.map((field, i) =>
    // 				eq(
    // 					aliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),
    // 					aliasedTableColumn(field, tableAlias),
    // 				)
    // 			),
    // 		);
    // 		const builtRelationJoin = this.buildRelationalQueryWithPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table: fullSchema[relationTableTsName] as PgTable,
    // 			tableConfig: schema[relationTableTsName]!,
    // 			queryConfig: selectedRelationQueryConfig,
    // 			tableAlias: relationTableAlias,
    // 			joinOn,
    // 		});
    // 		const builtRelationSelectionField = sql`case when ${
    // 			sql.identifier(relationTableAlias)
    // 		} is null then '[]' else json_agg(json_build_array(${
    // 			sql.join(
    // 				builtRelationJoin.selection.map(({ field }) =>
    // 					is(field, SQL.Aliased)
    // 						? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`
    // 						: is(field, Column)
    // 						? aliasedTableColumn(field, relationTableAlias)
    // 						: field
    // 				),
    // 				sql`, `,
    // 			)
    // 		})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);
    // 		const isLateralJoin = is(builtRelationJoin.sql, SQL);
    // 		joins.push({
    // 			on: isLateralJoin ? sql`true` : joinOn,
    // 			table: isLateralJoin
    // 				? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)
    // 				: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),
    // 			alias: relationTableAlias,
    // 			joinType: 'left',
    // 			lateral: isLateralJoin,
    // 		});
    // 		// Build the "from" subquery with the remaining Many relations
    // 		const builtTableFrom = this.buildRelationalQueryWithPK({
    // 			fullSchema,
    // 			schema,
    // 			tableNamesMap,
    // 			table,
    // 			tableConfig,
    // 			queryConfig: {
    // 				...config,
    // 				where: undefined,
    // 				orderBy: undefined,
    // 				limit: undefined,
    // 				offset: undefined,
    // 				with: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(
    // 					(result, { tsKey, queryConfig: configValue }) => {
    // 						result[tsKey] = configValue;
    // 						return result;
    // 					},
    // 					{},
    // 				),
    // 			},
    // 			tableAlias,
    // 		});
    // 		selectedRelations.push({
    // 			dbKey: selectedRelationTsKey,
    // 			tsKey: selectedRelationTsKey,
    // 			field: builtRelationSelectionField,
    // 			relationTableTsKey: relationTableTsName,
    // 			isJson: true,
    // 			selection: builtRelationJoin.selection,
    // 		});
    // 		// selection = builtTableFrom.selection.map((item) =>
    // 		// 	is(item.field, SQL.Aliased)
    // 		// 		? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
    // 		// 		: item
    // 		// );
    // 		// selectionForBuild = [{
    // 		// 	dbKey: '*',
    // 		// 	tsKey: '*',
    // 		// 	field: sql`${sql.identifier(tableAlias)}.*`,
    // 		// 	selection: [],
    // 		// 	isJson: false,
    // 		// 	relationTableTsKey: undefined,
    // 		// }];
    // 		// const newSelectionItem: (typeof selection)[number] = {
    // 		// 	dbKey: selectedRelationTsKey,
    // 		// 	tsKey: selectedRelationTsKey,
    // 		// 	field,
    // 		// 	relationTableTsKey: relationTableTsName,
    // 		// 	isJson: true,
    // 		// 	selection: builtRelationJoin.selection,
    // 		// };
    // 		// selection.push(newSelectionItem);
    // 		// selectionForBuild.push(newSelectionItem);
    // 		tableFrom = is(builtTableFrom.sql, PgTable)
    // 			? builtTableFrom.sql
    // 			: new Subquery(builtTableFrom.sql, {}, tableAlias);
    // 	}
    // 	if (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {
    // 		throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
    // 	}
    // 	let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];
    // 	function prepareSelectedColumns() {
    // 		return selectedColumns.map((key) => ({
    // 			dbKey: tableConfig.columns[key]!.name,
    // 			tsKey: key,
    // 			field: tableConfig.columns[key] as PgColumn,
    // 			relationTableTsKey: undefined,
    // 			isJson: false,
    // 			selection: [],
    // 		}));
    // 	}
    // 	function prepareSelectedExtras() {
    // 		return selectedExtras.map((item) => ({
    // 			dbKey: item.value.fieldAlias,
    // 			tsKey: item.tsKey,
    // 			field: item.value,
    // 			relationTableTsKey: undefined,
    // 			isJson: false,
    // 			selection: [],
    // 		}));
    // 	}
    // 	if (isRoot) {
    // 		selection = [
    // 			...prepareSelectedColumns(),
    // 			...prepareSelectedExtras(),
    // 		];
    // 	}
    // 	if (hasUserDefinedWhere || orderBy.length > 0) {
    // 		tableFrom = new Subquery(
    // 			this.buildSelectQuery({
    // 				table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
    // 				fields: {},
    // 				fieldsFlat: selectionForBuild.map(({ field }) => ({
    // 					path: [],
    // 					field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
    // 				})),
    // 				joins,
    // 				distinct,
    // 			}),
    // 			{},
    // 			tableAlias,
    // 		);
    // 		selectionForBuild = selection.map((item) =>
    // 			is(item.field, SQL.Aliased)
    // 				? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }
    // 				: item
    // 		);
    // 		joins = [];
    // 		distinct = undefined;
    // 	}
    // 	const result = this.buildSelectQuery({
    // 		table: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,
    // 		fields: {},
    // 		fieldsFlat: selectionForBuild.map(({ field }) => ({
    // 			path: [],
    // 			field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
    // 		})),
    // 		where,
    // 		limit,
    // 		offset,
    // 		joins,
    // 		orderBy,
    // 		distinct,
    // 	});
    // 	return {
    // 		tableTsKey: tableConfig.tsName,
    // 		sql: result,
    // 		selection,
    // 	};
    // }
    buildRelationalQueryWithoutPK({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        const joins = [];
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, getOperators())
                    : config.where;
                where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (is(orderByValue, Column)) {
                    return aliasedTableColumn(orderByValue, tableAlias);
                }
                return mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                const joinOn = and(...normalizedRelation.fields.map((field, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQueryWithoutPK({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: is(relation, One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                const field = sql `${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
                joins.push({
                    on: sql `true`,
                    table: new Subquery(builtRelation.sql, {}, relationTableAlias),
                    alias: relationTableAlias,
                    joinType: 'left',
                    lateral: true,
                });
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
            let field = sql `json_build_array(${sql.join(selection.map(({ field, tsKey, isJson }) => isJson
                ? sql `${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier('data')}`
                : is(field, SQL.Aliased)
                    ? field.sql
                    : field), sql `, `)})`;
            if (is(nestedQueryRelation, Many)) {
                field = sql `coalesce(json_agg(${field}${orderBy.length > 0 ? sql ` order by ${sql.join(orderBy, sql `, `)}` : undefined}), '[]'::json)`;
                // orderBy = [];
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field: field.as('data'),
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [{
                            path: [],
                            field: sql.raw('*'),
                        }],
                    where,
                    limit,
                    offset,
                    orderBy,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = [];
            }
            else {
                result = aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
}

class TypedQueryBuilder {
    static [entityKind] = 'TypedQueryBuilder';
    /** @internal */
    getSelectedFields() {
        return this._.selectedFields;
    }
}

class PgSelectBuilder {
    static [entityKind] = 'PgSelectBuilder';
    fields;
    session;
    dialect;
    withList = [];
    distinct;
    constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
            this.withList = config.withList;
        }
        this.distinct = config.distinct;
    }
    /**
     * Specify the table, subquery, or other target that you're
     * building a select query against.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM|Postgres from documentation}
     */
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (is(source, Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (is(source, PgViewBase)) {
            fields = source[ViewBaseConfig].selectedFields;
        }
        else if (is(source, SQL)) {
            fields = {};
        }
        else {
            fields = getTableColumns(source);
        }
        return new PgSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
class PgSelectQueryBuilder extends TypedQueryBuilder {
    static [entityKind] = 'PgSelectQueryBuilder';
    _;
    config;
    joinsNotNullableMap;
    tableName;
    isPartialSelect;
    session;
    dialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
            withList,
            table,
            fields: { ...fields },
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !is(table, SQL)) {
                    const selection = is(table, Subquery)
                        ? table[SubqueryConfig].selection
                        : is(table, View)
                            ? table[ViewBaseConfig].selectedFields
                            : table[Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            if (!this.config.joins) {
                this.config.joins = [];
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    /**
     * For each row of the table, include
     * values from a matching row of the joined
     * table, if there is a matching row. If not,
     * all of the columns of the joined table
     * will be set to null.
     */
    leftJoin = this.createJoin('left');
    /**
     * Includes all of the rows of the joined table.
     * If there is no matching row in the main table,
     * all the columns of the main table will be
     * set to null.
     */
    rightJoin = this.createJoin('right');
    /**
     * This is the default type of join.
     *
     * For each row of the table, the joined table
     * needs to have a matching row, or it will
     * be excluded from results.
     */
    innerJoin = this.createJoin('inner');
    /**
     * Rows from both the main & joined are included,
     * regardless of whether or not they have matching
     * rows in the other table.
     */
    fullJoin = this.createJoin('full');
    /**
     * Specify a condition to narrow the result set. Multiple
     * conditions can be combined with the `and` and `or`
     * functions.
     *
     * ## Examples
     *
     * ```ts
     * // Find cars made in the year 2000
     * db.select().from(cars).where(eq(cars.year, 2000));
     * ```
     */
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    /**
     * Sets the HAVING clause of this query, which often
     * used with GROUP BY and filters rows after they've been
     * grouped together and combined.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING|Postgres having clause documentation}
     */
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    /**
     * Set the maximum number of rows that will be
     * returned by this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the first 10 people from this query.
     * db.select().from(people).limit(10);
     * ```
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-LIMIT|Postgres LIMIT documentation}
     */
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    /**
     * Skip a number of rows when returning results
     * from this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the 10th-20th people from this query.
     * db.select().from(people).offset(10).limit(10);
     * ```
     */
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    /**
     * The FOR clause specifies a lock strength for this query
     * that controls how strictly it acquires exclusive access to
     * the rows being queried.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE|Postgres locking clause documentation}
     */
    for(strength, config = {}) {
        if (!this.config.lockingClauses) {
            this.config.lockingClauses = [];
        }
        this.config.lockingClauses.push({ strength, config });
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
class PgSelect extends PgSelectQueryBuilder {
    static [entityKind] = 'PgSelect';
    _prepare(name) {
        const { session, config, dialect, joinsNotNullableMap } = this;
        if (!session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        return tracer.startActiveSpan('drizzle.prepareQuery', () => {
            const fieldsList = orderSelectedFields(config.fields);
            const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
            query.joinsNotNullableMap = joinsNotNullableMap;
            return query;
        });
    }
    /**
     * Create a prepared statement for this query. This allows
     * the database to remember this query for the given session
     * and call it by name, rather than specifying the full query.
     *
     * {@link https://www.postgresql.org/docs/current/sql-prepare.html|Postgres prepare documentation}
     */
    prepare(name) {
        return this._prepare(name);
    }
    execute = (placeholderValues) => {
        return tracer.startActiveSpan('drizzle.operation', () => {
            return this._prepare().execute(placeholderValues);
        });
    };
}
applyMixins(PgSelect, [QueryPromise]);

class QueryBuilder {
    static [entityKind] = 'PgQueryBuilder';
    dialect;
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                distinct: true,
            });
        }
        function selectDistinctOn(on, fields) {
            return new PgSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                distinct: { on },
            });
        }
        return { select, selectDistinct, selectDistinctOn };
    }
    select(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
        });
    }
    selectDistinct(fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    selectDistinctOn(on, fields) {
        return new PgSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: { on },
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new PgDialect();
        }
        return this.dialect;
    }
}

class DefaultViewBuilderCore {
    name;
    schema;
    static [entityKind] = 'PgDefaultViewBuilderCore';
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
    }
    config = {};
    with(config) {
        this.config.with = config;
        return this;
    }
}
class ViewBuilder extends DefaultViewBuilderCore {
    static [entityKind] = 'PgViewBuilder';
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgView({
            pgConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
class ManualViewBuilder extends DefaultViewBuilderCore {
    static [entityKind] = 'PgManualViewBuilder';
    columns;
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
    }
    existing() {
        return new Proxy(new PgView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new PgView({
            pgConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
class MaterializedViewBuilderCore {
    name;
    schema;
    static [entityKind] = 'PgMaterializedViewBuilderCore';
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
    }
    config = {};
    using(using) {
        this.config.using = using;
        return this;
    }
    with(config) {
        this.config.with = config;
        return this;
    }
    tablespace(tablespace) {
        this.config.tablespace = tablespace;
        return this;
    }
    withNoData() {
        this.config.withNoData = true;
        return this;
    }
}
class MaterializedViewBuilder extends MaterializedViewBuilderCore {
    static [entityKind] = 'PgMaterializedViewBuilder';
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new PgMaterializedView({
            pgConfig: {
                with: this.config.with,
                using: this.config.using,
                tablespace: this.config.tablespace,
                withNoData: this.config.withNoData,
            },
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
class ManualMaterializedViewBuilder extends MaterializedViewBuilderCore {
    static [entityKind] = 'PgManualMaterializedViewBuilder';
    columns;
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(pgTable(name, columns));
    }
    existing() {
        return new Proxy(new PgMaterializedView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new PgMaterializedView({
            pgConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
class PgViewBase extends View {
    static [entityKind] = 'PgViewBase';
}
const PgViewConfig = Symbol.for('drizzle:PgViewConfig');
class PgView extends PgViewBase {
    static [entityKind] = 'PgView';
    [PgViewConfig];
    constructor({ pgConfig, config }) {
        super(config);
        if (pgConfig) {
            this[PgViewConfig] = {
                with: pgConfig.with,
            };
        }
    }
}
const PgMaterializedViewConfig = Symbol.for('drizzle:PgMaterializedViewConfig');
class PgMaterializedView extends PgViewBase {
    static [entityKind] = 'PgMaterializedView';
    [PgMaterializedViewConfig];
    constructor({ pgConfig, config }) {
        super(config);
        this[PgMaterializedViewConfig] = {
            with: pgConfig?.with,
            using: pgConfig?.using,
            tablespace: pgConfig?.tablespace,
            withNoData: pgConfig?.withNoData,
        };
    }
}
/** @internal */
function pgViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualViewBuilder(name, selection, schema);
    }
    return new ViewBuilder(name, schema);
}
/** @internal */
function pgMaterializedViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualMaterializedViewBuilder(name, selection, schema);
    }
    return new MaterializedViewBuilder(name, schema);
}
function pgView(name, columns) {
    return pgViewWithSchema(name, columns, undefined);
}
function pgMaterializedView(name, columns) {
    return pgMaterializedViewWithSchema(name, columns, undefined);
}

class Relation {
    sourceTable;
    referencedTable;
    relationName;
    static [entityKind] = 'Relation';
    referencedTableName;
    fieldName;
    constructor(sourceTable, referencedTable, relationName) {
        this.sourceTable = sourceTable;
        this.referencedTable = referencedTable;
        this.relationName = relationName;
        this.referencedTableName = referencedTable[Table.Symbol.Name];
    }
}
class Relations {
    table;
    config;
    static [entityKind] = 'Relations';
    constructor(table, config) {
        this.table = table;
        this.config = config;
    }
}
class One extends Relation {
    config;
    isNullable;
    static [entityKind] = 'One';
    constructor(sourceTable, referencedTable, config, isNullable) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
        this.isNullable = isNullable;
    }
    withFieldName(fieldName) {
        const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
        relation.fieldName = fieldName;
        return relation;
    }
}
class Many extends Relation {
    config;
    static [entityKind] = 'Many';
    constructor(sourceTable, referencedTable, config) {
        super(sourceTable, referencedTable, config?.relationName);
        this.config = config;
    }
    withFieldName(fieldName) {
        const relation = new Many(this.sourceTable, this.referencedTable, this.config);
        relation.fieldName = fieldName;
        return relation;
    }
}
function getOperators() {
    return {
        and,
        between,
        eq,
        exists,
        gt,
        gte,
        ilike,
        inArray,
        isNull,
        isNotNull,
        like,
        lt,
        lte,
        ne,
        not,
        notBetween,
        notExists,
        notLike,
        notIlike,
        notInArray,
        or,
        sql,
    };
}
function getOrderByOperators() {
    return {
        sql,
        asc,
        desc,
    };
}
function extractTablesRelationalConfig(schema, configHelpers) {
    if (Object.keys(schema).length === 1
        && 'default' in schema
        && !is(schema['default'], Table)) {
        schema = schema['default'];
    }
    // table DB name -> schema table key
    const tableNamesMap = {};
    // Table relations found before their tables - need to buffer them until we know the schema table key
    const relationsBuffer = {};
    const tablesConfig = {};
    for (const [key, value] of Object.entries(schema)) {
        if (isTable(value)) {
            const dbName = value[Table.Symbol.Name];
            const bufferedRelations = relationsBuffer[dbName];
            tableNamesMap[dbName] = key;
            tablesConfig[key] = {
                tsName: key,
                dbName: value[Table.Symbol.Name],
                columns: value[Table.Symbol.Columns],
                relations: bufferedRelations?.relations ?? {},
                primaryKey: bufferedRelations?.primaryKey ?? [],
            };
            // Fill in primary keys
            for (const column of Object.values(value[Table.Symbol.Columns])) {
                if (column.primary) {
                    tablesConfig[key].primaryKey.push(column);
                }
            }
            const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);
            if (extraConfig) {
                for (const configEntry of Object.values(extraConfig)) {
                    if (is(configEntry, PrimaryKeyBuilder)) {
                        tablesConfig[key].primaryKey.push(...configEntry.columns);
                    }
                }
            }
        }
        else if (is(value, Relations)) {
            const dbName = value.table[Table.Symbol.Name];
            const tableName = tableNamesMap[dbName];
            const relations = value.config(configHelpers(value.table));
            let primaryKey;
            for (const [relationName, relation] of Object.entries(relations)) {
                if (tableName) {
                    const tableConfig = tablesConfig[tableName];
                    tableConfig.relations[relationName] = relation;
                }
                else {
                    if (!(dbName in relationsBuffer)) {
                        relationsBuffer[dbName] = {
                            relations: {},
                            primaryKey,
                        };
                    }
                    relationsBuffer[dbName].relations[relationName] = relation;
                }
            }
        }
    }
    return { tables: tablesConfig, tableNamesMap };
}
function relations(table, relations) {
    return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations(helpers)).map(([key, value]) => [
        key,
        value.withFieldName(key),
    ])));
}
function createOne(sourceTable) {
    return function one(table, config) {
        return new One(sourceTable, table, config, (config?.fields.reduce((res, f) => res && f.notNull, true)
            ?? false));
    };
}
function createMany(sourceTable) {
    return function many(referencedTable, config) {
        return new Many(sourceTable, referencedTable, config);
    };
}
function normalizeRelation(schema, tableNamesMap, relation) {
    if (is(relation, One) && relation.config) {
        return {
            fields: relation.config.fields,
            references: relation.config.references,
        };
    }
    const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
    if (!referencedTableTsName) {
        throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
    }
    const referencedTableConfig = schema[referencedTableTsName];
    if (!referencedTableConfig) {
        throw new Error(`Table "${referencedTableTsName}" not found in schema`);
    }
    const sourceTable = relation.sourceTable;
    const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
    if (!sourceTableTsName) {
        throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
    }
    const reverseRelations = [];
    for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
        if ((relation.relationName
            && relation !== referencedTableRelation
            && referencedTableRelation.relationName === relation.relationName)
            || (!relation.relationName
                && referencedTableRelation.referencedTable === relation.sourceTable)) {
            reverseRelations.push(referencedTableRelation);
        }
    }
    if (reverseRelations.length > 1) {
        throw relation.relationName
            ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`)
            : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
    }
    if (reverseRelations[0]
        && is(reverseRelations[0], One)
        && reverseRelations[0].config) {
        return {
            fields: reverseRelations[0].config.references,
            references: reverseRelations[0].config.fields,
        };
    }
    throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
    return {
        one: createOne(sourceTable),
        many: createMany(sourceTable),
    };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
    const result = {};
    for (const [selectionItemIndex, selectionItem,] of buildQueryResultSelection.entries()) {
        if (selectionItem.isJson) {
            const relation = tableConfig.relations[selectionItem.tsKey];
            const rawSubRows = row[selectionItemIndex];
            const subRows = typeof rawSubRows === 'string'
                ? JSON.parse(rawSubRows)
                : rawSubRows;
            result[selectionItem.tsKey] = is(relation, One)
                ? subRows
                    && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue)
                : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
        }
        else {
            const value = mapColumnValue(row[selectionItemIndex]);
            const field = selectionItem.field;
            let decoder;
            if (is(field, Column)) {
                decoder = field;
            }
            else if (is(field, SQL)) {
                decoder = field.decoder;
            }
            else {
                decoder = field.sql.decoder;
            }
            result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
        }
    }
    return result;
}

function bindIfParam(value, column) {
    if (isDriverValueEncoder(column)
        && !isSQLWrapper(value)
        && !is(value, Param)
        && !is(value, Placeholder)
        && !is(value, Column)
        && !is(value, Table)
        && !is(value, View)) {
        return new Param(value, column);
    }
    return value;
}
/**
 * Test that two values are equal.
 *
 * Remember that the SQL standard dictates that
 * two NULL values are not equal, so if you want to test
 * whether a value is null, you may want to use
 * `isNull` instead.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made by Ford
 * db.select().from(cars)
 *   .where(eq(cars.make, 'Ford'))
 * ```
 *
 * @see isNull for a way to test equality to NULL.
 */
const eq = (left, right) => {
    return sql `${left} = ${bindIfParam(right, left)}`;
};
/**
 * Test that two values are not equal.
 *
 * Remember that the SQL standard dictates that
 * two NULL values are not equal, so if you want to test
 * whether a value is not null, you may want to use
 * `isNotNull` instead.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars not made by Ford
 * db.select().from(cars)
 *   .where(ne(cars.make, 'Ford'))
 * ```
 *
 * @see isNotNull for a way to test whether a value is not null.
 */
const ne = (left, right) => {
    return sql `${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
    const conditions = unfilteredConditions.filter((c) => c !== undefined);
    if (conditions.length === 0) {
        return undefined;
    }
    if (conditions.length === 1) {
        return new SQL(conditions);
    }
    return new SQL([
        new StringChunk('('),
        sql.join(conditions, new StringChunk(' and ')),
        new StringChunk(')'),
    ]);
}
function or(...unfilteredConditions) {
    const conditions = unfilteredConditions.filter((c) => c !== undefined);
    if (conditions.length === 0) {
        return undefined;
    }
    if (conditions.length === 1) {
        return new SQL(conditions);
    }
    return new SQL([
        new StringChunk('('),
        sql.join(conditions, new StringChunk(' or ')),
        new StringChunk(')'),
    ]);
}
/**
 * Negate the meaning of an expression using the `not` keyword.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars _not_ made by GM or Ford.
 * db.select().from(cars)
 *   .where(not(inArray(cars.make, ['GM', 'Ford'])))
 * ```
 */
function not(condition) {
    return sql `not ${condition}`;
}
/**
 * Test that the first expression passed is greater than
 * the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made after 2000.
 * db.select().from(cars)
 *   .where(gt(cars.year, 2000))
 * ```
 *
 * @see gte for greater-than-or-equal
 */
const gt = (left, right) => {
    return sql `${left} > ${bindIfParam(right, left)}`;
};
/**
 * Test that the first expression passed is greater than
 * or equal to the second expression. Use `gt` to
 * test whether an expression is strictly greater
 * than another.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made on or after 2000.
 * db.select().from(cars)
 *   .where(gte(cars.year, 2000))
 * ```
 *
 * @see gt for a strictly greater-than condition
 */
const gte = (left, right) => {
    return sql `${left} >= ${bindIfParam(right, left)}`;
};
/**
 * Test that the first expression passed is less than
 * the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made before 2000.
 * db.select().from(cars)
 *   .where(lt(cars.year, 2000))
 * ```
 *
 * @see lte for greater-than-or-equal
 */
const lt = (left, right) => {
    return sql `${left} < ${bindIfParam(right, left)}`;
};
/**
 * Test that the first expression passed is less than
 * or equal to the second expression.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars made before 2000.
 * db.select().from(cars)
 *   .where(lte(cars.year, 2000))
 * ```
 *
 * @see lt for a strictly less-than condition
 */
const lte = (left, right) => {
    return sql `${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('inArray requires at least one value');
        }
        return sql `${column} in ${values.map((v) => bindIfParam(v, column))}`;
    }
    return sql `${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('notInArray requires at least one value');
        }
        return sql `${column} not in ${values.map((v) => bindIfParam(v, column))}`;
    }
    return sql `${column} not in ${bindIfParam(values, column)}`;
}
/**
 * Test whether an expression is NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have no discontinuedAt date.
 * db.select().from(cars)
 *   .where(isNull(cars.discontinuedAt))
 * ```
 *
 * @see isNotNull for the inverse of this test
 */
function isNull(value) {
    return sql `${value} is null`;
}
/**
 * Test whether an expression is not NULL. By the SQL standard,
 * NULL is neither equal nor not equal to itself, so
 * it's recommended to use `isNull` and `notIsNull` for
 * comparisons to NULL.
 *
 * ## Examples
 *
 * ```ts
 * // Select cars that have been discontinued.
 * db.select().from(cars)
 *   .where(isNotNull(cars.discontinuedAt))
 * ```
 *
 * @see isNull for the inverse of this test
 */
function isNotNull(value) {
    return sql `${value} is not null`;
}
/**
 * Test whether a subquery evaluates to have any rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column has a match in a cities
 * // table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     exists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see notExists for the inverse of this test
 */
function exists(subquery) {
    return sql `exists (${subquery})`;
}
/**
 * Test whether a subquery doesn't include any result
 * rows.
 *
 * ## Examples
 *
 * ```ts
 * // Users whose `homeCity` column doesn't match
 * // a row in the cities table.
 * db
 *   .select()
 *   .from(users)
 *   .where(
 *     notExists(db.select()
 *       .from(cities)
 *       .where(eq(users.homeCity, cities.id))),
 *   );
 * ```
 *
 * @see exists for the inverse of this test
 */
function notExists(subquery) {
    return sql `not exists (${subquery})`;
}
function between(column, min, max) {
    return sql `${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
    return sql `${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
/**
 * Compare a column to a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(like(cars.name, '%Turbo%'))
 * ```
 *
 * @see ilike for a case-insensitive version of this condition
 */
function like(column, value) {
    return sql `${column} like ${value}`;
}
/**
 * The inverse of like - this tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "ROver" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see like for the inverse condition
 * @see notIlike for a case-insensitive version of this condition
 */
function notLike(column, value) {
    return sql `${column} not like ${value}`;
}
/**
 * Case-insensitively compare a column to a pattern,
 * which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * Unlike like, this performs a case-insensitive comparison.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars with 'Turbo' in their names.
 * db.select().from(cars)
 *   .where(ilike(cars.name, '%Turbo%'))
 * ```
 *
 * @see like for a case-sensitive version of this condition
 */
function ilike(column, value) {
    return sql `${column} ilike ${value}`;
}
/**
 * The inverse of ilike - this case-insensitively tests that a given column
 * does not match a pattern, which can include `%` and `_`
 * characters to match multiple variations. Including `%`
 * in the pattern matches zero or more characters, and including
 * `_` will match a single character.
 *
 * ## Examples
 *
 * ```ts
 * // Select all cars that don't have "Rover" in their name.
 * db.select().from(cars)
 *   .where(notLike(cars.name, '%Rover%'))
 * ```
 *
 * @see ilike for the inverse condition
 * @see notLike for a case-sensitive version of this condition
 */
function notIlike(column, value) {
    return sql `${column} not ilike ${value}`;
}
function arrayContains(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('arrayContains requires at least one value');
        }
        const array = sql `${bindIfParam(values, column)}`;
        return sql `${column} @> ${array}`;
    }
    return sql `${column} @> ${bindIfParam(values, column)}`;
}
function arrayContained(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('arrayContained requires at least one value');
        }
        const array = sql `${bindIfParam(values, column)}`;
        return sql `${column} <@ ${array}`;
    }
    return sql `${column} <@ ${bindIfParam(values, column)}`;
}
function arrayOverlaps(column, values) {
    if (Array.isArray(values)) {
        if (values.length === 0) {
            throw new Error('arrayOverlaps requires at least one value');
        }
        const array = sql `${bindIfParam(values, column)}`;
        return sql `${column} && ${array}`;
    }
    return sql `${column} && ${bindIfParam(values, column)}`;
}

/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in ascending
 * order. By the SQL standard, ascending order is the
 * default, so it is not usually necessary to specify
 * ascending sort order.
 *
 * ## Examples
 *
 * ```ts
 * // Return cars, starting with the oldest models
 * // and going in ascending order to the newest.
 * db.select().from(cars)
 *   .orderBy(asc(cars.year));
 * ```
 *
 * @see desc to sort in descending order
 */
function asc(column) {
    return sql `${column} asc`;
}
/**
 * Used in sorting, this specifies that the given
 * column or expression should be sorted in descending
 * order.
 *
 * ## Examples
 *
 * ```ts
 * // Select users, with the most recently created
 * // records coming first.
 * db.select().from(users)
 *   .orderBy(desc(users.createdAt));
 * ```
 *
 * @see asc to sort in ascending order
 */
function desc(column) {
    return sql `${column} desc`;
}

/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
class FakePrimitiveParam {
    static [entityKind] = 'FakePrimitiveParam';
}
function isSQLWrapper(value) {
    return typeof value === 'object' && value !== null && 'getSQL' in value
        && typeof value.getSQL === 'function';
}
function mergeQueries(queries) {
    const result = { sql: '', params: [] };
    for (const query of queries) {
        result.sql += query.sql;
        result.params.push(...query.params);
        if (query.typings?.length) {
            if (!result.typings) {
                result.typings = [];
            }
            result.typings.push(...query.typings);
        }
    }
    return result;
}
class StringChunk {
    static [entityKind] = 'StringChunk';
    value;
    constructor(value) {
        this.value = Array.isArray(value) ? value : [value];
    }
    getSQL() {
        return new SQL([this]);
    }
}
class SQL {
    queryChunks;
    static [entityKind] = 'SQL';
    /** @internal */
    decoder = noopDecoder;
    shouldInlineParams = false;
    constructor(queryChunks) {
        this.queryChunks = queryChunks;
    }
    append(query) {
        this.queryChunks.push(...query.queryChunks);
        return this;
    }
    toQuery(config) {
        return tracer.startActiveSpan('drizzle.buildSQL', (span) => {
            const query = this.buildQueryFromSourceParams(this.queryChunks, config);
            span?.setAttributes({
                'drizzle.query.text': query.sql,
                'drizzle.query.params': JSON.stringify(query.params),
            });
            return query;
        });
    }
    buildQueryFromSourceParams(chunks, _config) {
        const config = Object.assign({}, _config, {
            inlineParams: _config.inlineParams || this.shouldInlineParams,
            paramStartIndex: _config.paramStartIndex || { value: 0 },
        });
        const { escapeName, escapeParam, prepareTyping, inlineParams, paramStartIndex, } = config;
        return mergeQueries(chunks.map((chunk) => {
            if (is(chunk, StringChunk)) {
                return { sql: chunk.value.join(''), params: [] };
            }
            if (is(chunk, Name)) {
                return { sql: escapeName(chunk.value), params: [] };
            }
            if (chunk === undefined) {
                return { sql: '', params: [] };
            }
            if (Array.isArray(chunk)) {
                const result = [new StringChunk('(')];
                for (const [i, p] of chunk.entries()) {
                    result.push(p);
                    if (i < chunk.length - 1) {
                        result.push(new StringChunk(', '));
                    }
                }
                result.push(new StringChunk(')'));
                return this.buildQueryFromSourceParams(result, config);
            }
            if (is(chunk, SQL)) {
                return this.buildQueryFromSourceParams(chunk.queryChunks, {
                    ...config,
                    inlineParams: inlineParams || chunk.shouldInlineParams,
                });
            }
            if (is(chunk, Table)) {
                const schemaName = chunk[Table.Symbol.Schema];
                const tableName = chunk[Table.Symbol.Name];
                return {
                    sql: schemaName === undefined
                        ? escapeName(tableName)
                        : escapeName(schemaName) + '.' + escapeName(tableName),
                    params: [],
                };
            }
            if (is(chunk, Column)) {
                return { sql: escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(chunk.name), params: [] };
            }
            if (is(chunk, View)) {
                const schemaName = chunk[ViewBaseConfig].schema;
                const viewName = chunk[ViewBaseConfig].name;
                return {
                    sql: schemaName === undefined
                        ? escapeName(viewName)
                        : escapeName(schemaName) + '.' + escapeName(viewName),
                    params: [],
                };
            }
            if (is(chunk, Param)) {
                const mappedValue = (chunk.value === null) ? null : chunk.encoder.mapToDriverValue(chunk.value);
                if (is(mappedValue, SQL)) {
                    return this.buildQueryFromSourceParams([mappedValue], config);
                }
                if (inlineParams) {
                    return { sql: this.mapInlineParam(mappedValue, config), params: [] };
                }
                let typings;
                if (prepareTyping !== undefined) {
                    typings = [prepareTyping(chunk.encoder)];
                }
                return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
            }
            if (is(chunk, Placeholder)) {
                return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
            }
            if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
                return { sql: escapeName(chunk.fieldAlias), params: [] };
            }
            if (is(chunk, Subquery)) {
                if (chunk[SubqueryConfig].isWith) {
                    return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
                }
                return this.buildQueryFromSourceParams([
                    new StringChunk('('),
                    chunk[SubqueryConfig].sql,
                    new StringChunk(') '),
                    new Name(chunk[SubqueryConfig].alias),
                ], config);
            }
            // if (is(chunk, Placeholder)) {
            // 	return {sql: escapeParam}
            if (isSQLWrapper(chunk)) {
                return this.buildQueryFromSourceParams([
                    new StringChunk('('),
                    chunk.getSQL(),
                    new StringChunk(')'),
                ], config);
            }
            if (is(chunk, Relation)) {
                return this.buildQueryFromSourceParams([
                    chunk.sourceTable,
                    new StringChunk('.'),
                    sql.identifier(chunk.fieldName),
                ], config);
            }
            if (inlineParams) {
                return { sql: this.mapInlineParam(chunk, config), params: [] };
            }
            return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
        }));
    }
    mapInlineParam(chunk, { escapeString }) {
        if (chunk === null) {
            return 'null';
        }
        if (typeof chunk === 'number' || typeof chunk === 'boolean') {
            return chunk.toString();
        }
        if (typeof chunk === 'string') {
            return escapeString(chunk);
        }
        if (typeof chunk === 'object') {
            const mappedValueAsString = chunk.toString();
            if (mappedValueAsString === '[object Object]') {
                return escapeString(JSON.stringify(chunk));
            }
            return escapeString(mappedValueAsString);
        }
        throw new Error('Unexpected param value: ' + chunk);
    }
    getSQL() {
        return this;
    }
    as(alias) {
        // TODO: remove with deprecated overloads
        if (alias === undefined) {
            return this;
        }
        return new SQL.Aliased(this, alias);
    }
    mapWith(decoder) {
        this.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;
        return this;
    }
    inlineParams() {
        this.shouldInlineParams = true;
        return this;
    }
}
/**
 * Any DB name (table, column, index etc.)
 */
class Name {
    value;
    static [entityKind] = 'Name';
    brand;
    constructor(value) {
        this.value = value;
    }
    getSQL() {
        return new SQL([this]);
    }
}
/**
 * Any DB name (table, column, index etc.)
 * @deprecated Use `sql.identifier` instead.
 */
function name(value) {
    return new Name(value);
}
function isDriverValueEncoder(value) {
    return typeof value === 'object' && value !== null && 'mapToDriverValue' in value
        && typeof value.mapToDriverValue === 'function';
}
const noopDecoder = {
    mapFromDriverValue: (value) => value,
};
const noopEncoder = {
    mapToDriverValue: (value) => value,
};
const noopMapper = {
    ...noopDecoder,
    ...noopEncoder,
};
/** Parameter value that is optionally bound to an encoder (for example, a column). */
class Param {
    value;
    encoder;
    static [entityKind] = 'Param';
    brand;
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value, encoder = noopEncoder) {
        this.value = value;
        this.encoder = encoder;
    }
    getSQL() {
        return new SQL([this]);
    }
}
/** @deprecated Use `sql.param` instead. */
function param(value, encoder) {
    return new Param(value, encoder);
}
/*
    The type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -
    in runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values
    which will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload
    specify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and
    the type checker happy.
*/
function sql(strings, ...params) {
    const queryChunks = [];
    if (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {
        queryChunks.push(new StringChunk(strings[0]));
    }
    for (const [paramIndex, param] of params.entries()) {
        queryChunks.push(param, new StringChunk(strings[paramIndex + 1]));
    }
    return new SQL(queryChunks);
}
(function (sql) {
    function empty() {
        return new SQL([]);
    }
    sql.empty = empty;
    /** @deprecated - use `sql.join()` */
    function fromList(list) {
        return new SQL(list);
    }
    sql.fromList = fromList;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str) {
        return new SQL([new StringChunk(str)]);
    }
    sql.raw = raw;
    /**
     * Join a list of SQL chunks with a separator.
     * @example
     * ```ts
     * const query = sql.join([sql`a`, sql`b`, sql`c`]);
     * // sql`abc`
     * ```
     * @example
     * ```ts
     * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);
     * // sql`a, b, c`
     * ```
     */
    function join(chunks, separator) {
        const result = [];
        for (const [i, chunk] of chunks.entries()) {
            if (i > 0 && separator !== undefined) {
                result.push(separator);
            }
            result.push(chunk);
        }
        return new SQL(result);
    }
    sql.join = join;
    /**
     * Create a SQL chunk that represents a DB identifier (table, column, index etc.).
     * When used in a query, the identifier will be escaped based on the DB engine.
     * For example, in PostgreSQL, identifiers are escaped with double quotes.
     *
     * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**
     *
     * @example ```ts
     * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;
     * // 'SELECT * FROM "my-table"'
     * ```
     */
    function identifier(value) {
        return new Name(value);
    }
    sql.identifier = identifier;
    function placeholder(name) {
        return new Placeholder(name);
    }
    sql.placeholder = placeholder;
    function param(value, encoder) {
        return new Param(value, encoder);
    }
    sql.param = param;
})(sql || (sql = {}));
(function (SQL) {
    class Aliased {
        sql;
        fieldAlias;
        static [entityKind] = 'SQL.Aliased';
        /** @internal */
        isSelectionField = false;
        constructor(sql, fieldAlias) {
            this.sql = sql;
            this.fieldAlias = fieldAlias;
        }
        getSQL() {
            return this.sql;
        }
        /** @internal */
        clone() {
            return new Aliased(this.sql, this.fieldAlias);
        }
    }
    SQL.Aliased = Aliased;
})(SQL || (SQL = {}));
class Placeholder {
    name;
    static [entityKind] = 'Placeholder';
    constructor(name) {
        this.name = name;
    }
    getSQL() {
        return new SQL([this]);
    }
}
/** @deprecated Use `sql.placeholder` instead. */
function placeholder(name) {
    return new Placeholder(name);
}
function fillPlaceholders(params, values) {
    return params.map((p) => {
        if (is(p, Placeholder)) {
            if (!(p.name in values)) {
                throw new Error(`No value for placeholder "${p.name}" was provided`);
            }
            return values[p.name];
        }
        return p;
    });
}
// Defined separately from the Column class to resolve circular dependency
Column.prototype.getSQL = function () {
    return new SQL([this]);
};

class ColumnAliasProxyHandler {
    table;
    static [entityKind] = 'ColumnAliasProxyHandler';
    constructor(table) {
        this.table = table;
    }
    get(columnObj, prop) {
        if (prop === 'table') {
            return this.table;
        }
        return columnObj[prop];
    }
}
class TableAliasProxyHandler {
    alias;
    replaceOriginalName;
    static [entityKind] = 'TableAliasProxyHandler';
    constructor(alias, replaceOriginalName) {
        this.alias = alias;
        this.replaceOriginalName = replaceOriginalName;
    }
    get(target, prop) {
        if (prop === Table.Symbol.IsAlias) {
            return true;
        }
        if (prop === Table.Symbol.Name) {
            return this.alias;
        }
        if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
            return this.alias;
        }
        if (prop === ViewBaseConfig) {
            return {
                ...target[ViewBaseConfig],
                name: this.alias,
                isAlias: true,
            };
        }
        if (prop === Table.Symbol.Columns) {
            const columns = target[Table.Symbol.Columns];
            if (!columns) {
                return columns;
            }
            const proxiedColumns = {};
            Object.keys(columns).map((key) => {
                proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
            });
            return proxiedColumns;
        }
        const value = target[prop];
        if (is(value, Column)) {
            return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
        }
        return value;
    }
}
class RelationTableAliasProxyHandler {
    alias;
    static [entityKind] = 'RelationTableAliasProxyHandler';
    constructor(alias) {
        this.alias = alias;
    }
    get(target, prop) {
        if (prop === 'sourceTable') {
            return aliasedTable(target.sourceTable, this.alias);
        }
        return target[prop];
    }
}
function aliasedTable(table, tableAlias) {
    return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedRelation(relation, tableAlias) {
    return new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));
}
function aliasedTableColumn(column, tableAlias) {
    return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
    return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
    return sql.join(query.queryChunks.map((c) => {
        if (is(c, Column)) {
            return aliasedTableColumn(c, alias);
        }
        if (is(c, SQL)) {
            return mapColumnsInSQLToAlias(c, alias);
        }
        if (is(c, SQL.Aliased)) {
            return mapColumnsInAliasedSQLToAlias(c, alias);
        }
        return c;
    }));
}

export { PgArrayBuilder as $, getOrderByOperators as A, normalizeRelation as B, ColumnBuilder as C, DrizzleError as D, and as E, eq as F, aliasedTable as G, applyMixins as H, getTableColumns as I, TypedQueryBuilder as J, getTableLikeName as K, PgColumnBuilder as L, Many as M, PgColumn as N, One as O, PgDialect as P, QueryPromise as Q, pgTableWithSchema as R, SQL as S, Table as T, pgViewWithSchema as U, ViewBaseConfig as V, WithSubquery as W, pgMaterializedViewWithSchema as X, CheckBuilder as Y, Check as Z, check as _, extractTablesRelationalConfig as a, PgView as a$, PgArray as a0, PgDateBuilder as a1, PgDate as a2, PgDateStringBuilder as a3, PgDateString as a4, date as a5, PgJsonBuilder as a6, PgJson as a7, json as a8, PgJsonbBuilder as a9, PrimaryKeyBuilder as aA, PrimaryKey as aB, PgSelectQueryBuilder as aC, PgSelect as aD, InlineForeignKeys as aE, PgTable as aF, pgTable as aG, pgTableCreator as aH, unique as aI, uniqueKeyName as aJ, UniqueConstraintBuilder as aK, UniqueOnConstraintBuilder as aL, UniqueConstraint as aM, getTableConfig as aN, getViewConfig as aO, getMaterializedViewConfig as aP, parsePgNestedArray as aQ, parsePgArray as aR, makePgArray as aS, DefaultViewBuilderCore as aT, ViewBuilder as aU, ManualViewBuilder as aV, MaterializedViewBuilderCore as aW, MaterializedViewBuilder as aX, ManualMaterializedViewBuilder as aY, PgViewBase as aZ, PgViewConfig as a_, PgJsonb as aa, jsonb as ab, PgNumericBuilder as ac, PgNumeric as ad, numeric as ae, decimal as af, PgTimeBuilder as ag, PgTime as ah, time as ai, PgTimestampBuilder as aj, PgTimestamp as ak, PgTimestampStringBuilder as al, PgTimestampString as am, timestamp as an, PgUUIDBuilder as ao, PgUUID as ap, uuid as aq, ForeignKeyBuilder as ar, ForeignKey as as, foreignKey as at, IndexBuilderOn as au, IndexBuilder as av, Index as aw, index as ax, uniqueIndex as ay, primaryKey as az, Param as b, PgMaterializedViewConfig as b0, PgMaterializedView as b1, pgView as b2, pgMaterializedView as b3, ColumnAliasProxyHandler as b4, RelationTableAliasProxyHandler as b5, aliasedRelation as b6, hasOwnEntityKind as b7, bindIfParam as b8, ne as b9, createOne as bA, createMany as bB, FakePrimitiveParam as bC, isSQLWrapper as bD, StringChunk as bE, Name as bF, name as bG, isDriverValueEncoder as bH, noopDecoder as bI, noopEncoder as bJ, noopMapper as bK, param as bL, Placeholder as bM, placeholder as bN, TableName as bO, Schema as bP, Columns as bQ, OriginalName as bR, BaseName as bS, IsAlias as bT, ExtraConfigBuilder as bU, isTable as bV, iife as bW, or as ba, not as bb, gt as bc, gte as bd, lt as be, lte as bf, inArray as bg, notInArray as bh, isNull as bi, isNotNull as bj, exists as bk, notExists as bl, between as bm, notBetween as bn, like as bo, notLike as bp, ilike as bq, notIlike as br, arrayContains as bs, arrayContained as bt, arrayOverlaps as bu, asc as bv, desc as bw, Relation as bx, Relations as by, relations as bz, createTableRelationsHelpers as c, mapUpdateSet as d, entityKind as e, fillPlaceholders as f, mapRelationalRow as g, QueryBuilder as h, is as i, SelectionProxyHandler as j, PgSelectBuilder as k, TransactionRollbackError as l, mapResultRow as m, TableAliasProxyHandler as n, orderSelectedFields as o, Column as p, getTableName as q, Subquery as r, sql as s, tracer as t, SubqueryConfig as u, View as v, aliasedTableColumn as w, getOperators as x, mapColumnsInSQLToAlias as y, mapColumnsInAliasedSQLToAlias as z };
//# sourceMappingURL=alias-cf8e03cd.mjs.map
