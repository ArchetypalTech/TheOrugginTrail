import { entityKind } from '../../entity.js';
import { TypedQueryBuilder } from '../../query-builders/query-builder.js';
import type { BuildSubquerySelection, GetSelectTableName, GetSelectTableSelection, JoinNullability, SelectMode, SelectResult } from '../../query-builders/select.types.js';
import { QueryPromise } from '../../query-promise.js';
import { type Placeholder, type Query, SQL } from '../../sql/index.js';
import type { SQLiteColumn } from '../columns/index.js';
import type { SQLiteDialect } from '../dialect.js';
import type { PreparedQuery, SQLiteSession } from '../session.js';
import type { SubqueryWithSelection } from '../subquery.js';
import type { SQLiteTable } from '../table.js';
import { Subquery } from '../../subquery.js';
import { type ValueOrArray } from '../../utils.js';
import { type ColumnsSelection } from '../../view.js';
import { SQLiteViewBase } from '../view.js';
import type { JoinFn, SelectedFields, SQLiteSelectConfig, SQLiteSelectHKT, SQLiteSelectHKTBase, SQLiteSelectQueryBuilderHKT } from './select.types.js';
type CreateSQLiteSelectFromBuilderMode<TBuilderMode extends 'db' | 'qb', TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection extends ColumnsSelection, TSelectMode extends SelectMode> = TBuilderMode extends 'db' ? SQLiteSelect<TTableName, TResultType, TRunResult, TSelection, TSelectMode> : SQLiteSelectQueryBuilder<SQLiteSelectQueryBuilderHKT, TTableName, TResultType, TRunResult, TSelection, TSelectMode>;
export declare class SQLiteSelectBuilder<TSelection extends SelectedFields | undefined, TResultType extends 'sync' | 'async', TRunResult, TBuilderMode extends 'db' | 'qb' = 'db'> {
    static readonly [entityKind]: string;
    private fields;
    private session;
    private dialect;
    private withList;
    private distinct;
    constructor(config: {
        fields: TSelection;
        session: SQLiteSession<any, any, any, any> | undefined;
        dialect: SQLiteDialect;
        withList?: Subquery[];
        distinct?: boolean;
    });
    from<TFrom extends SQLiteTable | Subquery | SQLiteViewBase | SQL>(source: TFrom): CreateSQLiteSelectFromBuilderMode<TBuilderMode, GetSelectTableName<TFrom>, TResultType, TRunResult, TSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection, TSelection extends undefined ? 'single' : 'partial'>;
}
export declare abstract class SQLiteSelectQueryBuilder<THKT extends SQLiteSelectHKTBase, TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends TypedQueryBuilder<BuildSubquerySelection<TSelection, TNullabilityMap>, SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly selectMode: TSelectMode;
        readonly selection: TSelection;
        readonly result: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        readonly selectedFields: BuildSubquerySelection<TSelection, TNullabilityMap>;
    };
    protected joinsNotNullableMap: Record<string, boolean>;
    private tableName;
    private isPartialSelect;
    protected session: SQLiteSession<any, any, any, any> | undefined;
    protected dialect: SQLiteDialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }: {
        table: SQLiteSelectConfig['table'];
        fields: SQLiteSelectConfig['fields'];
        isPartialSelect: boolean;
        session: SQLiteSession<any, any, any, any> | undefined;
        dialect: SQLiteDialect;
        withList: Subquery[] | undefined;
        distinct: boolean | undefined;
    });
    private createJoin;
    leftJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "left", TSelection, TNullabilityMap>;
    rightJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "right", TSelection, TNullabilityMap>;
    innerJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "inner", TSelection, TNullabilityMap>;
    fullJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "full", TSelection, TNullabilityMap>;
    where(where: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    having(having: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    groupBy(builder: (aliases: TSelection) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>): this;
    groupBy(...columns: (SQLiteColumn | SQL)[]): this;
    orderBy(builder: (aliases: TSelection) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>): this;
    orderBy(...columns: (SQLiteColumn | SQL)[]): this;
    limit(limit: number | Placeholder): this;
    offset(offset: number | Placeholder): this;
    toSQL(): Query;
    as<TAlias extends string>(alias: TAlias): SubqueryWithSelection<BuildSubquerySelection<TSelection, TNullabilityMap>, TAlias>;
    getSelectedFields(): BuildSubquerySelection<TSelection, TNullabilityMap>;
}
export interface SQLiteSelect<TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection extends ColumnsSelection, TSelectMode extends SelectMode = 'single', TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends SQLiteSelectQueryBuilder<SQLiteSelectHKT, TTableName | undefined, TResultType, TRunResult, TSelection, TSelectMode, TNullabilityMap>, QueryPromise<SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
}
export declare class SQLiteSelect<TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection, TSelectMode extends SelectMode = 'single', TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends SQLiteSelectQueryBuilder<SQLiteSelectHKT, TTableName, TResultType, TRunResult, TSelection, TSelectMode, TNullabilityMap> {
    static readonly [entityKind]: string;
    prepare(isOneTimeQuery?: boolean): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        get: SelectResult<TSelection, TSelectMode, TNullabilityMap> | undefined;
        values: any[][];
        execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
    execute(): Promise<SelectResult<TSelection, TSelectMode, TNullabilityMap>[]>;
}
export {};
