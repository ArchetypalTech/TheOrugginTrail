import { e as entityKind, s as sql, n as TableAliasProxyHandler, T as Table, i as is, V as ViewBaseConfig } from '../alias-cf8e03cd.mjs';
import { j as SQLiteColumnBuilder, k as SQLiteColumn, l as SQLiteTable, U as UniqueConstraintBuilder, F as ForeignKeyBuilder, m as SQLiteViewConfig } from '../session-afae3551.mjs';
export { B as BaseSQLiteDatabase, E as ExecuteResultSync, o as ForeignKey, I as InlineForeignKeys, M as ManualViewBuilder, P as PreparedQuery, Q as QueryBuilder, c as SQLiteAsyncDialect, g as SQLiteDelete, n as SQLiteDialect, e as SQLiteInsert, q as SQLiteInsertBuilder, d as SQLiteSelect, r as SQLiteSelectBuilder, s as SQLiteSelectQueryBuilder, S as SQLiteSession, b as SQLiteSyncDialect, a as SQLiteTransaction, f as SQLiteUpdate, t as SQLiteUpdateBuilder, D as SQLiteView, C as SQLiteViewBase, z as UniqueConstraint, y as UniqueOnConstraintBuilder, A as ViewBuilder, V as ViewBuilderCore, p as foreignKey, u as sqliteTable, v as sqliteTableCreator, G as sqliteView, x as unique, w as uniqueKeyName, H as view } from '../session-afae3551.mjs';

class SQLiteBigIntBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteBigIntBuilder';
    constructor(name) {
        super(name, 'bigint', 'SQLiteBigInt');
    }
    /** @internal */
    build(table) {
        return new SQLiteBigInt(table, this.config);
    }
}
class SQLiteBigInt extends SQLiteColumn {
    static [entityKind] = 'SQLiteBigInt';
    getSQLType() {
        return 'blob';
    }
    mapFromDriverValue(value) {
        return BigInt(value.toString());
    }
    mapToDriverValue(value) {
        return Buffer.from(value.toString());
    }
}
class SQLiteBlobJsonBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteBlobJsonBuilder';
    constructor(name) {
        super(name, 'json', 'SQLiteBlobJson');
    }
    /** @internal */
    build(table) {
        return new SQLiteBlobJson(table, this.config);
    }
}
class SQLiteBlobJson extends SQLiteColumn {
    static [entityKind] = 'SQLiteBlobJson';
    getSQLType() {
        return 'blob';
    }
    mapFromDriverValue(value) {
        return JSON.parse(value.toString());
    }
    mapToDriverValue(value) {
        return Buffer.from(JSON.stringify(value));
    }
}
class SQLiteBlobBufferBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteBlobBufferBuilder';
    constructor(name) {
        super(name, 'buffer', 'SQLiteBlobBuffer');
    }
    /** @internal */
    build(table) {
        return new SQLiteBlobBuffer(table, this.config);
    }
}
class SQLiteBlobBuffer extends SQLiteColumn {
    static [entityKind] = 'SQLiteBlobBuffer';
    getSQLType() {
        return 'blob';
    }
}
function blob(name, config) {
    if (config?.mode === 'json') {
        return new SQLiteBlobJsonBuilder(name);
    }
    if (config?.mode === 'bigint') {
        return new SQLiteBigIntBuilder(name);
    }
    return new SQLiteBlobBufferBuilder(name);
}

class SQLiteCustomColumnBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteCustomColumnBuilder';
    constructor(name, fieldConfig, customTypeParams) {
        super(name, 'custom', 'SQLiteCustomColumn');
        this.config.fieldConfig = fieldConfig;
        this.config.customTypeParams = customTypeParams;
    }
    /** @internal */
    build(table) {
        return new SQLiteCustomColumn(table, this.config);
    }
}
class SQLiteCustomColumn extends SQLiteColumn {
    static [entityKind] = 'SQLiteCustomColumn';
    sqlName;
    mapTo;
    mapFrom;
    constructor(table, config) {
        super(table, config);
        this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
        this.mapTo = config.customTypeParams.toDriver;
        this.mapFrom = config.customTypeParams.fromDriver;
    }
    getSQLType() {
        return this.sqlName;
    }
    mapFromDriverValue(value) {
        return typeof this.mapFrom === 'function' ? this.mapFrom(value) : value;
    }
    mapToDriverValue(value) {
        return typeof this.mapTo === 'function' ? this.mapTo(value) : value;
    }
}
/**
 * Custom sqlite database data type generator
 */
function customType(customTypeParams) {
    return (dbName, fieldConfig) => {
        return new SQLiteCustomColumnBuilder(dbName, fieldConfig, customTypeParams);
    };
}

class SQLiteBaseIntegerBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteBaseIntegerBuilder';
    constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
    }
    primaryKey(config) {
        if (config?.autoIncrement) {
            this.config.autoIncrement = true;
        }
        this.config.hasDefault = true;
        return super.primaryKey();
    }
}
class SQLiteBaseInteger extends SQLiteColumn {
    static [entityKind] = 'SQLiteBaseInteger';
    autoIncrement = this.config.autoIncrement;
    getSQLType() {
        return 'integer';
    }
}
class SQLiteIntegerBuilder extends SQLiteBaseIntegerBuilder {
    static [entityKind] = 'SQLiteIntegerBuilder';
    constructor(name) {
        super(name, 'number', 'SQLiteInteger');
    }
    build(table) {
        return new SQLiteInteger(table, this.config);
    }
}
class SQLiteInteger extends SQLiteBaseInteger {
    static [entityKind] = 'SQLiteInteger';
}
class SQLiteTimestampBuilder extends SQLiteBaseIntegerBuilder {
    static [entityKind] = 'SQLiteTimestampBuilder';
    constructor(name, mode) {
        super(name, 'date', 'SQLiteTimestamp');
        this.config.mode = mode;
    }
    /**
     * @deprecated Use `default()` with your own expression instead.
     *
     * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
     */
    defaultNow() {
        return this.default(sql `(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
    }
    build(table) {
        return new SQLiteTimestamp(table, this.config);
    }
}
class SQLiteTimestamp extends SQLiteBaseInteger {
    static [entityKind] = 'SQLiteTimestamp';
    mode = this.config.mode;
    mapFromDriverValue(value) {
        if (this.config.mode === 'timestamp') {
            return new Date(value * 1000);
        }
        return new Date(value);
    }
    mapToDriverValue(value) {
        const unix = value.getTime();
        if (this.config.mode === 'timestamp') {
            return Math.floor(unix / 1000);
        }
        return unix;
    }
}
class SQLiteBooleanBuilder extends SQLiteBaseIntegerBuilder {
    static [entityKind] = 'SQLiteBooleanBuilder';
    constructor(name, mode) {
        super(name, 'boolean', 'SQLiteBoolean');
        this.config.mode = mode;
    }
    build(table) {
        return new SQLiteBoolean(table, this.config);
    }
}
class SQLiteBoolean extends SQLiteBaseInteger {
    static [entityKind] = 'SQLiteBoolean';
    mode = this.config.mode;
    mapFromDriverValue(value) {
        return Number(value) === 1;
    }
    mapToDriverValue(value) {
        return value ? 1 : 0;
    }
}
function integer(name, config) {
    if (config?.mode === 'timestamp' || config?.mode === 'timestamp_ms') {
        return new SQLiteTimestampBuilder(name, config.mode);
    }
    if (config?.mode === 'boolean') {
        return new SQLiteBooleanBuilder(name, config.mode);
    }
    return new SQLiteIntegerBuilder(name);
}
const int = integer;

class SQLiteNumericBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteNumericBuilder';
    constructor(name) {
        super(name, 'string', 'SQLiteNumeric');
    }
    /** @internal */
    build(table) {
        return new SQLiteNumeric(table, this.config);
    }
}
class SQLiteNumeric extends SQLiteColumn {
    static [entityKind] = 'SQLiteNumeric';
    getSQLType() {
        return 'numeric';
    }
}
function numeric(name) {
    return new SQLiteNumericBuilder(name);
}

class SQLiteRealBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteRealBuilder';
    constructor(name) {
        super(name, 'number', 'SQLiteReal');
    }
    /** @internal */
    build(table) {
        return new SQLiteReal(table, this.config);
    }
}
class SQLiteReal extends SQLiteColumn {
    static [entityKind] = 'SQLiteReal';
    getSQLType() {
        return 'real';
    }
}
function real(name) {
    return new SQLiteRealBuilder(name);
}

class SQLiteTextBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteTextBuilder';
    constructor(name, config) {
        super(name, 'string', 'SQLiteText');
        this.config.enumValues = config.enum;
        this.config.length = config.length;
    }
    /** @internal */
    build(table) {
        return new SQLiteText(table, this.config);
    }
}
class SQLiteText extends SQLiteColumn {
    static [entityKind] = 'SQLiteText';
    enumValues = this.config.enumValues;
    length = this.config.length;
    constructor(table, config) {
        super(table, config);
    }
    getSQLType() {
        return `text${this.config.length ? `(${this.config.length})` : ''}`;
    }
}
class SQLiteTextJsonBuilder extends SQLiteColumnBuilder {
    static [entityKind] = 'SQLiteTextJsonBuilder';
    constructor(name) {
        super(name, 'json', 'SQLiteTextJson');
    }
    /** @internal */
    build(table) {
        return new SQLiteTextJson(table, this.config);
    }
}
class SQLiteTextJson extends SQLiteColumn {
    static [entityKind] = 'SQLiteTextJson';
    getSQLType() {
        return 'text';
    }
    mapFromDriverValue(value) {
        return JSON.parse(value);
    }
    mapToDriverValue(value) {
        return JSON.stringify(value);
    }
}
function text(name, config = {}) {
    return (config.mode === 'json'
        ? new SQLiteTextJsonBuilder(name)
        : new SQLiteTextBuilder(name, config));
}

function alias(table, alias) {
    return new Proxy(table, new TableAliasProxyHandler(alias, false));
}

class CheckBuilder {
    name;
    value;
    static [entityKind] = 'SQLiteCheckBuilder';
    brand;
    constructor(name, value) {
        this.name = name;
        this.value = value;
    }
    build(table) {
        return new Check(table, this);
    }
}
class Check {
    table;
    static [entityKind] = 'SQLiteCheck';
    name;
    value;
    constructor(table, builder) {
        this.table = table;
        this.name = builder.name;
        this.value = builder.value;
    }
}
function check(name, value) {
    return new CheckBuilder(name, value);
}

class IndexBuilderOn {
    name;
    unique;
    static [entityKind] = 'SQLiteIndexBuilderOn';
    constructor(name, unique) {
        this.name = name;
        this.unique = unique;
    }
    on(...columns) {
        return new IndexBuilder(this.name, columns, this.unique);
    }
}
class IndexBuilder {
    static [entityKind] = 'SQLiteIndexBuilder';
    /** @internal */
    config;
    constructor(name, columns, unique) {
        this.config = {
            name,
            columns,
            unique,
            where: undefined,
        };
    }
    /**
     * Condition for partial index.
     */
    where(condition) {
        this.config.where = condition;
        return this;
    }
    /** @internal */
    build(table) {
        return new Index(this.config, table);
    }
}
class Index {
    static [entityKind] = 'SQLiteIndex';
    config;
    constructor(config, table) {
        this.config = { ...config, table };
    }
}
function index(name) {
    return new IndexBuilderOn(name, false);
}
function uniqueIndex(name) {
    return new IndexBuilderOn(name, true);
}

function primaryKey(...columns) {
    return new PrimaryKeyBuilder(columns);
}
class PrimaryKeyBuilder {
    static [entityKind] = 'SQLitePrimaryKeyBuilder';
    /** @internal */
    columns;
    constructor(columns) {
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new PrimaryKey(table, this.columns);
    }
}
class PrimaryKey {
    table;
    static [entityKind] = 'SQLitePrimaryKey';
    columns;
    constructor(table, columns) {
        this.table = table;
        this.columns = columns;
    }
    getName() {
        return `${this.table[SQLiteTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;
    }
}

function getTableConfig(table) {
    const columns = Object.values(table[SQLiteTable.Symbol.Columns]);
    const indexes = [];
    const checks = [];
    const primaryKeys = [];
    const uniqueConstraints = [];
    const foreignKeys = Object.values(table[SQLiteTable.Symbol.InlineForeignKeys]);
    const name = table[Table.Symbol.Name];
    const extraConfigBuilder = table[SQLiteTable.Symbol.ExtraConfigBuilder];
    if (extraConfigBuilder !== undefined) {
        const extraConfig = extraConfigBuilder(table[SQLiteTable.Symbol.Columns]);
        for (const builder of Object.values(extraConfig)) {
            if (is(builder, IndexBuilder)) {
                indexes.push(builder.build(table));
            }
            else if (is(builder, CheckBuilder)) {
                checks.push(builder.build(table));
            }
            else if (is(builder, UniqueConstraintBuilder)) {
                uniqueConstraints.push(builder.build(table));
            }
            else if (is(builder, PrimaryKeyBuilder)) {
                primaryKeys.push(builder.build(table));
            }
            else if (is(builder, ForeignKeyBuilder)) {
                foreignKeys.push(builder.build(table));
            }
        }
    }
    return {
        columns,
        indexes,
        foreignKeys,
        checks,
        primaryKeys,
        uniqueConstraints,
        name,
    };
}
function getViewConfig(view) {
    return {
        ...view[ViewBaseConfig],
        ...view[SQLiteViewConfig],
    };
}

export { Check, CheckBuilder, ForeignKeyBuilder, Index, IndexBuilder, IndexBuilderOn, PrimaryKey, PrimaryKeyBuilder, SQLiteBaseInteger, SQLiteBaseIntegerBuilder, SQLiteBigInt, SQLiteBigIntBuilder, SQLiteBlobBuffer, SQLiteBlobBufferBuilder, SQLiteBlobJson, SQLiteBlobJsonBuilder, SQLiteBoolean, SQLiteBooleanBuilder, SQLiteColumn, SQLiteColumnBuilder, SQLiteCustomColumn, SQLiteCustomColumnBuilder, SQLiteInteger, SQLiteIntegerBuilder, SQLiteNumeric, SQLiteNumericBuilder, SQLiteReal, SQLiteRealBuilder, SQLiteTable, SQLiteText, SQLiteTextBuilder, SQLiteTextJson, SQLiteTextJsonBuilder, SQLiteTimestamp, SQLiteTimestampBuilder, SQLiteViewConfig, UniqueConstraintBuilder, alias, blob, check, customType, getTableConfig, getViewConfig, index, int, integer, numeric, primaryKey, real, text, uniqueIndex };
//# sourceMappingURL=index.mjs.map
