import { entityKind } from '../entity.js';
import { type TablesRelationalConfig } from '../relations.js';
import type { Query, SQL } from '../sql/index.js';
import type { SQLiteAsyncDialect, SQLiteSyncDialect } from './dialect.js';
import { QueryPromise } from '../index.js';
import { BaseSQLiteDatabase } from './db.js';
import type { SelectedFieldsOrdered } from './query-builders/select.types.js';
import type { SQLiteRaw } from './query-builders/raw.js';
export interface PreparedQueryConfig {
    type: 'sync' | 'async';
    run: unknown;
    all: unknown;
    get: unknown;
    values: unknown;
    execute: unknown;
}
export declare class ExecuteResultSync<T> extends QueryPromise<T> {
    private resultCb;
    static readonly [entityKind]: string;
    constructor(resultCb: () => T);
    execute(): Promise<T>;
    sync(): T;
}
export type ExecuteResult<TType extends 'sync' | 'async', TResult> = TType extends 'async' ? Promise<TResult> : ExecuteResultSync<TResult>;
export declare abstract class PreparedQuery<T extends PreparedQueryConfig> {
    private mode;
    private executeMethod;
    static readonly [entityKind]: string;
    constructor(mode: 'sync' | 'async', executeMethod: SQLiteExecuteMethod);
    abstract run(placeholderValues?: Record<string, unknown>): Result<T['type'], T['run']>;
    abstract all(placeholderValues?: Record<string, unknown>): Result<T['type'], T['all']>;
    abstract get(placeholderValues?: Record<string, unknown>): Result<T['type'], T['get']>;
    abstract values(placeholderValues?: Record<string, unknown>): Result<T['type'], T['values']>;
    execute(placeholderValues?: Record<string, unknown>): ExecuteResult<T['type'], T['execute']>;
}
export interface SQLiteTransactionConfig {
    behavior?: 'deferred' | 'immediate' | 'exclusive';
}
export type SQLiteExecuteMethod = 'run' | 'all' | 'get';
export declare abstract class SQLiteSession<TResultKind extends 'sync' | 'async', TRunResult, TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig> {
    static readonly [entityKind]: string;
    constructor(
    /** @internal */
    dialect: {
        sync: SQLiteSyncDialect;
        async: SQLiteAsyncDialect;
    }[TResultKind]);
    abstract prepareQuery(query: Query, fields: SelectedFieldsOrdered | undefined, executeMethod: SQLiteExecuteMethod, customResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => unknown): PreparedQuery<PreparedQueryConfig & {
        type: TResultKind;
    }>;
    prepareOneTimeQuery(query: Query, fields: SelectedFieldsOrdered | undefined, executeMethod: SQLiteExecuteMethod): PreparedQuery<PreparedQueryConfig & {
        type: TResultKind;
    }>;
    abstract transaction<T>(transaction: (tx: SQLiteTransaction<TResultKind, TRunResult, TFullSchema, TSchema>) => Result<TResultKind, T>, config?: SQLiteTransactionConfig): Result<TResultKind, T>;
    run(query: SQL): Result<TResultKind, TRunResult>;
    all<T = unknown>(query: SQL): Result<TResultKind, T[]>;
    get<T = unknown>(query: SQL): Result<TResultKind, T>;
    values<T extends any[] = unknown[]>(query: SQL): Result<TResultKind, T[]>;
}
interface ResultHKT {
    readonly $brand: 'SQLiteResultHKT';
    readonly config: unknown;
    readonly type: unknown;
}
interface SyncResultHKT extends ResultHKT {
    readonly type: this['config'];
}
interface AsyncResultHKT extends ResultHKT {
    readonly type: Promise<this['config']>;
}
interface DBAsyncResultHKT extends ResultHKT {
    readonly type: SQLiteRaw<this['config']>;
}
export type Result<TKind extends 'sync' | 'async', TResult> = (('sync' extends TKind ? SyncResultHKT : AsyncResultHKT) & {
    readonly config: TResult;
})['type'];
export type DBResult<TKind extends 'sync' | 'async', TResult> = (('sync' extends TKind ? SyncResultHKT : DBAsyncResultHKT) & {
    readonly config: TResult;
})['type'];
export declare abstract class SQLiteTransaction<TResultType extends 'sync' | 'async', TRunResult, TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig> extends BaseSQLiteDatabase<TResultType, TRunResult, TFullSchema, TSchema> {
    protected schema: {
        fullSchema: Record<string, unknown>;
        schema: TSchema;
        tableNamesMap: Record<string, string>;
    } | undefined;
    protected readonly nestedIndex: number;
    static readonly [entityKind]: string;
    constructor(resultType: TResultType, dialect: {
        sync: SQLiteSyncDialect;
        async: SQLiteAsyncDialect;
    }[TResultType], session: SQLiteSession<TResultType, TRunResult, TFullSchema, TSchema>, schema: {
        fullSchema: Record<string, unknown>;
        schema: TSchema;
        tableNamesMap: Record<string, string>;
    } | undefined, nestedIndex?: number);
    rollback(): never;
}
export {};
