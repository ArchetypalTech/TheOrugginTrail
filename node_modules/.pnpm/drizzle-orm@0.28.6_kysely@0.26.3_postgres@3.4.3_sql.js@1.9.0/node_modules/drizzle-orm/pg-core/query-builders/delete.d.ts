import { entityKind } from '../../entity.js';
import type { PgDialect } from '../dialect.js';
import type { PgSession, PreparedQuery, PreparedQueryConfig, QueryResultHKT, QueryResultKind } from '../session.js';
import type { PgTable } from '../table.js';
import type { SelectResultFields } from '../../query-builders/select.types.js';
import { QueryPromise } from '../../query-promise.js';
import type { Query, SQL, SQLWrapper } from '../../sql/index.js';
import { type InferModel } from '../../table.js';
import type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.js';
export interface PgDeleteConfig {
    where?: SQL | undefined;
    table: PgTable;
    returning?: SelectedFieldsOrdered;
}
export interface PgDelete<TTable extends PgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> {
}
export declare class PgDelete<TTable extends PgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private config;
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    returning(): PgDelete<TTable, TQueryResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): PgDelete<TTable, TQueryResult, SelectResultFields<TSelectedFields>>;
    toSQL(): Query;
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}
