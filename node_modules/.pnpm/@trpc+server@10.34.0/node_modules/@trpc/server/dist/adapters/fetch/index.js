'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('../../index-4a823936.js');
var resolveHTTPResponse = require('../../resolveHTTPResponse-199d522a.js');
var batchStreamFormatter = require('../../batchStreamFormatter-93cdcdd4.js');
require('../../codes-0eeb600d.js');
require('../../config-943bca43.js');
require('../../TRPCError-d07099d1.js');
require('../../transformTRPCResponse-48d70ef6.js');
require('../../contentType-5b601838.js');

async function fetchRequestHandler(opts) {
    const resHeaders = new Headers();
    const createContext = async ()=>{
        return opts.createContext?.({
            req: opts.req,
            resHeaders
        });
    };
    const url = new URL(opts.req.url);
    const path = url.pathname.slice(opts.endpoint.length + 1);
    const req = {
        query: url.searchParams,
        method: opts.req.method,
        headers: Object.fromEntries(opts.req.headers),
        body: opts.req.headers.get('content-type') === 'application/json' ? await opts.req.text() : ''
    };
    let resolve;
    const promise = new Promise((r)=>resolve = r);
    let status = 200;
    let isStream = false;
    let controller;
    let encoder;
    let formatter;
    const unstable_onHead = (head, isStreaming)=>{
        for (const [key, value] of Object.entries(head.headers ?? {})){
            /* istanbul ignore if -- @preserve */ if (typeof value === 'undefined') {
                continue;
            }
            if (typeof value === 'string') {
                resHeaders.set(key, value);
                continue;
            }
            for (const v of value){
                resHeaders.append(key, v);
            }
        }
        status = head.status;
        if (isStreaming) {
            resHeaders.set('Transfer-Encoding', 'chunked');
            resHeaders.append('Vary', 'trpc-batch-mode');
            const stream = new ReadableStream({
                start (c) {
                    controller = c;
                }
            });
            const response = new Response(stream, {
                status,
                headers: resHeaders
            });
            resolve(response);
            encoder = new TextEncoder();
            formatter = batchStreamFormatter.getBatchStreamFormatter();
            isStream = true;
        }
    };
    const unstable_onChunk = ([index, string])=>{
        if (index === -1) {
            // full response, no streaming
            const response = new Response(string || null, {
                status,
                headers: resHeaders
            });
            resolve(response);
        } else {
            controller.enqueue(encoder.encode(formatter(index, string)));
        }
    };
    resolveHTTPResponse.resolveHTTPResponse({
        req,
        createContext,
        path,
        router: opts.router,
        batching: opts.batching,
        responseMeta: opts.responseMeta,
        onError (o) {
            opts?.onError?.({
                ...o,
                req: opts.req
            });
        },
        unstable_onHead,
        unstable_onChunk
    }).then(()=>{
        if (isStream) {
            controller.enqueue(encoder.encode(formatter.end()));
            controller.close();
        }
    }).catch(()=>{
        if (isStream) {
            controller.close();
        }
    });
    return promise;
}

exports.fetchRequestHandler = fetchRequestHandler;
