import {
  E,
  P,
  g,
  ie,
  le,
  ue
} from "./chunk-GAKOKVI7.js";
import {
  Ce,
  P as P2,
  R,
  S,
  a,
  b,
  c,
  f,
  g as g2,
  i,
  m,
  m2,
  o,
  r,
  r2,
  s,
  s2,
  x
} from "./chunk-KPE323GY.js";
import {
  I,
  N,
  O,
  Pt,
  require_browser
} from "./chunk-BUD4MBMR.js";
import {
  encodePacked,
  parseAbi,
  parseAbiParameters
} from "./chunk-BI4QVQKZ.js";
import {
  TransactionReceiptNotFoundError,
  concatHex,
  decodeAbiParameters,
  encodeAbiParameters,
  getAddress,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  isHex,
  padHex,
  size,
  sliceHex,
  stringToHex
} from "./chunk-FZ3KYLDH.js";
import {
  EMPTY,
  Observable,
  catchError,
  combineLatest,
  concat,
  concatMap,
  defer,
  filter,
  firstValueFrom,
  from,
  identity,
  map,
  mergeMap,
  of,
  pipe,
  scan,
  share,
  shareReplay,
  tap
} from "./chunk-ESXY76HE.js";
import {
  __publicField,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/TRPCError-6a1653a4.mjs
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function getTRPCErrorFromUnknown(cause) {
  if (cause instanceof TRPCError) {
    return cause;
  }
  const trpcError = new TRPCError({
    code: "INTERNAL_SERVER_ERROR",
    cause
  });
  if (cause instanceof Error && cause.stack) {
    trpcError.stack = cause.stack;
  }
  return trpcError;
}
var UnknownCauseError = class extends Error {
};
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type = typeof cause;
  if (type === "undefined" || type === "function" || cause === null) {
    return void 0;
  }
  if (type !== "object") {
    return new Error(String(cause));
  }
  if (isObject(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
var TRPCError = class extends Error {
  constructor(opts) {
    const cause = getCauseFromUnknown(opts.cause);
    const message = opts.message ?? (cause == null ? void 0 : cause.message) ?? opts.code;
    super(message, {
      cause
    });
    this.code = opts.code;
    this.name = this.constructor.name;
  }
};

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/codes-24aa1ce1.mjs
function invert(obj) {
  const newObj = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    const v2 = obj[key];
    newObj[v2] = key;
  }
  return newObj;
}
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  /**
  * Internal JSON-RPC error.
  */
  INTERNAL_SERVER_ERROR: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
var TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/index-044a193b.mjs
var TRPC_ERROR_CODES_BY_NUMBER2 = invert(TRPC_ERROR_CODES_BY_KEY);
var JSONRPC2_TO_HTTP_CODE = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  TIMEOUT: 408,
  CONFLICT: 409,
  CLIENT_CLOSED_REQUEST: 499,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  METHOD_NOT_SUPPORTED: 405,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429
};
function getStatusCodeFromKey(code) {
  return JSONRPC2_TO_HTTP_CODE[code] ?? 500;
}
function getHTTPStatusCodeFromError(error) {
  const { code } = error;
  return getStatusCodeFromKey(code);
}
var noop = () => {
};
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _2, args) {
      const isApply = path[path.length - 1] === "apply";
      return callback({
        args: isApply ? args.length >= 2 ? args[1] : [] : args,
        path: isApply ? path.slice(0, -1) : path
      });
    }
  });
  return proxy;
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
var createFlatProxy = (callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
};

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/config-7eddc5bb.mjs
function getDataTransformer(transformer) {
  if ("input" in transformer) {
    return transformer;
  }
  return {
    input: transformer,
    output: transformer
  };
}
var defaultTransformer = {
  _default: true,
  input: {
    serialize: (obj) => obj,
    deserialize: (obj) => obj
  },
  output: {
    serialize: (obj) => obj,
    deserialize: (obj) => obj
  }
};
var defaultFormatter = ({ shape }) => {
  return shape;
};
function omitPrototype(obj) {
  return Object.assign(/* @__PURE__ */ Object.create(null), obj);
}
var procedureTypes = [
  "query",
  "mutation",
  "subscription"
];
function isRouter(procedureOrRouter) {
  return "router" in procedureOrRouter._def;
}
var emptyRouter = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: defaultFormatter,
  transformer: defaultTransformer
};
var reservedWords = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function createRouterFactory(config) {
  return function createRouterInner(procedures) {
    const reservedWordsUsed = new Set(Object.keys(procedures).filter((v2) => reservedWords.includes(v2)));
    if (reservedWordsUsed.size > 0) {
      throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
    }
    const routerProcedures = omitPrototype({});
    function recursiveGetPaths(procedures2, path = "") {
      for (const [key, procedureOrRouter] of Object.entries(procedures2 ?? {})) {
        const newPath = `${path}${key}`;
        if (isRouter(procedureOrRouter)) {
          recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);
          continue;
        }
        if (routerProcedures[newPath]) {
          throw new Error(`Duplicate key: ${newPath}`);
        }
        routerProcedures[newPath] = procedureOrRouter;
      }
    }
    recursiveGetPaths(procedures);
    const _def = {
      _config: config,
      router: true,
      procedures: routerProcedures,
      ...emptyRouter,
      record: procedures,
      queries: Object.entries(routerProcedures).filter((pair) => pair[1]._def.query).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {}),
      mutations: Object.entries(routerProcedures).filter((pair) => pair[1]._def.mutation).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {}),
      subscriptions: Object.entries(routerProcedures).filter((pair) => pair[1]._def.subscription).reduce((acc, [key, val]) => ({
        ...acc,
        [key]: val
      }), {})
    };
    const router = {
      ...procedures,
      _def,
      createCaller(ctx) {
        const proxy = createRecursiveProxy(({ path, args }) => {
          if (path.length === 1 && procedureTypes.includes(path[0])) {
            return callProcedure({
              procedures: _def.procedures,
              path: args[0],
              rawInput: args[1],
              ctx,
              type: path[0]
            });
          }
          const fullPath = path.join(".");
          const procedure = _def.procedures[fullPath];
          let type = "query";
          if (procedure._def.mutation) {
            type = "mutation";
          } else if (procedure._def.subscription) {
            type = "subscription";
          }
          return procedure({
            path: fullPath,
            rawInput: args[0],
            ctx,
            type
          });
        });
        return proxy;
      },
      getErrorShape(opts) {
        const { path, error } = opts;
        const { code } = opts.error;
        const shape = {
          message: error.message,
          code: TRPC_ERROR_CODES_BY_KEY[code],
          data: {
            code,
            httpStatus: getHTTPStatusCodeFromError(error)
          }
        };
        if (config.isDev && typeof opts.error.stack === "string") {
          shape.data.stack = opts.error.stack;
        }
        if (typeof path === "string") {
          shape.data.path = path;
        }
        return this._def._config.errorFormatter({
          ...opts,
          shape
        });
      }
    };
    return router;
  };
}
function callProcedure(opts) {
  var _a2;
  const { type, path } = opts;
  if (!(path in opts.procedures) || !((_a2 = opts.procedures[path]) == null ? void 0 : _a2._def[type])) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: `No "${type}"-procedure on path "${path}"`
    });
  }
  const procedure = opts.procedures[path];
  return procedure(opts);
}
var _a, _b, _c, _d, _e, _f;
var isServerDefault = typeof window === "undefined" || "Deno" in window || ((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV) === "test" || !!((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d.JEST_WORKER_ID) || !!((_f = (_e = globalThis.process) == null ? void 0 : _e.env) == null ? void 0 : _f.VITEST_WORKER_ID);

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/index.mjs
function getParseFn(procedureParser) {
  const parser = procedureParser;
  if (typeof parser === "function") {
    return parser;
  }
  if (typeof parser.parseAsync === "function") {
    return parser.parseAsync.bind(parser);
  }
  if (typeof parser.parse === "function") {
    return parser.parse.bind(parser);
  }
  if (typeof parser.validateSync === "function") {
    return parser.validateSync.bind(parser);
  }
  if (typeof parser.create === "function") {
    return parser.create.bind(parser);
  }
  if (typeof parser.assert === "function") {
    return (value) => {
      parser.assert(value);
      return value;
    };
  }
  throw new Error("Could not find a validator fn");
}
function mergeWithoutOverrides(obj1, ...objs) {
  const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
  for (const overrides of objs) {
    for (const key in overrides) {
      if (key in newObj && newObj[key] !== overrides[key]) {
        throw new Error(`Duplicate key ${key}`);
      }
      newObj[key] = overrides[key];
    }
  }
  return newObj;
}
function createMiddlewareFactory() {
  function createMiddlewareInner(middlewares) {
    return {
      _middlewares: middlewares,
      unstable_pipe(middlewareBuilderOrFn) {
        const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
          middlewareBuilderOrFn
        ];
        return createMiddlewareInner([
          ...middlewares,
          ...pipedMiddleware
        ]);
      }
    };
  }
  function createMiddleware(fn) {
    return createMiddlewareInner([
      fn
    ]);
  }
  return createMiddleware;
}
function isPlainObject(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
}
function createInputMiddleware(parse2) {
  const inputMiddleware = async ({ next, rawInput, input }) => {
    let parsedInput;
    try {
      parsedInput = await parse2(rawInput);
    } catch (cause) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        cause
      });
    }
    const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {
      ...input,
      ...parsedInput
    } : parsedInput;
    return next({
      input: combinedInput
    });
  };
  inputMiddleware._type = "input";
  return inputMiddleware;
}
function createOutputMiddleware(parse2) {
  const outputMiddleware = async ({ next }) => {
    const result = await next();
    if (!result.ok) {
      return result;
    }
    try {
      const data = await parse2(result.data);
      return {
        ...result,
        data
      };
    } catch (cause) {
      throw new TRPCError({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause
      });
    }
  };
  outputMiddleware._type = "output";
  return outputMiddleware;
}
var middlewareMarker = "middlewareMarker";
function createNewBuilder(def1, def2) {
  const { middlewares = [], inputs, meta, ...rest } = def2;
  return createBuilder({
    ...mergeWithoutOverrides(def1, rest),
    inputs: [
      ...def1.inputs,
      ...inputs ?? []
    ],
    middlewares: [
      ...def1.middlewares,
      ...middlewares
    ],
    meta: def1.meta && meta ? {
      ...def1.meta,
      ...meta
    } : meta ?? def1.meta
  });
}
function createBuilder(initDef = {}) {
  const _def = {
    inputs: [],
    middlewares: [],
    ...initDef
  };
  return {
    _def,
    input(input) {
      const parser = getParseFn(input);
      return createNewBuilder(_def, {
        inputs: [
          input
        ],
        middlewares: [
          createInputMiddleware(parser)
        ]
      });
    },
    output(output) {
      const parseOutput = getParseFn(output);
      return createNewBuilder(_def, {
        output,
        middlewares: [
          createOutputMiddleware(parseOutput)
        ]
      });
    },
    meta(meta) {
      return createNewBuilder(_def, {
        meta
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(builder) {
      return createNewBuilder(_def, builder._def);
    },
    use(middlewareBuilderOrFn) {
      const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
        middlewareBuilderOrFn
      ];
      return createNewBuilder(_def, {
        middlewares
      });
    },
    query(resolver) {
      return createResolver({
        ..._def,
        query: true
      }, resolver);
    },
    mutation(resolver) {
      return createResolver({
        ..._def,
        mutation: true
      }, resolver);
    },
    subscription(resolver) {
      return createResolver({
        ..._def,
        subscription: true
      }, resolver);
    }
  };
}
function createResolver(_def, resolver) {
  const finalBuilder = createNewBuilder(_def, {
    resolver,
    middlewares: [
      async function resolveMiddleware(opts) {
        const data = await resolver(opts);
        return {
          marker: middlewareMarker,
          ok: true,
          data,
          ctx: opts.ctx
        };
      }
    ]
  });
  return createProcedureCaller(finalBuilder._def);
}
var codeblock = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function createProcedureCaller(_def) {
  const procedure = async function resolve(opts) {
    if (!opts || !("rawInput" in opts)) {
      throw new Error(codeblock);
    }
    const callRecursive = async (callOpts = {
      index: 0,
      ctx: opts.ctx
    }) => {
      try {
        const middleware = _def.middlewares[callOpts.index];
        const result2 = await middleware({
          ctx: callOpts.ctx,
          type: opts.type,
          path: opts.path,
          rawInput: callOpts.rawInput ?? opts.rawInput,
          meta: _def.meta,
          input: callOpts.input,
          next(_nextOpts) {
            const nextOpts = _nextOpts;
            return callRecursive({
              index: callOpts.index + 1,
              ctx: nextOpts && "ctx" in nextOpts ? {
                ...callOpts.ctx,
                ...nextOpts.ctx
              } : callOpts.ctx,
              input: nextOpts && "input" in nextOpts ? nextOpts.input : callOpts.input,
              rawInput: nextOpts && "rawInput" in nextOpts ? nextOpts.rawInput : callOpts.rawInput
            });
          }
        });
        return result2;
      } catch (cause) {
        return {
          ok: false,
          error: getTRPCErrorFromUnknown(cause),
          marker: middlewareMarker
        };
      }
    };
    const result = await callRecursive();
    if (!result) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    }
    if (!result.ok) {
      throw result.error;
    }
    return result.data;
  };
  procedure._def = _def;
  procedure.meta = _def.meta;
  return procedure;
}
function mergeRouters(...routerList) {
  var _a2;
  const record = mergeWithoutOverrides({}, ...routerList.map((r4) => r4._def.record));
  const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
    if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
      if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
        throw new Error("You seem to have several error formatters");
      }
      return nextRouter._def._config.errorFormatter;
    }
    return currentErrorFormatter;
  }, defaultFormatter);
  const transformer = routerList.reduce((prev, current) => {
    if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
      if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
        throw new Error("You seem to have several transformers");
      }
      return current._def._config.transformer;
    }
    return prev;
  }, defaultTransformer);
  const router = createRouterFactory({
    errorFormatter,
    transformer,
    isDev: routerList.some((r4) => r4._def._config.isDev),
    allowOutsideOfServer: routerList.some((r4) => r4._def._config.allowOutsideOfServer),
    isServer: routerList.some((r4) => r4._def._config.isServer),
    $types: (_a2 = routerList[0]) == null ? void 0 : _a2._def._config.$types
  })(record);
  return router;
}
var TRPCBuilder = class _TRPCBuilder {
  context() {
    return new _TRPCBuilder();
  }
  meta() {
    return new _TRPCBuilder();
  }
  create(options) {
    return createTRPCInner()(options);
  }
};
var initTRPC = new TRPCBuilder();
function createTRPCInner() {
  return function initTRPCInner(runtime) {
    var _a2, _b2;
    const errorFormatter = (runtime == null ? void 0 : runtime.errorFormatter) ?? defaultFormatter;
    const transformer = getDataTransformer((runtime == null ? void 0 : runtime.transformer) ?? defaultTransformer);
    const config = {
      transformer,
      isDev: (runtime == null ? void 0 : runtime.isDev) ?? ((_b2 = (_a2 = globalThis.process) == null ? void 0 : _a2.env) == null ? void 0 : _b2.NODE_ENV) !== "production",
      allowOutsideOfServer: (runtime == null ? void 0 : runtime.allowOutsideOfServer) ?? false,
      errorFormatter,
      isServer: (runtime == null ? void 0 : runtime.isServer) ?? isServerDefault,
      /**
      * @internal
      */
      $types: createFlatProxy((key) => {
        throw new Error(`Tried to access "$types.${key}" which is not available at runtime`);
      })
    };
    {
      const isServer = (runtime == null ? void 0 : runtime.isServer) ?? isServerDefault;
      if (!isServer && (runtime == null ? void 0 : runtime.allowOutsideOfServer) !== true) {
        throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
      }
    }
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: config,
      /**
      * Builder object for creating procedures
      */
      procedure: createBuilder({
        meta: runtime == null ? void 0 : runtime.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: createMiddlewareFactory(),
      /**
      * Create a router
      */
      router: createRouterFactory(config),
      /**
      * Merge Routers
      */
      mergeRouters
    };
  };
}

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/double-indexed-kv.js
var DoubleIndexedKV = (
  /** @class */
  function() {
    function DoubleIndexedKV2() {
      this.keyToValue = /* @__PURE__ */ new Map();
      this.valueToKey = /* @__PURE__ */ new Map();
    }
    DoubleIndexedKV2.prototype.set = function(key, value) {
      this.keyToValue.set(key, value);
      this.valueToKey.set(value, key);
    };
    DoubleIndexedKV2.prototype.getByKey = function(key) {
      return this.keyToValue.get(key);
    };
    DoubleIndexedKV2.prototype.getByValue = function(value) {
      return this.valueToKey.get(value);
    };
    DoubleIndexedKV2.prototype.clear = function() {
      this.keyToValue.clear();
      this.valueToKey.clear();
    };
    return DoubleIndexedKV2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/registry.js
var Registry = (
  /** @class */
  function() {
    function Registry2(generateIdentifier) {
      this.generateIdentifier = generateIdentifier;
      this.kv = new DoubleIndexedKV();
    }
    Registry2.prototype.register = function(value, identifier) {
      if (this.kv.getByValue(value)) {
        return;
      }
      if (!identifier) {
        identifier = this.generateIdentifier(value);
      }
      this.kv.set(identifier, value);
    };
    Registry2.prototype.clear = function() {
      this.kv.clear();
    };
    Registry2.prototype.getIdentifier = function(value) {
      return this.kv.getByValue(value);
    };
    Registry2.prototype.getValue = function(identifier) {
      return this.kv.getByKey(identifier);
    };
    return Registry2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/class-registry.js
var __extends = function() {
  var extendStatics = function(d, b3) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b4) {
      d2.__proto__ = b4;
    } || function(d2, b4) {
      for (var p3 in b4)
        if (Object.prototype.hasOwnProperty.call(b4, p3))
          d2[p3] = b4[p3];
    };
    return extendStatics(d, b3);
  };
  return function(d, b3) {
    if (typeof b3 !== "function" && b3 !== null)
      throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
    extendStatics(d, b3);
    function __() {
      this.constructor = d;
    }
    d.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  };
}();
var ClassRegistry = (
  /** @class */
  function(_super) {
    __extends(ClassRegistry2, _super);
    function ClassRegistry2() {
      var _this = _super.call(this, function(c3) {
        return c3.name;
      }) || this;
      _this.classToAllowedProps = /* @__PURE__ */ new Map();
      return _this;
    }
    ClassRegistry2.prototype.register = function(value, options) {
      if (typeof options === "object") {
        if (options.allowProps) {
          this.classToAllowedProps.set(value, options.allowProps);
        }
        _super.prototype.register.call(this, value, options.identifier);
      } else {
        _super.prototype.register.call(this, value, options);
      }
    };
    ClassRegistry2.prototype.getAllowedProps = function(value) {
      return this.classToAllowedProps.get(value);
    };
    return ClassRegistry2;
  }(Registry)
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/util.js
var __read = function(o3, n) {
  var m4 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m4)
    return o3;
  var i2 = m4.call(o3), r4, ar = [], e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r4 = i2.next()).done)
      ar.push(r4.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r4 && !r4.done && (m4 = i2["return"]))
        m4.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  var values = [];
  for (var key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  var values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  var valuesNotNever = values;
  for (var i2 = 0; i2 < valuesNotNever.length; i2++) {
    var value = valuesNotNever[i2];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(function(_a2) {
    var _b2 = __read(_a2, 2), key = _b2[0], value = _b2[1];
    return run(value, key);
  });
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (var i2 = 0; i2 < record.length; i2++) {
    var value = record[i2];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/custom-transformer-registry.js
var CustomTransformerRegistry = (
  /** @class */
  function() {
    function CustomTransformerRegistry2() {
      this.transfomers = {};
    }
    CustomTransformerRegistry2.prototype.register = function(transformer) {
      this.transfomers[transformer.name] = transformer;
    };
    CustomTransformerRegistry2.prototype.findApplicable = function(v2) {
      return find(this.transfomers, function(transformer) {
        return transformer.isApplicable(v2);
      });
    };
    CustomTransformerRegistry2.prototype.findByName = function(name) {
      return this.transfomers[name];
    };
    return CustomTransformerRegistry2;
  }()
);

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/is.js
var getType = function(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
};
var isUndefined = function(payload) {
  return typeof payload === "undefined";
};
var isNull = function(payload) {
  return payload === null;
};
var isPlainObject2 = function(payload) {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = function(payload) {
  return isPlainObject2(payload) && Object.keys(payload).length === 0;
};
var isArray = function(payload) {
  return Array.isArray(payload);
};
var isString = function(payload) {
  return typeof payload === "string";
};
var isNumber = function(payload) {
  return typeof payload === "number" && !isNaN(payload);
};
var isBoolean = function(payload) {
  return typeof payload === "boolean";
};
var isRegExp = function(payload) {
  return payload instanceof RegExp;
};
var isMap = function(payload) {
  return payload instanceof Map;
};
var isSet = function(payload) {
  return payload instanceof Set;
};
var isSymbol = function(payload) {
  return getType(payload) === "Symbol";
};
var isDate = function(payload) {
  return payload instanceof Date && !isNaN(payload.valueOf());
};
var isError = function(payload) {
  return payload instanceof Error;
};
var isNaNValue = function(payload) {
  return typeof payload === "number" && isNaN(payload);
};
var isPrimitive = function(payload) {
  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
};
var isBigint = function(payload) {
  return typeof payload === "bigint";
};
var isInfinite = function(payload) {
  return payload === Infinity || payload === -Infinity;
};
var isTypedArray = function(payload) {
  return ArrayBuffer.isView(payload) && !(payload instanceof DataView);
};
var isURL = function(payload) {
  return payload instanceof URL;
};

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/pathstringifier.js
var escapeKey = function(key) {
  return key.replace(/\./g, "\\.");
};
var stringifyPath = function(path) {
  return path.map(String).map(escapeKey).join(".");
};
var parsePath = function(string) {
  var result = [];
  var segment = "";
  for (var i2 = 0; i2 < string.length; i2++) {
    var char = string.charAt(i2);
    var isEscapedDot = char === "\\" && string.charAt(i2 + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i2++;
      continue;
    }
    var isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  var lastSegment = segment;
  result.push(lastSegment);
  return result;
};

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/transformer.js
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s5, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s5 = arguments[i2];
      for (var p3 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p3))
          t2[p3] = s5[p3];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __read2 = function(o3, n) {
  var m4 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m4)
    return o3;
  var i2 = m4.call(o3), r4, ar = [], e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r4 = i2.next()).done)
      ar.push(r4.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r4 && !r4.done && (m4 = i2["return"]))
        m4.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from2) {
  for (var i2 = 0, il = from2.length, j3 = to.length; i2 < il; i2++, j3++)
    to[j3] = from2[i2];
  return to;
};
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", function() {
    return null;
  }, function() {
    return void 0;
  }),
  simpleTransformation(isBigint, "bigint", function(v2) {
    return v2.toString();
  }, function(v2) {
    if (typeof BigInt !== "undefined") {
      return BigInt(v2);
    }
    console.error("Please add a BigInt polyfill.");
    return v2;
  }),
  simpleTransformation(isDate, "Date", function(v2) {
    return v2.toISOString();
  }, function(v2) {
    return new Date(v2);
  }),
  simpleTransformation(isError, "Error", function(v2, superJson) {
    var baseError = {
      name: v2.name,
      message: v2.message
    };
    superJson.allowedErrorProps.forEach(function(prop) {
      baseError[prop] = v2[prop];
    });
    return baseError;
  }, function(v2, superJson) {
    var e2 = new Error(v2.message);
    e2.name = v2.name;
    e2.stack = v2.stack;
    superJson.allowedErrorProps.forEach(function(prop) {
      e2[prop] = v2[prop];
    });
    return e2;
  }),
  simpleTransformation(isRegExp, "regexp", function(v2) {
    return "" + v2;
  }, function(regex) {
    var body = regex.slice(1, regex.lastIndexOf("/"));
    var flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    function(v2) {
      return __spreadArray([], __read2(v2.values()));
    },
    function(v2) {
      return new Set(v2);
    }
  ),
  simpleTransformation(isMap, "map", function(v2) {
    return __spreadArray([], __read2(v2.entries()));
  }, function(v2) {
    return new Map(v2);
  }),
  simpleTransformation(function(v2) {
    return isNaNValue(v2) || isInfinite(v2);
  }, "number", function(v2) {
    if (isNaNValue(v2)) {
      return "NaN";
    }
    if (v2 > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation(function(v2) {
    return v2 === 0 && 1 / v2 === -Infinity;
  }, "number", function() {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", function(v2) {
    return v2.toString();
  }, function(v2) {
    return new URL(v2);
  })
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation(function(s5, superJson) {
  if (isSymbol(s5)) {
    var isRegistered = !!superJson.symbolRegistry.getIdentifier(s5);
    return isRegistered;
  }
  return false;
}, function(s5, superJson) {
  var identifier = superJson.symbolRegistry.getIdentifier(s5);
  return ["symbol", identifier];
}, function(v2) {
  return v2.description;
}, function(_, a3, superJson) {
  var value = superJson.symbolRegistry.getValue(a3[1]);
  if (!value) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce(function(obj, ctor) {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, function(v2) {
  return ["typed-array", v2.constructor.name];
}, function(v2) {
  return __spreadArray([], __read2(v2));
}, function(v2, a3) {
  var ctor = constructorToName[a3[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v2);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {
    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, function(clazz, superJson) {
  var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, function(clazz, superJson) {
  var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return __assign({}, clazz);
  }
  var result = {};
  allowedProps.forEach(function(prop) {
    result[prop] = clazz[prop];
  });
  return result;
}, function(v2, a3, superJson) {
  var clazz = superJson.classRegistry.getValue(a3[1]);
  if (!clazz) {
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  }
  return Object.assign(Object.create(clazz.prototype), v2);
});
var customRule = compositeTransformation(function(value, superJson) {
  return !!superJson.customTransformerRegistry.findApplicable(value);
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return ["custom", transformer.name];
}, function(value, superJson) {
  var transformer = superJson.customTransformerRegistry.findApplicable(value);
  return transformer.serialize(value);
}, function(v2, a3, superJson) {
  var transformer = superJson.customTransformerRegistry.findByName(a3[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v2);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = function(value, superJson) {
  var applicableCompositeRule = findArr(compositeRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value, superJson),
      type: applicableCompositeRule.annotation(value, superJson)
    };
  }
  var applicableSimpleRule = findArr(simpleRules, function(rule) {
    return rule.isApplicable(value, superJson);
  });
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach(function(rule) {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = function(json, type, superJson) {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    var transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/accessDeep.js
var getNthKey = function(value, n) {
  var keys = value.keys();
  while (n > 0) {
    keys.next();
    n--;
  }
  return keys.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = function(object, path) {
  validatePath(path);
  for (var i2 = 0; i2 < path.length; i2++) {
    var key = path[i2];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      var row = +key;
      var type = +path[++i2] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
var setDeep = function(object, path, mapper) {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  var parent = object;
  for (var i2 = 0; i2 < path.length - 1; i2++) {
    var key = path[i2];
    if (isArray(parent)) {
      var index = +key;
      parent = parent[index];
    } else if (isPlainObject2(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      var row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      var isEnd = i2 === path.length - 2;
      if (isEnd) {
        break;
      }
      var row = +key;
      var type = +path[++i2] === 0 ? "key" : "value";
      var keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  var lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject2(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    var oldValue = getNthKey(parent, +lastKey);
    var newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent["delete"](oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    var row = +path[path.length - 2];
    var keyToRow = getNthKey(parent, row);
    var type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        var newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent["delete"](keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/plainer.js
var __read3 = function(o3, n) {
  var m4 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m4)
    return o3;
  var i2 = m4.call(o3), r4, ar = [], e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r4 = i2.next()).done)
      ar.push(r4.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r4 && !r4.done && (m4 = i2["return"]))
        m4.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from2) {
  for (var i2 = 0, il = from2.length, j3 = to.length; i2 < il; i2++, j3++)
    to[j3] = from2[i2];
  return to;
};
function traverse(tree, walker2, origin) {
  if (origin === void 0) {
    origin = [];
  }
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, function(subtree, key) {
      return traverse(subtree, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
    return;
  }
  var _a2 = __read3(tree, 2), nodeValue = _a2[0], children = _a2[1];
  if (children) {
    forEach(children, function(child, key) {
      traverse(child, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, function(type, path) {
    plain = setDeep(plain, path, function(v2) {
      return untransformValue(v2, type, superJson);
    });
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    var object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach(function(identicalObjectPath) {
      plain = setDeep(plain, identicalObjectPath, function() {
        return object;
      });
    });
  }
  if (isArray(annotations)) {
    var _a2 = __read3(annotations, 2), root = _a2[0], other = _a2[1];
    root.forEach(function(identicalPath) {
      plain = setDeep(plain, parsePath(identicalPath), function() {
        return plain;
      });
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = function(object, superJson) {
  return isPlainObject2(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
};
function addIdentity(object, path, identities) {
  var existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  var result = {};
  var rootEqualityPaths = void 0;
  identitites.forEach(function(paths) {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map(function(path) {
        return path.map(String);
      }).sort(function(a3, b3) {
        return a3.length - b3.length;
      });
    }
    var _a2 = __read3(paths), representativePath = _a2[0], identicalPaths = _a2.slice(1);
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var walker = function(object, identities, superJson, dedupe, path, objectsInThisPath, seenObjects) {
  var _a2;
  if (path === void 0) {
    path = [];
  }
  if (objectsInThisPath === void 0) {
    objectsInThisPath = [];
  }
  if (seenObjects === void 0) {
    seenObjects = /* @__PURE__ */ new Map();
  }
  var primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    var seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    var transformed_1 = transformValue(object, superJson);
    var result_1 = transformed_1 ? {
      transformedValue: transformed_1.value,
      annotations: [transformed_1.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result_1);
    }
    return result_1;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  var transformationResult = transformValue(object, superJson);
  var transformed = (_a2 = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a2 !== void 0 ? _a2 : object;
  var transformedValue = isArray(transformed) ? [] : {};
  var innerAnnotations = {};
  forEach(transformed, function(value, index) {
    var recursiveResult = walker(value, identities, superJson, dedupe, __spreadArray2(__spreadArray2([], __read3(path)), [index]), __spreadArray2(__spreadArray2([], __read3(objectsInThisPath)), [object]), seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject2(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, function(tree, key) {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  var result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};

// ../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject3(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a3, b3, c3, d, e2) {
  return (value) => a3(value) || b3(value) || !!c3 && c3(value) || !!d && d(value) || !!e2 && e2(value);
}
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
var isNullOrUndefined = isOneOf(isNull2, isUndefined2);

// ../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject3(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}

// ../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/dist/esm/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t2) {
    for (var s5, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s5 = arguments[i2];
      for (var p3 in s5)
        if (Object.prototype.hasOwnProperty.call(s5, p3))
          t2[p3] = s5[p3];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
var __read4 = function(o3, n) {
  var m4 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m4)
    return o3;
  var i2 = m4.call(o3), r4, ar = [], e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r4 = i2.next()).done)
      ar.push(r4.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r4 && !r4.done && (m4 = i2["return"]))
        m4.call(i2);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from2) {
  for (var i2 = 0, il = from2.length, j3 = to.length; i2 < il; i2++, j3++)
    to[j3] = from2[i2];
  return to;
};
var SuperJSON = (
  /** @class */
  function() {
    function SuperJSON2(_a2) {
      var _b2 = _a2 === void 0 ? {} : _a2, _c2 = _b2.dedupe, dedupe = _c2 === void 0 ? false : _c2;
      this.classRegistry = new ClassRegistry();
      this.symbolRegistry = new Registry(function(s5) {
        var _a3;
        return (_a3 = s5.description) !== null && _a3 !== void 0 ? _a3 : "";
      });
      this.customTransformerRegistry = new CustomTransformerRegistry();
      this.allowedErrorProps = [];
      this.dedupe = dedupe;
    }
    SuperJSON2.prototype.serialize = function(object) {
      var identities = /* @__PURE__ */ new Map();
      var output = walker(object, identities, this, this.dedupe);
      var res = {
        json: output.transformedValue
      };
      if (output.annotations) {
        res.meta = __assign2(__assign2({}, res.meta), { values: output.annotations });
      }
      var equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
      if (equalityAnnotations) {
        res.meta = __assign2(__assign2({}, res.meta), { referentialEqualities: equalityAnnotations });
      }
      return res;
    };
    SuperJSON2.prototype.deserialize = function(payload) {
      var json = payload.json, meta = payload.meta;
      var result = copy(json);
      if (meta === null || meta === void 0 ? void 0 : meta.values) {
        result = applyValueAnnotations(result, meta.values, this);
      }
      if (meta === null || meta === void 0 ? void 0 : meta.referentialEqualities) {
        result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
      }
      return result;
    };
    SuperJSON2.prototype.stringify = function(object) {
      return JSON.stringify(this.serialize(object));
    };
    SuperJSON2.prototype.parse = function(string) {
      return this.deserialize(JSON.parse(string));
    };
    SuperJSON2.prototype.registerClass = function(v2, options) {
      this.classRegistry.register(v2, options);
    };
    SuperJSON2.prototype.registerSymbol = function(v2, identifier) {
      this.symbolRegistry.register(v2, identifier);
    };
    SuperJSON2.prototype.registerCustom = function(transformer, name) {
      this.customTransformerRegistry.register(__assign2({ name }, transformer));
    };
    SuperJSON2.prototype.allowErrorProps = function() {
      var _a2;
      var props = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        props[_i] = arguments[_i];
      }
      (_a2 = this.allowedErrorProps).push.apply(_a2, __spreadArray3([], __read4(props)));
    };
    SuperJSON2.defaultInstance = new SuperJSON2();
    SuperJSON2.serialize = SuperJSON2.defaultInstance.serialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.deserialize = SuperJSON2.defaultInstance.deserialize.bind(SuperJSON2.defaultInstance);
    SuperJSON2.stringify = SuperJSON2.defaultInstance.stringify.bind(SuperJSON2.defaultInstance);
    SuperJSON2.parse = SuperJSON2.defaultInstance.parse.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerClass = SuperJSON2.defaultInstance.registerClass.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerSymbol = SuperJSON2.defaultInstance.registerSymbol.bind(SuperJSON2.defaultInstance);
    SuperJSON2.registerCustom = SuperJSON2.defaultInstance.registerCustom.bind(SuperJSON2.defaultInstance);
    SuperJSON2.allowErrorProps = SuperJSON2.defaultInstance.allowErrorProps.bind(SuperJSON2.defaultInstance);
    return SuperJSON2;
  }()
);
var esm_default = SuperJSON;
var serialize = SuperJSON.serialize;
var deserialize = SuperJSON.deserialize;
var stringify = SuperJSON.stringify;
var parse = SuperJSON.parse;
var registerClass = SuperJSON.registerClass;
var registerCustom = SuperJSON.registerCustom;
var registerSymbol = SuperJSON.registerSymbol;
var allowErrorProps = SuperJSON.allowErrorProps;

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity2(x3) {
  return x3;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity2;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          var _a2;
          if (isDone) {
            return;
          }
          (_a2 = observer.next) == null ? void 0 : _a2.call(observer, value);
        },
        error(err) {
          var _a2;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a2 = observer.error) == null ? void 0 : _a2.call(observer, err);
          unsubscribe();
        },
        complete() {
          var _a2;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a2 = observer.complete) == null ? void 0 : _a2.call(observer);
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self);
    }
  };
  return self;
}

// ../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/observable/index.mjs
function share2(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          var _a2;
          for (const observer of observers) {
            (_a2 = observer.next) == null ? void 0 : _a2.call(observer, value);
          }
        },
        error(error) {
          var _a2;
          for (const observer of observers) {
            (_a2 = observer.error) == null ? void 0 : _a2.call(observer, error);
          }
        },
        complete() {
          var _a2;
          for (const observer of observers) {
            (_a2 = observer.complete) == null ? void 0 : _a2.call(observer);
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v2) => v2 === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
var ObservableAbortError = class _ObservableAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, _ObservableAbortError.prototype);
  }
};
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/TRPCClientError-fef6cf44.mjs
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause.name === "TRPCClientError";
}
var TRPCClientError = class _TRPCClientError extends Error {
  static from(cause, opts = {}) {
    if (!(cause instanceof Error)) {
      return new _TRPCClientError(cause.error.message ?? "", {
        ...opts,
        cause: void 0,
        result: cause
      });
    }
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    return new _TRPCClientError(cause.message, {
      ...opts,
      cause,
      result: null
    });
  }
  constructor(message, opts) {
    var _a2, _b2;
    const cause = opts == null ? void 0 : opts.cause;
    super(message, {
      cause
    });
    this.meta = opts == null ? void 0 : opts.meta;
    this.cause = cause;
    this.shape = (_a2 = opts == null ? void 0 : opts.result) == null ? void 0 : _a2.error;
    this.data = (_b2 = opts == null ? void 0 : opts.result) == null ? void 0 : _b2.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/httpUtils-1efcb902.mjs
var isFunction = (fn) => typeof fn === "function";
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return window.fetch;
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return globalThis.fetch;
  }
  throw new Error("No fetch implementation found");
}
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts) {
  return {
    url: opts.url,
    fetch: opts.fetch,
    AbortController: getAbortController(opts.AbortController)
  };
}
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
var getUrl = (opts) => {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
};
var getBody = (opts) => {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
};
var jsonHttpRequester = (opts) => {
  return httpRequest({
    ...opts,
    contentTypeHeader: "application/json",
    getUrl,
    getBody
  });
};
async function fetchHTTPResponse(opts, ac) {
  const url = opts.getUrl(opts);
  const body = opts.getBody(opts);
  const { type } = opts;
  const resolvedHeaders = await opts.headers();
  if (type === "subscription") {
    throw new Error("Subscriptions should use wsLink");
  }
  const headers = {
    ...opts.contentTypeHeader ? {
      "content-type": opts.contentTypeHeader
    } : {},
    ...opts.batchModeHeader ? {
      "trpc-batch-mode": opts.batchModeHeader
    } : {},
    ...resolvedHeaders
  };
  return getFetch(opts.fetch)(url, {
    method: METHOD[type],
    signal: ac == null ? void 0 : ac.signal,
    body,
    headers
  });
}
function httpRequest(opts) {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const meta = {};
  const promise = new Promise((resolve, reject) => {
    fetchHTTPResponse(opts, ac).then((_res) => {
      meta.response = _res;
      return _res.json();
    }).then((json) => {
      meta.responseJSON = json;
      resolve({
        json,
        meta
      });
    }).catch((err) => {
      reject(TRPCClientError.from(err, {
        meta
      }));
    });
  });
  const cancel = () => {
    ac == null ? void 0 : ac.abort();
  };
  return {
    promise,
    cancel
  };
}

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/transformResult-7ab522e6.mjs
function isObject2(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
var TransformResultError = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TransformResultError();
  }
  if (!result.ok && (!isObject2(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TransformResultError();
  }
  if (result.ok && !isObject2(result.result)) {
    throw new TransformResultError();
  }
  return result;
}

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/httpBatchLink-fbd7b43c.mjs
var throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items) {
    var _a2, _b2;
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        (_a2 = item.reject) == null ? void 0 : _a2.call(item, new Error("Aborted"));
        index++;
        continue;
      }
      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        (_b2 = item.reject) == null ? void 0 : _b2.call(item, new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const unitResolver = (index, value) => {
        var _a2;
        const item = batch.items[index];
        (_a2 = item.resolve) == null ? void 0 : _a2.call(item, value);
        item.batch = null;
        item.reject = null;
        item.resolve = null;
      };
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key), unitResolver);
      batch.cancel = cancel;
      promise.then((result) => {
        var _a2;
        for (let i2 = 0; i2 < result.length; i2++) {
          const value = result[i2];
          unitResolver(i2, value);
        }
        for (const item of batch.items) {
          (_a2 = item.reject) == null ? void 0 : _a2.call(item, new Error("Missing result"));
          item.batch = null;
        }
      }).catch((cause) => {
        var _a2;
        for (const item of batch.items) {
          (_a2 = item.reject) == null ? void 0 : _a2.call(item, cause);
          item.batch = null;
        }
      });
    }
  }
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      var _a2;
      item.aborted = true;
      if ((_a2 = item.batch) == null ? void 0 : _a2.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise,
      cancel
    };
  }
  return {
    load
  };
}
function createHTTPBatchLink(requester) {
  return function httpBatchLink2(opts) {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    const maxURLLength = opts.maxURLLength ?? Infinity;
    return (runtime) => {
      const batchLoader = (type) => {
        const validate = (batchOps) => {
          if (maxURLLength === Infinity) {
            return true;
          }
          const path = batchOps.map((op) => op.path).join(",");
          const inputs = batchOps.map((op) => op.input);
          const url = getUrl({
            ...resolvedOpts,
            runtime,
            type,
            path,
            inputs
          });
          return url.length <= maxURLLength;
        };
        const fetch = requester({
          ...resolvedOpts,
          runtime,
          type,
          opts
        });
        return {
          validate,
          fetch
        };
      };
      const query = dataLoader(batchLoader("query"));
      const mutation = dataLoader(batchLoader("mutation"));
      const subscription = dataLoader(batchLoader("subscription"));
      const loaders = {
        query,
        subscription,
        mutation
      };
      return ({ op }) => {
        return observable((observer) => {
          const loader = loaders[op.type];
          const { promise, cancel } = loader.load(op);
          let _res = void 0;
          promise.then((res) => {
            _res = res;
            const transformed = transformResult(res.json, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error, {
                meta: res.meta
              }));
              return;
            }
            observer.next({
              context: res.meta,
              result: transformed.result
            });
            observer.complete();
          }).catch((err) => {
            observer.error(TRPCClientError.from(err, {
              meta: _res == null ? void 0 : _res.meta
            }));
          });
          return () => {
            cancel();
          };
        });
      };
    };
  };
}
var batchRequester = (requesterOpts) => {
  return (batchOps) => {
    const path = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { promise, cancel } = jsonHttpRequester({
      ...requesterOpts,
      path,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    });
    return {
      promise: promise.then((res) => {
        const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
        const result = resJSON.map((item) => ({
          meta: res.meta,
          json: item
        }));
        return result;
      }),
      cancel
    };
  };
};
var httpBatchLink = createHTTPBatchLink(batchRequester);

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLinkFactory(factoryOpts) {
  return (opts) => {
    const resolvedOpts = resolveHTTPLinkOptions(opts);
    return (runtime) => ({ op }) => observable((observer) => {
      const { path, input, type } = op;
      const { promise, cancel } = factoryOpts.requester({
        ...resolvedOpts,
        runtime,
        type,
        path,
        input,
        headers() {
          if (!opts.headers) {
            return {};
          }
          if (typeof opts.headers === "function") {
            return opts.headers({
              op
            });
          }
          return opts.headers;
        }
      });
      let meta = void 0;
      promise.then((res) => {
        meta = res.meta;
        const transformed = transformResult(res.json, runtime);
        if (!transformed.ok) {
          observer.error(TRPCClientError.from(transformed.error, {
            meta
          }));
          return;
        }
        observer.next({
          context: res.meta,
          result: transformed.result
        });
        observer.complete();
      }).catch((cause) => {
        observer.error(TRPCClientError.from(cause, {
          meta
        }));
      });
      return () => {
        cancel();
      };
    });
  };
}
var httpLink = httpLinkFactory({
  requester: jsonHttpRequester
});

// ../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/index.mjs
var TRPCUntypedClient = class {
  $request({ type, input, path, context = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path,
        input,
        context
      }
    });
    return chain$.pipe(share2());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      var _a2;
      (_a2 = opts.signal) == null ? void 0 : _a2.addEventListener("abort", abort);
      promise.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path,
      input,
      context: opts == null ? void 0 : opts.context,
      signal: opts == null ? void 0 : opts.signal
    });
  }
  mutation(path, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path,
      input,
      context: opts == null ? void 0 : opts.context,
      signal: opts == null ? void 0 : opts.signal
    });
  }
  subscription(path, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path,
      input,
      context: opts == null ? void 0 : opts.context
    });
    return observable$.subscribe({
      next(envelope) {
        var _a2, _b2, _c2;
        if (envelope.result.type === "started") {
          (_a2 = opts.onStarted) == null ? void 0 : _a2.call(opts);
        } else if (envelope.result.type === "stopped") {
          (_b2 = opts.onStopped) == null ? void 0 : _b2.call(opts);
        } else {
          (_c2 = opts.onData) == null ? void 0 : _c2.call(opts, envelope.result.data);
        }
      },
      error(err) {
        var _a2;
        (_a2 = opts.onError) == null ? void 0 : _a2.call(opts, err);
      },
      complete() {
        var _a2;
        (_a2 = opts.onComplete) == null ? void 0 : _a2.call(opts);
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    const combinedTransformer = (() => {
      const transformer = opts.transformer;
      if (!transformer) {
        return {
          input: {
            serialize: (data) => data,
            deserialize: (data) => data
          },
          output: {
            serialize: (data) => data,
            deserialize: (data) => data
          }
        };
      }
      if ("input" in transformer) {
        return opts.transformer;
      }
      return {
        input: transformer,
        output: transformer
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (data) => combinedTransformer.input.serialize(data),
        deserialize: (data) => combinedTransformer.output.deserialize(data)
      },
      combinedTransformer
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var clientCallTypeToProcedureType = (clientCallType) => {
  return clientCallTypeMap[clientCallType];
};
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    if (key === "__untypedClient") {
      return client;
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const procedureType = clientCallTypeToProcedureType(pathCopy.pop());
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}
function getTextDecoder(customTextDecoder) {
  if (customTextDecoder) {
    return customTextDecoder;
  }
  if (typeof window !== "undefined" && window.TextDecoder) {
    return new window.TextDecoder();
  }
  if (typeof globalThis !== "undefined" && globalThis.TextDecoder) {
    return new globalThis.TextDecoder();
  }
  throw new Error("No TextDecoder implementation found");
}
async function parseJSONStream(opts) {
  const parse2 = opts.parse ?? JSON.parse;
  const onLine = (line) => {
    var _a2;
    if ((_a2 = opts.signal) == null ? void 0 : _a2.aborted)
      return;
    if (!line || line === "}") {
      return;
    }
    const indexOfColon = line.indexOf(":");
    const indexAsStr = line.substring(2, indexOfColon - 1);
    const text = line.substring(indexOfColon + 1);
    opts.onSingle(Number(indexAsStr), parse2(text));
  };
  await readLines(opts.readableStream, onLine, opts.textDecoder);
}
async function readLines(readableStream, onLine, textDecoder) {
  let partOfLine = "";
  const onChunk = (chunk) => {
    const chunkText = textDecoder.decode(chunk);
    const chunkLines = chunkText.split("\n");
    if (chunkLines.length === 1) {
      partOfLine += chunkLines[0];
    } else if (chunkLines.length > 1) {
      onLine(partOfLine + chunkLines[0]);
      for (let i2 = 1; i2 < chunkLines.length - 1; i2++) {
        onLine(chunkLines[i2]);
      }
      partOfLine = chunkLines[chunkLines.length - 1];
    }
  };
  if ("getReader" in readableStream) {
    await readStandardChunks(readableStream, onChunk);
  } else {
    await readNodeChunks(readableStream, onChunk);
  }
  onLine(partOfLine);
}
function readNodeChunks(stream, onChunk) {
  return new Promise((resolve) => {
    stream.on("data", onChunk);
    stream.on("end", resolve);
  });
}
async function readStandardChunks(stream, onChunk) {
  const reader = stream.getReader();
  let readResult = await reader.read();
  while (!readResult.done) {
    onChunk(readResult.value);
    readResult = await reader.read();
  }
}
var streamingJsonHttpRequester = (opts, onSingle) => {
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const responsePromise = fetchHTTPResponse({
    ...opts,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl,
    getBody
  }, ac);
  const cancel = () => ac == null ? void 0 : ac.abort();
  const promise = responsePromise.then(async (res) => {
    if (!res.body)
      throw new Error("Received response without body");
    const meta = {
      response: res
    };
    return parseJSONStream({
      readableStream: res.body,
      onSingle,
      parse: (string) => ({
        json: JSON.parse(string),
        meta
      }),
      signal: ac == null ? void 0 : ac.signal,
      textDecoder: opts.textDecoder
    });
  });
  return {
    cancel,
    promise
  };
};
var streamRequester = (requesterOpts) => {
  const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);
  return (batchOps, unitResolver) => {
    const path = batchOps.map((op) => op.path).join(",");
    const inputs = batchOps.map((op) => op.input);
    const { cancel, promise } = streamingJsonHttpRequester({
      ...requesterOpts,
      textDecoder,
      path,
      inputs,
      headers() {
        if (!requesterOpts.opts.headers) {
          return {};
        }
        if (typeof requesterOpts.opts.headers === "function") {
          return requesterOpts.opts.headers({
            opList: batchOps
          });
        }
        return requesterOpts.opts.headers;
      }
    }, (index, res) => {
      unitResolver(index, res);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: promise.then(() => []),
      cancel
    };
  };
};
var unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);
var getBody2 = (opts) => {
  if (!("input" in opts)) {
    return void 0;
  }
  if (!(opts.input instanceof FormData)) {
    throw new Error("Input is not FormData");
  }
  return opts.input;
};
var formDataRequester = (opts) => {
  if (opts.type !== "mutation") {
    throw new Error("We only handle mutations with formdata");
  }
  return httpRequest({
    ...opts,
    getUrl() {
      return `${opts.url}/${opts.path}`;
    },
    getBody: getBody2
  });
};
var experimental_formDataLink = httpLinkFactory({
  requester: formDataRequester
});

// ../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/dist/chunk-5D4GTPIW.js
function T({ url: e2 }) {
  return createTRPCProxyClient({ transformer: esm_default, links: [httpBatchLink({ url: e2 })] });
}

// ../../node_modules/.pnpm/@latticexyz+store@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/store/dist/ts/index.js
var t = "event Store_SetRecord(bytes32 indexed tableId, bytes32[] keyTuple, bytes staticData, bytes32 encodedLengths, bytes dynamicData)";
var o2 = "event Store_SpliceStaticData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, bytes data)";
var s3 = "event Store_SpliceDynamicData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, uint40 deleteCount, bytes32 encodedLengths, bytes data)";
var r3 = "event Store_DeleteRecord(bytes32 indexed tableId, bytes32[] keyTuple)";
var e = [t, o2, s3, r3];
var I2 = parseAbi(e);

// ../../node_modules/.pnpm/@latticexyz+store@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/store/dist/mud.config.js
var s4 = m2({ storeImportPath: "../../", namespace: "store", userTypes: { ResourceId: { filePath: "./src/ResourceId.sol", internalType: "bytes32" }, FieldLayout: { filePath: "./src/FieldLayout.sol", internalType: "bytes32" }, Schema: { filePath: "./src/Schema.sol", internalType: "bytes32" } }, tables: { StoreHooks: { keySchema: { tableId: "ResourceId" }, valueSchema: { hooks: "bytes21[]" } }, Tables: { keySchema: { tableId: "ResourceId" }, valueSchema: { fieldLayout: "FieldLayout", keySchema: "Schema", valueSchema: "Schema", abiEncodedKeyNames: "bytes", abiEncodedFieldNames: "bytes" } }, ResourceIds: { keySchema: { resourceId: "ResourceId" }, valueSchema: { exists: "bool" } }, Hooks: { keySchema: { resourceId: "ResourceId" }, valueSchema: { hooks: "bytes21[]" }, tableIdArgument: true } } });

// ../../node_modules/.pnpm/@latticexyz+world@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/world/dist/mud.config.js
var a2 = m2({ worldImportPath: "../../", worldgenDirectory: "interfaces", worldInterfaceName: "IBaseWorld", namespace: "world", userTypes: { ResourceId: { filePath: "@latticexyz/store/src/ResourceId.sol", internalType: "bytes32" } }, tables: { NamespaceOwner: { keySchema: { namespaceId: "ResourceId" }, valueSchema: { owner: "address" } }, ResourceAccess: { keySchema: { resourceId: "ResourceId", caller: "address" }, valueSchema: { access: "bool" } }, InstalledModules: { keySchema: { moduleName: "bytes16", argumentsHash: "bytes32" }, valueSchema: { moduleAddress: "address" } }, UserDelegationControl: { keySchema: { delegator: "address", delegatee: "address" }, valueSchema: { delegationControlId: "ResourceId" } }, NamespaceDelegationControl: { keySchema: { namespaceId: "ResourceId" }, valueSchema: { delegationControlId: "ResourceId" } }, Balances: { keySchema: { namespaceId: "ResourceId" }, valueSchema: { balance: "uint256" } }, Systems: { keySchema: { systemId: "ResourceId" }, valueSchema: { system: "address", publicAccess: "bool" }, dataStruct: false }, SystemRegistry: { keySchema: { system: "address" }, valueSchema: { systemId: "ResourceId" } }, SystemHooks: { keySchema: { systemId: "ResourceId" }, valueSchema: "bytes21[]" }, FunctionSelectors: { keySchema: { functionSelector: "bytes4" }, valueSchema: { systemId: "ResourceId", systemFunctionSelector: "bytes4" }, dataStruct: false }, FunctionSignatures: { keySchema: { functionSelector: "bytes4" }, valueSchema: { functionSignature: "string" }, offchainOnly: true } }, excludeSystems: ["StoreRegistrationSystem"] });

// ../../node_modules/.pnpm/@latticexyz+block-logs-stream@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/block-logs-stream/dist/index.js
var import_debug = __toESM(require_browser());
var u = (0, import_debug.default)("mud:block-events-stream");
async function* b2({ maxBlockRange: c3 = 1000n, maxRetryCount: i2 = 3, publicClient: l5, ...r4 }) {
  let e2 = r4.fromBlock, t2 = s2(c3, r4.toBlock - e2), n = 0;
  for (; e2 <= r4.toBlock; )
    try {
      let o3 = e2 + t2;
      u("getting logs", { fromBlock: e2, toBlock: o3 });
      let s5 = await l5.getLogs({ ...r4, fromBlock: e2, toBlock: o3, strict: true });
      yield { fromBlock: e2, toBlock: o3, logs: s5 }, e2 = o3 + 1n, t2 = s2(c3, r4.toBlock - e2);
    } catch (o3) {
      if (u("error getting logs:", String(o3)), !(o3 instanceof Error))
        throw o3;
      if (o3.message.includes("rate limit exceeded") && n < i2) {
        let s5 = 2 * n;
        u(`too many requests, retrying in ${s5}s`, o3), await R(1e3 * s5), n += 1;
        continue;
      }
      if (o3.message.includes("block range exceeded")) {
        if (t2 /= 2n, t2 <= 0n)
          throw new Error("can't reduce block range any further");
        u("block range exceeded, trying a smaller block range", o3);
        continue;
      }
      throw o3;
    }
}
function F({ publicClient: c3, address: i2, events: l5, maxBlockRange: r4 }) {
  let e2, t2;
  return pipe(tap(({ endBlock: n, startBlock: o3 }) => {
    e2 ?? (e2 = o3), t2 = n;
  }), concatMap(() => e2 > t2 ? EMPTY : (u("fetching logs for block range", { fromBlock: e2, toBlock: t2 }), from(b2({ publicClient: c3, address: i2, events: l5, fromBlock: e2, toBlock: t2, maxBlockRange: r4 })).pipe(tap(({ toBlock: n }) => {
    e2 = n + 1n;
  })))));
}
function O2({ publicClient: c3, blockTag: i2 }) {
  return new Observable(function(r4) {
    return c3.watchBlocks({ blockTag: i2, emitOnBegin: true, onBlock: (e2) => r4.next(e2), onError: (e2) => r4.error(e2) });
  });
}
function D(c3, i2) {
  let l5 = Array.from(new Set(c3.map((t2) => t2.blockNumber)));
  l5.sort(m);
  let r4 = l5.map((t2) => {
    let n = c3.filter((o3) => o3.blockNumber === t2);
    if (n.length && (n.sort((o3, s5) => o3.logIndex < s5.logIndex ? -1 : o3.logIndex > s5.logIndex ? 1 : 0), !!n.length))
      return { blockNumber: t2, logs: n };
  }).filter(P2), e2 = l5.length > 0 ? l5[l5.length - 1] : null;
  return i2 != null && (e2 == null || i2 > e2) && r4.push({ blockNumber: i2, logs: [] }), r4;
}

// ../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/dist/chunk-7YRL77Z6.js
var import_debug2 = __toESM(require_browser(), 1);

// ../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/dist/index.js
var l2 = class extends r {
  constructor(t2) {
    super(`Hex value "${t2}" is an odd length (${t2.length - 2}). It must be an even length.`);
    __publicField(this, "name", "InvalidHexValueError");
  }
};
var S2 = class extends r {
  constructor(t2) {
    super(`Hex value "${t2}" has length of ${t2.length - 2}, but expected length of 64 for a schema.`);
    __publicField(this, "name", "InvalidHexLengthForSchemaError");
  }
};
var g3 = class extends r {
  constructor(t2) {
    super(`Hex value "${t2}" has length of ${t2.length - 2}, but expected length of 64 for a packed counter.`);
    __publicField(this, "name", "InvalidHexLengthForPackedCounterError");
  }
};
var A = class extends r {
  constructor(t2, c3) {
    super(`Hex value "${c3}" has length of ${c3.length - 2}, but expected length of ${g2[t2] * 2} for ${t2} type.`);
    __publicField(this, "name", "InvalidHexLengthForStaticFieldError");
  }
};
var v = class extends r {
  constructor(t2, c3) {
    super(`Hex value "${c3}" has length of ${c3.length - 2}, but expected a multiple of ${g2[t2] * 2} for ${t2}[] type.`);
    __publicField(this, "name", "InvalidHexLengthForArrayFieldError");
  }
};
var H = class extends r {
  constructor(t2, c3, i2) {
    super(`Schema "${t2}" static data length (${c3}) did not match the summed length of all static fields (${i2}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`);
    __publicField(this, "name", "SchemaStaticLengthMismatchError");
  }
};
var F2 = class extends r {
  constructor(t2, c3, i2) {
    super(`PackedCounter "${t2}" total bytes length (${c3}) did not match the summed length of all field byte lengths (${i2}).`);
    __publicField(this, "name", "PackedCounterLengthMismatchError");
  }
};
function y(e2, t2) {
  if (t2.length > 3 && t2.length % 2 !== 0)
    throw new l2(t2);
  if ((t2.length - 2) / 2 !== g2[e2])
    throw new A(e2, t2);
  switch (e2) {
    case "uint8":
    case "uint16":
    case "uint24":
    case "uint32":
    case "uint40":
    case "uint48":
    case "uint56":
    case "uint64":
    case "uint72":
    case "uint80":
    case "uint88":
    case "uint96":
    case "uint104":
    case "uint112":
    case "uint120":
    case "uint128":
    case "uint136":
    case "uint144":
    case "uint152":
    case "uint160":
    case "uint168":
    case "uint176":
    case "uint184":
    case "uint192":
    case "uint200":
    case "uint208":
    case "uint216":
    case "uint224":
    case "uint232":
    case "uint240":
    case "uint248":
    case "uint256":
    case "int8":
    case "int16":
    case "int24":
    case "int32":
    case "int40":
    case "int48":
    case "int56":
    case "int64":
    case "int72":
    case "int80":
    case "int88":
    case "int96":
    case "int104":
    case "int112":
    case "int120":
    case "int128":
    case "int136":
    case "int144":
    case "int152":
    case "int160":
    case "int168":
    case "int176":
    case "int184":
    case "int192":
    case "int200":
    case "int208":
    case "int216":
    case "int224":
    case "int232":
    case "int240":
    case "int248":
    case "int256": {
      let i2 = hexToBigInt(t2, { signed: e2.startsWith("int") }), a3 = typeof a[e2];
      if (a3 === "number")
        return Number(i2);
      if (a3 === "bigint")
        return i2;
      throw new Error(`Unexpected default value type (${a3}) for ABI type (${e2})`);
    }
    case "bytes1":
    case "bytes2":
    case "bytes3":
    case "bytes4":
    case "bytes5":
    case "bytes6":
    case "bytes7":
    case "bytes8":
    case "bytes9":
    case "bytes10":
    case "bytes11":
    case "bytes12":
    case "bytes13":
    case "bytes14":
    case "bytes15":
    case "bytes16":
    case "bytes17":
    case "bytes18":
    case "bytes19":
    case "bytes20":
    case "bytes21":
    case "bytes22":
    case "bytes23":
    case "bytes24":
    case "bytes25":
    case "bytes26":
    case "bytes27":
    case "bytes28":
    case "bytes29":
    case "bytes30":
    case "bytes31":
    case "bytes32":
      return t2;
    case "bool":
      return hexToBool(t2);
    case "address":
      return getAddress(t2);
  }
  return o(e2, `Unsupported static ABI type: ${e2}`);
}
function f2(e2, t2) {
  if (e2 === "bytes")
    return t2;
  if (e2 === "string")
    return hexToString(t2);
  if (t2.length > 3 && t2.length % 2 !== 0)
    throw new l2(t2);
  let c3 = (t2.length - 2) / 2;
  switch (e2) {
    case "uint8[]":
    case "uint16[]":
    case "uint24[]":
    case "uint32[]":
    case "uint40[]":
    case "uint48[]":
    case "uint56[]":
    case "uint64[]":
    case "uint72[]":
    case "uint80[]":
    case "uint88[]":
    case "uint96[]":
    case "uint104[]":
    case "uint112[]":
    case "uint120[]":
    case "uint128[]":
    case "uint136[]":
    case "uint144[]":
    case "uint152[]":
    case "uint160[]":
    case "uint168[]":
    case "uint176[]":
    case "uint184[]":
    case "uint192[]":
    case "uint200[]":
    case "uint208[]":
    case "uint216[]":
    case "uint224[]":
    case "uint232[]":
    case "uint240[]":
    case "uint248[]":
    case "uint256[]":
    case "int8[]":
    case "int16[]":
    case "int24[]":
    case "int32[]":
    case "int40[]":
    case "int48[]":
    case "int56[]":
    case "int64[]":
    case "int72[]":
    case "int80[]":
    case "int88[]":
    case "int96[]":
    case "int104[]":
    case "int112[]":
    case "int120[]":
    case "int128[]":
    case "int136[]":
    case "int144[]":
    case "int152[]":
    case "int160[]":
    case "int168[]":
    case "int176[]":
    case "int184[]":
    case "int192[]":
    case "int200[]":
    case "int208[]":
    case "int216[]":
    case "int224[]":
    case "int232[]":
    case "int240[]":
    case "int248[]":
    case "int256[]":
    case "bytes1[]":
    case "bytes2[]":
    case "bytes3[]":
    case "bytes4[]":
    case "bytes5[]":
    case "bytes6[]":
    case "bytes7[]":
    case "bytes8[]":
    case "bytes9[]":
    case "bytes10[]":
    case "bytes11[]":
    case "bytes12[]":
    case "bytes13[]":
    case "bytes14[]":
    case "bytes15[]":
    case "bytes16[]":
    case "bytes17[]":
    case "bytes18[]":
    case "bytes19[]":
    case "bytes20[]":
    case "bytes21[]":
    case "bytes22[]":
    case "bytes23[]":
    case "bytes24[]":
    case "bytes25[]":
    case "bytes26[]":
    case "bytes27[]":
    case "bytes28[]":
    case "bytes29[]":
    case "bytes30[]":
    case "bytes31[]":
    case "bytes32[]":
    case "bool[]":
    case "address[]": {
      let i2 = r2(e2), a3 = g2[i2];
      if (c3 % a3 !== 0)
        throw new v(i2, t2);
      return new Array(c3 / a3).fill(void 0).map((r4, s5) => {
        let o3 = sliceHex(t2, s5 * a3, (s5 + 1) * a3);
        return y(i2, o3);
      });
    }
  }
  return o(e2, `Unsupported dynamic ABI type: ${e2}`);
}
function w2(e2) {
  if (e2.length !== 66)
    throw new g3(e2);
  let t2 = y("uint56", N(e2, 32 - 7, 32)), c3 = f2("uint40[]", N(e2, 0, 32 - 7)), i2 = Object.freeze([...c3].reverse()), a3 = BigInt(i2.reduce((n, r4) => n + r4, 0));
  if (a3 !== t2)
    throw new F2(e2, t2, a3);
  return { totalByteLength: t2, fieldByteLengths: i2 };
}
function T2(e2) {
  return e2.reduce((t2, c3) => t2 + g2[c3], 0);
}
function j(e2, t2) {
  let c3 = [], i2 = 0;
  e2.staticFields.forEach((r4) => {
    let s5 = g2[r4], o3 = y(r4, N(t2, i2, i2 + s5));
    i2 += s5, c3.push(o3);
  });
  let a3 = T2(e2.staticFields), n = i2;
  if (n !== a3 && console.warn("Decoded static data length does not match value schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?", { expectedLength: a3, actualLength: n, bytesOffset: i2 }), e2.dynamicFields.length > 0) {
    let r4 = w2(N(t2, i2, i2 + 32));
    i2 += 32, e2.dynamicFields.forEach((o3, d) => {
      let m4 = r4.fieldByteLengths[d];
      if (m4 > 0) {
        let h = f2(o3, N(t2, i2, i2 + m4));
        i2 += m4, c3.push(h);
      } else
        c3.push(s[o3]);
    });
    let s5 = i2 - 32 - n;
    BigInt(s5) !== r4.totalByteLength && console.warn("Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?", { expectedLength: r4.totalByteLength, actualLength: s5, bytesOffset: i2 });
  }
  return c3;
}
function E2(e2, t2) {
  let c3 = Object.values(e2).filter(f), i2 = Object.values(e2).filter(x), a3 = j({ staticFields: c3, dynamicFields: i2 }, t2);
  return Object.fromEntries(Object.keys(e2).map((n, r4) => [n, a3[r4]]));
}
function zt(e2, { staticData: t2, encodedLengths: c3, dynamicData: i2 }) {
  return E2(e2, concatHex([N(t2, 0, T2(Object.values(e2).filter(f))), c3, i2]));
}
function p2(e2, t2) {
  if (b(e2) && Array.isArray(t2)) {
    let c3 = r2(e2);
    return t2.length === 0 ? "0x" : encodePacked(t2.map(() => c3), t2);
  }
  return encodePacked([e2], [t2]);
}
function O3(e2, t2) {
  return t2.map((c3, i2) => encodeAbiParameters([{ type: e2.staticFields[i2] }], [c3]));
}
function Xt(e2, t2) {
  let c3 = Object.values(e2).filter(f);
  return O3({ staticFields: c3, dynamicFields: [] }, Object.values(t2));
}
function K(e2) {
  let t2 = e2.map(size).reverse(), c3 = t2.reduce((i2, a3) => i2 + BigInt(a3), 0n);
  return padHex(concatHex([...t2.map((i2) => p2("uint40", i2)), p2("uint56", c3)]), { size: 32, dir: "left" });
}
function z2(e2, t2) {
  let c3 = Object.entries(e2), i2 = c3.filter(([, o3]) => f(o3)), a3 = c3.filter(([, o3]) => x(o3)), n = i2.map(([o3, d]) => p2(d, t2[o3])), r4 = a3.map(([o3, d]) => p2(d, t2[o3])), s5 = K(r4);
  return { staticData: concatHex(n), encodedLengths: s5, dynamicData: concatHex(r4) };
}
function L(e2) {
  if (e2.length !== 66)
    throw new S2(e2);
  let t2 = hexToNumber(sliceHex(e2, 0, 2)), c3 = hexToNumber(sliceHex(e2, 2, 3)), i2 = hexToNumber(sliceHex(e2, 3, 4)), a3 = [], n = [];
  for (let s5 = 4; s5 < 4 + c3; s5++) {
    let o3 = hexToNumber(sliceHex(e2, s5, s5 + 1));
    a3.push(i[o3]);
  }
  for (let s5 = 4 + c3; s5 < 4 + c3 + i2; s5++) {
    let o3 = hexToNumber(sliceHex(e2, s5, s5 + 1));
    n.push(i[o3]);
  }
  let r4 = a3.reduce((s5, o3) => s5 + g2[o3], 0);
  if (r4 !== t2)
    throw console.warn(`Schema "${e2}" static data length (${t2}) did not match the summed length of all static fields (${r4}). Is \`staticAbiTypeToByteLength\` up to date with Solidity schema types?`), new H(e2, t2, r4);
  return { staticFields: a3, dynamicFields: n };
}

// ../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/dist/chunk-7YRL77Z6.js
function T3(a3) {
  return S(a3, (n) => n.type);
}
var k = Ce(s4).tables;
var Ie = Ce(a2).tables;
var He = k.Tables.tableId;
var Oe = { ...k.Tables, keySchema: T3(k.Tables.keySchema), valueSchema: T3(k.Tables.valueSchema) };
var F3 = ((i2) => (i2.INITIALIZE = "initialize", i2.SNAPSHOT = "snapshot", i2.RPC = "rpc", i2.LIVE = "live", i2))(F3 || {});
var Q2 = Object.keys(s4.tables).map((a3) => O({ type: s4.tables[a3].offchainOnly ? "offchainTable" : "table", namespace: s4.namespace, name: a3 }));
var X2 = Object.keys(a2.tables).map((a3) => O({ type: a2.tables[a3].offchainOnly ? "offchainTable" : "table", namespace: a2.namespace, name: a3 }));
var W = [...Q2, ...X2];
var M = (0, import_debug2.default)("mud:store-sync");
var l3 = M.extend("createStoreSync");
var ye = W.map((a3) => ({ tableId: a3 }));
async function Xe({ storageAdapter: a3, onProgress: n, publicClient: m4, address: v2, filters: i2 = [], tableIds: C = [], startBlock: L2 = 0n, maxBlockRange: D2, initialState: I3, indexerUrl: y2 }) {
  let h = i2.length || C.length ? [...i2, ...C.map((e2) => ({ tableId: e2 })), ...ye] : [], H2 = defer(async () => {
    var _a2;
    if (I3)
      return I3;
    if (!y2)
      return;
    l3("fetching initial state from indexer", y2), n == null ? void 0 : n({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Fetching snapshot from indexer" });
    let e2 = T({ url: y2 }), t2 = ((_a2 = m4.chain) == null ? void 0 : _a2.id) ?? await m4.getChainId(), r4 = await e2.findAll.query({ chainId: t2, address: v2, filters: h });
    return n == null ? void 0 : n({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: 0n, message: "Fetched snapshot from indexer" }), r4;
  }).pipe(catchError((e2) => (l3("error fetching initial state from indexer", e2), n == null ? void 0 : n({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: L2, message: "Failed to fetch snapshot from indexer" }), of(void 0))), shareReplay(1)), K3 = H2.pipe(map((e2) => (e2 == null ? void 0 : e2.blockNumber) ?? L2), tap((e2) => l3("starting sync from block", e2))), z3 = H2.pipe(filter((e2) => e2 != null && e2.blockNumber != null && e2.tables.length > 0), concatMap(async ({ blockNumber: e2, tables: t2 }) => {
    l3("hydrating from initial state to block", e2), n == null ? void 0 : n({ step: "snapshot", percentage: 0, latestBlockNumber: 0n, lastBlockNumberProcessed: e2, message: "Hydrating from snapshot" });
    let r4 = t2.flatMap((s5) => s5.records.map((g4) => ({ eventName: "Store_SetRecord", address: s5.address, args: { tableId: s5.tableId, keyTuple: Xt(s5.keySchema, g4.key), ...z2(s5.valueSchema, g4.value) } }))), c3 = Math.max(100, Math.floor(r4.length / 50)), o3 = Array.from(c(r4, c3));
    for (let [s5, g4] of o3.entries())
      await a3({ blockNumber: e2, logs: g4 }), n == null ? void 0 : n({ step: "snapshot", percentage: (s5 + g4.length) / o3.length * 100, latestBlockNumber: 0n, lastBlockNumberProcessed: e2, message: "Hydrating from snapshot" });
    return n == null ? void 0 : n({ step: "snapshot", percentage: 100, latestBlockNumber: 0n, lastBlockNumberProcessed: e2, message: "Hydrated from snapshot" }), { blockNumber: e2, logs: r4 };
  }), shareReplay(1)), O4 = O2({ publicClient: m4, blockTag: "latest" }).pipe(shareReplay(1)), P3 = O4.pipe(map((e2) => e2.number), tap((e2) => {
    l3("latest block number", e2);
  }), shareReplay(1)), f4 = null, p3 = null, R3 = combineLatest([K3, P3]).pipe(map(([e2, t2]) => ({ startBlock: e2, endBlock: t2 })), tap((e2) => {
    f4 = e2.startBlock, p3 = e2.endBlock;
  }), F({ publicClient: m4, address: v2, events: I2, maxBlockRange: D2 }), map(({ toBlock: e2, logs: t2 }) => {
    if (!h.length)
      return { toBlock: e2, logs: t2 };
    let r4 = t2.filter((c3) => h.some((o3) => o3.tableId === c3.args.tableId && (o3.key0 == null || o3.key0 === c3.args.keyTuple[0]) && (o3.key1 == null || o3.key1 === c3.args.keyTuple[1])));
    return { toBlock: e2, logs: r4 };
  }), mergeMap(({ toBlock: e2, logs: t2 }) => from(D(t2, e2))), share()), u3 = null, w4 = concat(z3, R3.pipe(concatMap(async (e2) => (await a3(e2), e2)), tap(({ blockNumber: e2, logs: t2 }) => {
    if (l3("stored", t2.length, "logs for block", e2), u3 = e2, f4 != null && p3 != null)
      if (e2 < p3) {
        let r4 = p3 - f4, c3 = u3 - f4;
        n == null ? void 0 : n({ step: "rpc", percentage: Number(c3 * 1000n / r4) / 10, latestBlockNumber: p3, lastBlockNumberProcessed: u3, message: "Hydrating from RPC" });
      } else
        n == null ? void 0 : n({ step: "live", percentage: 100, latestBlockNumber: p3, lastBlockNumberProcessed: u3, message: "All caught up!" });
  }))).pipe(share()), q2 = 10, U = w4.pipe(scan((e2, t2) => [t2, ...e2].slice(0, q2), []), filter((e2) => e2.length > 0), shareReplay(1));
  async function Z2(e2) {
    l3("waiting for tx", e2);
    let t2 = U.pipe(concatMap(async (r4) => {
      if (r4.flatMap((o3) => o3.logs.map((s5) => s5.transactionHash).filter(P2)).includes(e2))
        return true;
      try {
        let o3 = r4[0];
        l3("fetching tx receipt for block", o3.blockNumber);
        let s5 = await m4.getTransactionReceipt({ hash: e2 });
        return o3.blockNumber >= s5.blockNumber;
      } catch (o3) {
        if (o3 instanceof TransactionReceiptNotFoundError)
          return false;
        throw o3;
      }
    }), tap((r4) => l3("has tx?", e2, r4)));
    await firstValueFrom(t2.pipe(filter(identity)));
  }
  return { latestBlock$: O4, latestBlockNumber$: P3, blockLogs$: R3, storedBlockLogs$: w4, waitForTransaction: Z2 };
}

// ../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/dist/chunk-4J5NR5O4.js
function x2(e2) {
  return e2.eventName === "Store_SetRecord" && e2.args.tableId === k.Tables.tableId;
}
function V(e2) {
  let [o3, ...p3] = e2.args.keyTuple;
  p3.length && console.warn("registerSchema event is expected to have only one key in key tuple, but got multiple", e2);
  let s5 = I(o3), a3 = E2(Oe.valueSchema, concatHex([e2.args.staticData, e2.args.encodedLengths, e2.args.dynamicData])), S3 = L(a3.keySchema), c3 = L(a3.valueSchema), b3 = decodeAbiParameters(parseAbiParameters("string[]"), a3.abiEncodedKeyNames)[0], g4 = decodeAbiParameters(parseAbiParameters("string[]"), a3.abiEncodedFieldNames)[0], h = [...c3.staticFields, ...c3.dynamicFields];
  return { address: e2.address, tableId: o3, namespace: s5.namespace, name: s5.name, keySchema: Object.fromEntries(S3.staticFields.map((t2, r4) => [b3[r4], t2])), valueSchema: Object.fromEntries(h.map((t2, r4) => [g4[r4], t2])) };
}

// ../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/dist/recs/index.js
function K2(e2) {
  if (!isHex(e2))
    throw new Error(`entity ${e2} is not a hex string`);
  let r4 = size(e2);
  if (r4 % 32 !== 0)
    throw new Error(`entity length ${r4} is not a multiple of 32 bytes`);
  return new Array(r4 / 32).fill(0).map((i2, o3) => sliceHex(e2, o3 * 32, (o3 + 1) * 32));
}
function dt(e2, r4) {
  let i2 = K2(r4);
  if (i2.length !== Object.keys(e2).length)
    throw new Error(`entity key tuple length ${i2.length} does not match key schema length ${Object.keys(e2).length}`);
  return Object.fromEntries(Object.entries(e2).map(([o3, T4], S3) => [o3, decodeAbiParameters([{ type: T4 }], i2[S3])[0]]));
}
function u2(e2) {
  return concatHex(e2);
}
function w3(e2, r4) {
  if (Object.keys(e2).length !== Object.keys(r4).length)
    throw new Error(`key length ${Object.keys(r4).length} does not match key schema length ${Object.keys(e2).length}`);
  return u2(Object.entries(e2).map(([i2, o3]) => encodeAbiParameters([{ type: o3 }], [r4[i2]])));
}
function Ct(e2) {
  var _a2, _b2, _c2, _d2;
  return ((_a2 = e2.metadata) == null ? void 0 : _a2.componentName) != null && ((_b2 = e2.metadata) == null ? void 0 : _b2.tableName) != null && ((_c2 = e2.metadata) == null ? void 0 : _c2.keySchema) != null && ((_d2 = e2.metadata) == null ? void 0 : _d2.valueSchema) != null;
}
var l4 = M.extend("recs");
function j2(e2) {
  return { RegisteredTables: ie(e2, { table: P.T }, { metadata: { componentName: "RegisteredTables" } }), SyncProgress: ie(e2, { step: P.String, message: P.String, percentage: P.Number, latestBlockNumber: P.BigInt, lastBlockNumberProcessed: P.BigInt }, { metadata: { componentName: "SyncProgress" } }) };
}
function R2(e2) {
  return w3({ address: "address", namespace: "bytes16", name: "bytes16" }, { address: e2.address, namespace: stringToHex(e2.namespace, { size: 16 }), name: stringToHex(e2.name, { size: 16 }) });
}
var f3 = u2([]);
var W2 = { uint8: P.Number, uint16: P.Number, uint24: P.Number, uint32: P.Number, uint40: P.Number, uint48: P.Number, uint56: P.BigInt, uint64: P.BigInt, uint72: P.BigInt, uint80: P.BigInt, uint88: P.BigInt, uint96: P.BigInt, uint104: P.BigInt, uint112: P.BigInt, uint120: P.BigInt, uint128: P.BigInt, uint136: P.BigInt, uint144: P.BigInt, uint152: P.BigInt, uint160: P.BigInt, uint168: P.BigInt, uint176: P.BigInt, uint184: P.BigInt, uint192: P.BigInt, uint200: P.BigInt, uint208: P.BigInt, uint216: P.BigInt, uint224: P.BigInt, uint232: P.BigInt, uint240: P.BigInt, uint248: P.BigInt, uint256: P.BigInt, int8: P.Number, int16: P.Number, int24: P.Number, int32: P.Number, int40: P.Number, int48: P.Number, int56: P.BigInt, int64: P.BigInt, int72: P.BigInt, int80: P.BigInt, int88: P.BigInt, int96: P.BigInt, int104: P.BigInt, int112: P.BigInt, int120: P.BigInt, int128: P.BigInt, int136: P.BigInt, int144: P.BigInt, int152: P.BigInt, int160: P.BigInt, int168: P.BigInt, int176: P.BigInt, int184: P.BigInt, int192: P.BigInt, int200: P.BigInt, int208: P.BigInt, int216: P.BigInt, int224: P.BigInt, int232: P.BigInt, int240: P.BigInt, int248: P.BigInt, int256: P.BigInt, bytes1: P.String, bytes2: P.String, bytes3: P.String, bytes4: P.String, bytes5: P.String, bytes6: P.String, bytes7: P.String, bytes8: P.String, bytes9: P.String, bytes10: P.String, bytes11: P.String, bytes12: P.String, bytes13: P.String, bytes14: P.String, bytes15: P.String, bytes16: P.String, bytes17: P.String, bytes18: P.String, bytes19: P.String, bytes20: P.String, bytes21: P.String, bytes22: P.String, bytes23: P.String, bytes24: P.String, bytes25: P.String, bytes26: P.String, bytes27: P.String, bytes28: P.String, bytes29: P.String, bytes30: P.String, bytes31: P.String, bytes32: P.String, bool: P.Boolean, address: P.String, "uint8[]": P.NumberArray, "uint16[]": P.NumberArray, "uint24[]": P.NumberArray, "uint32[]": P.NumberArray, "uint40[]": P.NumberArray, "uint48[]": P.NumberArray, "uint56[]": P.BigIntArray, "uint64[]": P.BigIntArray, "uint72[]": P.BigIntArray, "uint80[]": P.BigIntArray, "uint88[]": P.BigIntArray, "uint96[]": P.BigIntArray, "uint104[]": P.BigIntArray, "uint112[]": P.BigIntArray, "uint120[]": P.BigIntArray, "uint128[]": P.BigIntArray, "uint136[]": P.BigIntArray, "uint144[]": P.BigIntArray, "uint152[]": P.BigIntArray, "uint160[]": P.BigIntArray, "uint168[]": P.BigIntArray, "uint176[]": P.BigIntArray, "uint184[]": P.BigIntArray, "uint192[]": P.BigIntArray, "uint200[]": P.BigIntArray, "uint208[]": P.BigIntArray, "uint216[]": P.BigIntArray, "uint224[]": P.BigIntArray, "uint232[]": P.BigIntArray, "uint240[]": P.BigIntArray, "uint248[]": P.BigIntArray, "uint256[]": P.BigIntArray, "int8[]": P.NumberArray, "int16[]": P.NumberArray, "int24[]": P.NumberArray, "int32[]": P.NumberArray, "int40[]": P.NumberArray, "int48[]": P.NumberArray, "int56[]": P.BigIntArray, "int64[]": P.BigIntArray, "int72[]": P.BigIntArray, "int80[]": P.BigIntArray, "int88[]": P.BigIntArray, "int96[]": P.BigIntArray, "int104[]": P.BigIntArray, "int112[]": P.BigIntArray, "int120[]": P.BigIntArray, "int128[]": P.BigIntArray, "int136[]": P.BigIntArray, "int144[]": P.BigIntArray, "int152[]": P.BigIntArray, "int160[]": P.BigIntArray, "int168[]": P.BigIntArray, "int176[]": P.BigIntArray, "int184[]": P.BigIntArray, "int192[]": P.BigIntArray, "int200[]": P.BigIntArray, "int208[]": P.BigIntArray, "int216[]": P.BigIntArray, "int224[]": P.BigIntArray, "int232[]": P.BigIntArray, "int240[]": P.BigIntArray, "int248[]": P.BigIntArray, "int256[]": P.BigIntArray, "bytes1[]": P.StringArray, "bytes2[]": P.StringArray, "bytes3[]": P.StringArray, "bytes4[]": P.StringArray, "bytes5[]": P.StringArray, "bytes6[]": P.StringArray, "bytes7[]": P.StringArray, "bytes8[]": P.StringArray, "bytes9[]": P.StringArray, "bytes10[]": P.StringArray, "bytes11[]": P.StringArray, "bytes12[]": P.StringArray, "bytes13[]": P.StringArray, "bytes14[]": P.StringArray, "bytes15[]": P.StringArray, "bytes16[]": P.StringArray, "bytes17[]": P.StringArray, "bytes18[]": P.StringArray, "bytes19[]": P.StringArray, "bytes20[]": P.StringArray, "bytes21[]": P.StringArray, "bytes22[]": P.StringArray, "bytes23[]": P.StringArray, "bytes24[]": P.StringArray, "bytes25[]": P.StringArray, "bytes26[]": P.StringArray, "bytes27[]": P.StringArray, "bytes28[]": P.StringArray, "bytes29[]": P.StringArray, "bytes30[]": P.StringArray, "bytes31[]": P.StringArray, "bytes32[]": P.StringArray, "bool[]": P.T, "address[]": P.StringArray, bytes: P.String, string: P.String };
function M2(e2, r4) {
  return ie(e2, { ...Object.fromEntries(Object.entries(r4.valueSchema).map(([i2, { type: o3 }]) => [i2, W2[o3]])), __staticData: P.OptionalString, __encodedLengths: P.OptionalString, __dynamicData: P.OptionalString }, { id: r4.tableId, metadata: { componentName: r4.name, tableName: `${r4.namespace}:${r4.name}`, keySchema: S(r4.keySchema, ({ type: i2 }) => i2), valueSchema: S(r4.valueSchema, ({ type: i2 }) => i2) } });
}
function B(e2, r4) {
  return S(r4, (i2) => M2(e2, i2));
}
var st = Ce(s4).tables;
var mt = Ce(a2).tables;
function q({ world: e2, tables: r4, shouldSkipUpdateStream: i2 }) {
  e2.registerEntity({ id: f3 });
  let o3 = { ...B(e2, r4), ...B(e2, st), ...B(e2, mt), ...j2(e2) };
  async function T4({ logs: S3 }) {
    var _a2, _b2;
    let C = S3.filter(x2).map(V);
    for (let n of C) {
      let y2 = R2(n);
      le(o3.RegisteredTables, y2) ? console.warn("table already registered, ignoring", { newTable: n, existingTable: (_a2 = g(o3.RegisteredTables, y2)) == null ? void 0 : _a2.table }) : E(o3.RegisteredTables, y2, { table: n }, { skipUpdateStream: i2 == null ? void 0 : i2() });
    }
    for (let n of S3) {
      let { namespace: y2, name: A2 } = I(n.args.tableId), a3 = (_b2 = g(o3.RegisteredTables, R2({ address: n.address, namespace: y2, name: A2 }))) == null ? void 0 : _b2.table;
      if (!a3) {
        l4(`skipping update for unknown table: ${y2}:${A2} at ${n.address}`);
        continue;
      }
      let g4 = e2.components.find((s5) => s5.id === a3.tableId);
      if (!g4) {
        l4(`skipping update for unknown component: ${a3.tableId} (${a3.namespace}:${a3.name}). Available components: ${Object.keys(o3)}`);
        continue;
      }
      let m4 = u2(n.args.keyTuple);
      if (n.eventName === "Store_SetRecord") {
        let s5 = zt(a3.valueSchema, n.args);
        l4("setting component", { namespace: a3.namespace, name: a3.name, entity: m4, value: s5 }), E(g4, m4, { ...s5, __staticData: n.args.staticData, __encodedLengths: n.args.encodedLengths, __dynamicData: n.args.dynamicData }, { skipUpdateStream: i2 == null ? void 0 : i2() });
      } else if (n.eventName === "Store_SpliceStaticData") {
        let s5 = g(g4, m4), p3 = (s5 == null ? void 0 : s5.__staticData) ?? "0x", c3 = Pt(p3, n.args.start, size(n.args.data), n.args.data), b3 = zt(a3.valueSchema, { staticData: c3, encodedLengths: (s5 == null ? void 0 : s5.__encodedLengths) ?? "0x", dynamicData: (s5 == null ? void 0 : s5.__dynamicData) ?? "0x" });
        l4("setting component via splice static", { namespace: a3.namespace, name: a3.name, entity: m4, previousStaticData: p3, newStaticData: c3, previousValue: s5, newValue: b3 }), E(g4, m4, { ...b3, __staticData: c3 }, { skipUpdateStream: i2 == null ? void 0 : i2() });
      } else if (n.eventName === "Store_SpliceDynamicData") {
        let s5 = g(g4, m4), p3 = (s5 == null ? void 0 : s5.__dynamicData) ?? "0x", c3 = Pt(p3, n.args.start, n.args.deleteCount, n.args.data), b3 = zt(a3.valueSchema, { staticData: (s5 == null ? void 0 : s5.__staticData) ?? "0x", encodedLengths: n.args.encodedLengths, dynamicData: c3 });
        l4("setting component via splice dynamic", { namespace: a3.namespace, name: a3.name, entity: m4, previousDynamicData: p3, newDynamicData: c3, previousValue: s5, newValue: b3 }), E(g4, m4, { ...b3, __encodedLengths: n.args.encodedLengths, __dynamicData: c3 }, { skipUpdateStream: i2 == null ? void 0 : i2() });
      } else
        n.eventName === "Store_DeleteRecord" && (l4("deleting component", { namespace: a3.namespace, name: a3.name, entity: m4 }), ue(g4, m4, { skipUpdateStream: i2 == null ? void 0 : i2() }));
    }
  }
  return { storageAdapter: T4, components: o3 };
}
async function ke({ world: e2, config: r4, tables: i2, startSync: o3 = true, ...T4 }) {
  let S3 = { ...Ce(r4).tables, ...i2 }, { storageAdapter: C, components: n } = q({ world: e2, tables: S3, shouldSkipUpdateStream: () => {
    var _a2;
    return ((_a2 = g(n.SyncProgress, f3)) == null ? void 0 : _a2.step) !== "live";
  } }), y2 = await Xe({ storageAdapter: C, config: r4, ...T4, onProgress: ({ step: g4, percentage: m4, latestBlockNumber: s5, lastBlockNumberProcessed: p3, message: c3 }) => {
    var _a2;
    if (((_a2 = g(n.SyncProgress, f3)) == null ? void 0 : _a2.step) !== "live" && (E(n.SyncProgress, f3, { step: g4, percentage: m4, latestBlockNumber: s5, lastBlockNumberProcessed: p3, message: c3 }), g4 === "live"))
      for (let b3 of Object.values(n)) {
        let I3 = b3;
        for (let E3 of I3.entities()) {
          let D2 = g(I3, E3);
          I3.update$.next({ component: I3, entity: E3, value: [D2, D2] });
        }
      }
  } }), A2 = o3 ? y2.storedBlockLogs$.subscribe() : null, a3 = () => {
    A2 == null ? void 0 : A2.unsubscribe();
  };
  return e2.registerDisposer(a3), { ...y2, components: n, stopSync: a3 };
}

export {
  K2 as K,
  dt,
  u2 as u,
  w3 as w,
  Ct,
  f3 as f,
  q,
  ke
};
/*! Bundled license information:

@trpc/client/dist/httpUtils-1efcb902.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-UYNVZXVO.js.map
